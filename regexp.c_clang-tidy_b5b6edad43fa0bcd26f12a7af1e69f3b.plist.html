<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/regexp.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/*\n * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()\n *\n * NOTICE:\n *\n * This is NOT the original regular expression code as written by Henry\n * Spencer.  This code has been modified specifically for use with the VIM\n * editor, and should not be used separately from Vim.  If you want a good\n * regular expression library, get the original code.  The copyright notice\n * that follows is from the original.\n *\n * END NOTICE\n *\n *\tCopyright (c) 1986 by University of Toronto.\n *\tWritten by Henry Spencer.  Not derived from licensed software.\n *\n *\tPermission is granted to anyone to use this software for any\n *\tpurpose on any computer system, and to redistribute it freely,\n *\tsubject to the following restrictions:\n *\n *\t1. The author is not responsible for the consequences of use of\n *\t\tthis software, no matter how awful, even if they arise\n *\t\tfrom defects in it.\n *\n *\t2. The origin of this software must not be misrepresented, either\n *\t\tby explicit claim or by omission.\n *\n *\t3. Altered versions must be plainly marked as such, and must not\n *\t\tbe misrepresented as being the original software.\n *\n * Beware that some of this code is subtly aware of the way operator\n * precedence is structured in regular expressions.  Serious changes in\n * regular-expression syntax might require a total rethink.\n *\n * Changes have been made by Tony Andrews, Olaf 'Rhialto' Seibert, Robert\n * Webb, Ciaran McCreesh and Bram Moolenaar.\n * Named character class support added by Walter Briscoe (1998 Jul 01)\n */\n\n// By default: do not create debugging logs or files related to regular\n// expressions, even when compiling with -DDEBUG.\n// Uncomment the second line to get the regexp debugging.\n// #undef REGEXP_DEBUG\n// #define REGEXP_DEBUG\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/eval/userfunc.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/plines.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/strings.h\"\n\n#ifdef REGEXP_DEBUG\n/* show/save debugging data when BT engine is used */\n# define BT_REGEXP_DUMP\n/* save the debugging data to a file instead of displaying it */\n# define BT_REGEXP_LOG\n# define BT_REGEXP_DEBUG_LOG\n# define BT_REGEXP_DEBUG_LOG_NAME       \"bt_regexp_debug.log\"\n#endif\n\n/*\n * The \"internal use only\" fields in regexp_defs.h are present to pass info from\n * compile to execute that permits the execute phase to run lots faster on\n * simple cases.  They are:\n *\n * regstart\tchar that must begin a match; NUL if none obvious; Can be a\n *\t\tmulti-byte character.\n * reganch\tis the match anchored (at beginning-of-line only)?\n * regmust\tstring (pointer into program) that match must include, or NULL\n * regmlen\tlength of regmust string\n * regflags\tRF_ values or'ed together\n *\n * Regstart and reganch permit very fast decisions on suitable starting points\n * for a match, cutting down the work a lot.  Regmust permits fast rejection\n * of lines that cannot possibly match.  The regmust tests are costly enough\n * that vim_regcomp() supplies a regmust only if the r.e. contains something\n * potentially expensive (at present, the only such thing detected is * or +\n * at the start of the r.e., which can involve a lot of backup).  Regmlen is\n * supplied because the test in vim_regexec() needs it and vim_regcomp() is\n * computing it anyway.\n */\n\n/*\n * Structure for regexp \"program\".  This is essentially a linear encoding\n * of a nondeterministic finite-state machine (aka syntax charts or\n * \"railroad normal form\" in parsing technology).  Each node is an opcode\n * plus a \"next\" pointer, possibly plus an operand.  \"Next\" pointers of\n * all nodes except BRANCH and BRACES_COMPLEX implement concatenation; a \"next\"\n * pointer with a BRANCH on both ends of it is connecting two alternatives.\n * (Here we have one of the subtle syntax dependencies:\tan individual BRANCH\n * (as opposed to a collection of them) is never concatenated with anything\n * because of operator precedence).  The \"next\" pointer of a BRACES_COMPLEX\n * node points to the node after the stuff to be repeated.\n * The operand of some types of node is a literal string; for others, it is a\n * node leading into a sub-FSM.  In particular, the operand of a BRANCH node\n * is the first node of the branch.\n * (NB this is *not* a tree structure: the tail of the branch connects to the\n * thing following the set of BRANCHes.)\n *\n * pattern\tis coded like:\n *\n *\t\t\t  +-----------------+\n *\t\t\t  |\t\t    V\n * <aa>\\|<bb>\tBRANCH <aa> BRANCH <bb> --> END\n *\t\t     |\t    ^\t |\t    ^\n *\t\t     +------+\t +----------+\n *\n *\n *\t\t       +------------------+\n *\t\t       V\t\t  |\n * <aa>*\tBRANCH BRANCH <aa> --> BACK BRANCH --> NOTHING --> END\n *\t\t     |\t    |\t\t    ^\t\t\t   ^\n *\t\t     |\t    +---------------+\t\t\t   |\n *\t\t     +---------------------------------------------+\n *\n *\n *\t\t       +----------------------+\n *\t\t       V\t\t      |\n * <aa>\\+\tBRANCH <aa> --> BRANCH --> BACK  BRANCH --> NOTHING --> END\n *\t\t     |\t\t     |\t\t ^\t\t\t^\n *\t\t     |\t\t     +-----------+\t\t\t|\n *\t\t     +--------------------------------------------------+\n *\n *\n *\t\t\t\t\t+-------------------------+\n *\t\t\t\t\tV\t\t\t  |\n * <aa>\\{}\tBRANCH BRACE_LIMITS --> BRACE_COMPLEX <aa> --> BACK  END\n *\t\t     |\t\t\t\t    |\t\t     ^\n *\t\t     |\t\t\t\t    +----------------+\n *\t\t     +-----------------------------------------------+\n *\n *\n * <aa>\\@!<bb>\tBRANCH NOMATCH <aa> --> END  <bb> --> END\n *\t\t     |\t     |\t\t      ^       ^\n *\t\t     |\t     +----------------+       |\n *\t\t     +--------------------------------+\n *\n *\t\t\t\t\t\t      +---------+\n *\t\t\t\t\t\t      |\t\tV\n * \\z[abc]\tBRANCH BRANCH  a  BRANCH  b  BRANCH  c\tBRANCH\tNOTHING --> END\n *\t\t     |\t    |\t       |\t  |\t^\t\t    ^\n *\t\t     |\t    |\t       |\t  +-----+\t\t    |\n *\t\t     |\t    |\t       +----------------+\t\t    |\n *\t\t     |\t    +---------------------------+\t\t    |\n *\t\t     +------------------------------------------------------+\n *\n * They all start with a BRANCH for \"\\|\" alternatives, even when there is only\n * one alternative.\n */\n\n/*\n * The opcodes are:\n */\n\n/* definition\tnumber\t\t   opnd?    meaning */\n#define END             0       /*\tEnd of program or NOMATCH operand. */\n#define BOL             1       /*\tMatch \"\" at beginning of line. */\n#define EOL             2       /*\tMatch \"\" at end of line. */\n#define BRANCH          3       /* node Match this alternative, or the\n                                 *\tnext... */\n#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */\n#define EXACTLY         5       /* str\tMatch this string. */\n#define NOTHING         6       /*\tMatch empty string. */\n#define STAR            7       /* node Match this (simple) thing 0 or more\n                                 *\ttimes. */\n#define PLUS            8       /* node Match this (simple) thing 1 or more\n                                 *\ttimes. */\n#define MATCH           9       /* node match the operand zero-width */\n#define NOMATCH         10      /* node check for no match with operand */\n#define BEHIND          11      /* node look behind for a match with operand */\n#define NOBEHIND        12      /* node look behind for no match with operand */\n#define SUBPAT          13      /* node match the operand here */\n#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and\n                                 *\tn times (\\{m,n\\}). */\n#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */\n#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */\n#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE\n                                 *\tand BRACE_COMPLEX. */\n#define NEWL            18      /*\tMatch line-break */\n#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */\n\n\n/* character classes: 20-48 normal, 50-78 include a line-break */\n#define ADD_NL          30\n#define FIRST_NL        ANY + ADD_NL\n#define ANY             20      /*\tMatch any one character. */\n#define ANYOF           21      /* str\tMatch any character in this string. */\n#define ANYBUT          22      /* str\tMatch any character not in this\n                                 *\tstring. */\n#define IDENT           23      /*\tMatch identifier char */\n#define SIDENT          24      /*\tMatch identifier char but no digit */\n#define KWORD           25      /*\tMatch keyword char */\n#define SKWORD          26      /*\tMatch word char but no digit */\n#define FNAME           27      /*\tMatch file name char */\n#define SFNAME          28      /*\tMatch file name char but no digit */\n#define PRINT           29      /*\tMatch printable char */\n#define SPRINT          30      /*\tMatch printable char but no digit */\n#define WHITE           31      /*\tMatch whitespace char */\n#define NWHITE          32      /*\tMatch non-whitespace char */\n#define DIGIT           33      /*\tMatch digit char */\n#define NDIGIT          34      /*\tMatch non-digit char */\n#define HEX             35      /*\tMatch hex char */\n#define NHEX            36      /*\tMatch non-hex char */\n#define OCTAL           37      /*\tMatch octal char */\n#define NOCTAL          38      /*\tMatch non-octal char */\n#define WORD            39      /*\tMatch word char */\n#define NWORD           40      /*\tMatch non-word char */\n#define HEAD            41      /*\tMatch head char */\n#define NHEAD           42      /*\tMatch non-head char */\n#define ALPHA           43      /*\tMatch alpha char */\n#define NALPHA          44      /*\tMatch non-alpha char */\n#define LOWER           45      /*\tMatch lowercase char */\n#define NLOWER          46      /*\tMatch non-lowercase char */\n#define UPPER           47      /*\tMatch uppercase char */\n#define NUPPER          48      /*\tMatch non-uppercase char */\n#define LAST_NL         NUPPER + ADD_NL\n// -V:WITH_NL:560\n#define WITH_NL(op)     ((op) >= FIRST_NL && (op) <= LAST_NL)\n\n#define MOPEN           80   // -89 Mark this point in input as start of\n                             //     \\( \u2026 \\) subexpr.  MOPEN + 0 marks start of\n                             //     match.\n#define MCLOSE          90   // -99 Analogous to MOPEN.  MCLOSE + 0 marks\n                             //     end of match.\n#define BACKREF         100  // -109 node Match same string again \\1-\\9.\n\n# define ZOPEN          110  // -119 Mark this point in input as start of\n                             //  \\z( \u2026 \\) subexpr.\n# define ZCLOSE         120  // -129 Analogous to ZOPEN.\n# define ZREF           130  // -139 node Match external submatch \\z1-\\z9\n\n#define BRACE_COMPLEX   140 /* -149 node Match nodes between m & n times */\n\n#define NOPEN           150     // Mark this point in input as start of\n                                // \\%( subexpr.\n#define NCLOSE          151     // Analogous to NOPEN.\n\n#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */\n#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */\n#define RE_EOF          202     /*\tMatch \"\" at end of file. */\n#define CURSOR          203     /*\tMatch location of cursor. */\n\n#define RE_LNUM         204     /* nr cmp  Match line number */\n#define RE_COL          205     /* nr cmp  Match column number */\n#define RE_VCOL         206     /* nr cmp  Match virtual column number */\n\n#define RE_MARK         207     /* mark cmp  Match mark position */\n#define RE_VISUAL       208     /*\tMatch Visual area */\n#define RE_COMPOSING    209     // any composing characters\n\n/*\n * Magic characters have a special meaning, they don't match literally.\n * Magic characters are negative.  This separates them from literal characters\n * (possibly multi-byte).  Only ASCII characters can be Magic.\n */\n#define Magic(x)        ((int)(x) - 256)\n#define un_Magic(x)     ((x) + 256)\n#define is_Magic(x)     ((x) < 0)\n\n/*\n * We should define ftpr as a pointer to a function returning a pointer to\n * a function returning a pointer to a function ...\n * This is impossible, so we declare a pointer to a function returning a\n * pointer to a function returning void. This should work for all compilers.\n */\ntypedef void (*(*fptr_T)(int *, int))(void);\n\ntypedef struct {\n  char_u     *regparse;\n  int prevchr_len;\n  int curchr;\n  int prevchr;\n  int prevprevchr;\n  int nextchr;\n  int at_start;\n  int prev_at_start;\n  int regnpar;\n} parse_state_T;\n\n/*\n * Structure used to save the current input state, when it needs to be\n * restored after trying a match.  Used by reg_save() and reg_restore().\n * Also stores the length of \"backpos\".\n */\ntypedef struct {\n  union {\n    char_u  *ptr;       ///< rex.input pointer, for single-line regexp\n    lpos_T pos;         ///< rex.input pos, for multi-line regexp\n  } rs_u;\n  int rs_len;\n} regsave_T;\n\n/* struct to save start/end pointer/position in for \\(\\) */\ntypedef struct {\n  union {\n    char_u  *ptr;\n    lpos_T pos;\n  } se_u;\n} save_se_T;\n\n/* used for BEHIND and NOBEHIND matching */\ntypedef struct regbehind_S {\n  regsave_T save_after;\n  regsave_T save_behind;\n  int save_need_clear_subexpr;\n  save_se_T save_start[NSUBEXP];\n  save_se_T save_end[NSUBEXP];\n} regbehind_T;\n\n/* Values for rs_state in regitem_T. */\ntypedef enum regstate_E {\n  RS_NOPEN = 0          /* NOPEN and NCLOSE */\n  , RS_MOPEN            /* MOPEN + [0-9] */\n  , RS_MCLOSE           /* MCLOSE + [0-9] */\n  , RS_ZOPEN            /* ZOPEN + [0-9] */\n  , RS_ZCLOSE           /* ZCLOSE + [0-9] */\n  , RS_BRANCH           /* BRANCH */\n  , RS_BRCPLX_MORE      /* BRACE_COMPLEX and trying one more match */\n  , RS_BRCPLX_LONG      /* BRACE_COMPLEX and trying longest match */\n  , RS_BRCPLX_SHORT     /* BRACE_COMPLEX and trying shortest match */\n  , RS_NOMATCH          /* NOMATCH */\n  , RS_BEHIND1          /* BEHIND / NOBEHIND matching rest */\n  , RS_BEHIND2          /* BEHIND / NOBEHIND matching behind part */\n  , RS_STAR_LONG        /* STAR/PLUS/BRACE_SIMPLE longest match */\n  , RS_STAR_SHORT       /* STAR/PLUS/BRACE_SIMPLE shortest match */\n} regstate_T;\n\n/*\n * When there are alternatives a regstate_T is put on the regstack to remember\n * what we are doing.\n * Before it may be another type of item, depending on rs_state, to remember\n * more things.\n */\ntypedef struct regitem_S {\n  regstate_T rs_state;          // what we are doing, one of RS_ above\n  uint16_t   rs_no;             // submatch nr or BEHIND/NOBEHIND\n  char_u     *rs_scan;          // current node in program\n  union {\n    save_se_T sesave;\n    regsave_T regsave;\n  } rs_un;                      ///< room for saving rex.input\n} regitem_T;\n\n\n/* used for STAR, PLUS and BRACE_SIMPLE matching */\ntypedef struct regstar_S {\n  int nextb;                    /* next byte */\n  int nextb_ic;                 /* next byte reverse case */\n  long count;\n  long minval;\n  long maxval;\n} regstar_T;\n\n/* used to store input position when a BACK was encountered, so that we now if\n * we made any progress since the last time. */\ntypedef struct backpos_S {\n  char_u      *bp_scan;         /* \"scan\" where BACK was encountered */\n  regsave_T bp_pos;             /* last input position */\n} backpos_T;\n\ntypedef struct {\n  int a, b, c;\n} decomp_T;\n\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"regexp.c.generated.h\"\n#endif\nstatic int no_Magic(int x)\n{\n  if (is_Magic(x))\n    return un_Magic(x);\n  return x;\n}\n\nstatic int toggle_Magic(int x)\n{\n  if (is_Magic(x))\n    return un_Magic(x);\n  return Magic(x);\n}\n\n/*\n * The first byte of the regexp internal \"program\" is actually this magic\n * number; the start node begins in the second byte.  It's used to catch the\n * most severe mutilation of the program by the caller.\n */\n\n#define REGMAGIC        0234\n\n/*\n * Opcode notes:\n *\n * BRANCH\tThe set of branches constituting a single choice are hooked\n *\t\ttogether with their \"next\" pointers, since precedence prevents\n *\t\tanything being concatenated to any individual branch.  The\n *\t\t\"next\" pointer of the last BRANCH in a choice points to the\n *\t\tthing following the whole choice.  This is also where the\n *\t\tfinal \"next\" pointer of each individual branch points; each\n *\t\tbranch starts with the operand node of a BRANCH node.\n *\n * BACK\t\tNormal \"next\" pointers all implicitly point forward; BACK\n *\t\texists to make loop structures possible.\n *\n * STAR,PLUS\t'=', and complex '*' and '+', are implemented as circular\n *\t\tBRANCH structures using BACK.  Simple cases (one character\n *\t\tper match) are implemented with STAR and PLUS for speed\n *\t\tand to minimize recursive plunges.\n *\n * BRACE_LIMITS\tThis is always followed by a BRACE_SIMPLE or BRACE_COMPLEX\n *\t\tnode, and defines the min and max limits to be used for that\n *\t\tnode.\n *\n * MOPEN,MCLOSE\t...are numbered at compile time.\n * ZOPEN,ZCLOSE\t...ditto\n */\n\n/*\n * A node is one char of opcode followed by two chars of \"next\" pointer.\n * \"Next\" pointers are stored as two 8-bit bytes, high order first.  The\n * value is a positive offset from the opcode of the node containing it.\n * An operand, if any, simply follows the node.  (Note that much of the\n * code generation knows about this implicit relationship.)\n *\n * Using two bytes for the \"next\" pointer is vast overkill for most things,\n * but allows patterns to get big without disasters.\n */\n#define OP(p)           ((int)*(p))\n#define NEXT(p)         (((*((p) + 1) & 0377) << 8) + (*((p) + 2) & 0377))\n#define OPERAND(p)      ((p) + 3)\n/* Obtain an operand that was stored as four bytes, MSB first. */\n#define OPERAND_MIN(p)  (((long)(p)[3] << 24) + ((long)(p)[4] << 16) \\\n                         + ((long)(p)[5] << 8) + (long)(p)[6])\n/* Obtain a second operand stored as four bytes. */\n#define OPERAND_MAX(p)  OPERAND_MIN((p) + 4)\n/* Obtain a second single-byte operand stored after a four bytes operand. */\n#define OPERAND_CMP(p)  (p)[7]\n\n/*\n * Utility definitions.\n */\n#define UCHARAT(p)      ((int)*(char_u *)(p))\n\n/* Used for an error (down from) vim_regcomp(): give the error message, set\n * rc_did_emsg and return NULL */\n#define EMSG_RET_NULL(m) return (EMSG(m), rc_did_emsg = true, (void *)NULL)\n#define IEMSG_RET_NULL(m) return (IEMSG(m), rc_did_emsg = true, (void *)NULL)\n#define EMSG_RET_FAIL(m) return (EMSG(m), rc_did_emsg = true, FAIL)\n#define EMSG2_RET_NULL(m, c) \\\n    return (EMSG2((m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = true, (void *)NULL)\n#define EMSG2_RET_FAIL(m, c) \\\n    return (EMSG2((m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = true, FAIL)\n#define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_( \\\n    \"E369: invalid item in %s%%[]\"), reg_magic == MAGIC_ALL)\n\n#define MAX_LIMIT       (32767L << 16L)\n\n\n#ifdef BT_REGEXP_DUMP\nstatic void regdump(char_u *, bt_regprog_T *);\n#endif\n#ifdef REGEXP_DEBUG\nstatic char_u   *regprop(char_u *);\n#endif\n\nstatic char_u e_missingbracket[] = N_(\"E769: Missing ] after %s[\");\nstatic char_u e_reverse_range[] = N_(\"E944: Reverse range in character class\");\nstatic char_u e_large_class[] = N_(\"E945: Range too large in character class\");\nstatic char_u e_unmatchedpp[] = N_(\"E53: Unmatched %s%%(\");\nstatic char_u e_unmatchedp[] = N_(\"E54: Unmatched %s(\");\nstatic char_u e_unmatchedpar[] = N_(\"E55: Unmatched %s)\");\nstatic char_u e_z_not_allowed[] = N_(\"E66: \\\\z( not allowed here\");\nstatic char_u e_z1_not_allowed[] = N_(\"E67: \\\\z1 - \\\\z9 not allowed here\");\nstatic char_u e_missing_sb[] = N_(\"E69: Missing ] after %s%%[\");\nstatic char_u e_empty_sb[]  = N_(\"E70: Empty %s%%[]\");\nstatic char_u e_recursive[]  = N_(\"E956: Cannot use pattern recursively\");\n\n#define NOT_MULTI       0\n#define MULTI_ONE       1\n#define MULTI_MULT      2\n/*\n * Return NOT_MULTI if c is not a \"multi\" operator.\n * Return MULTI_ONE if c is a single \"multi\" operator.\n * Return MULTI_MULT if c is a multi \"multi\" operator.\n */\nstatic int re_multi_type(int c)\n{\n  if (c == Magic('@') || c == Magic('=') || c == Magic('?'))\n    return MULTI_ONE;\n  if (c == Magic('*') || c == Magic('+') || c == Magic('{'))\n    return MULTI_MULT;\n  return NOT_MULTI;\n}\n\n/*\n * Flags to be passed up and down.\n */\n#define HASWIDTH        0x1     /* Known never to match null string. */\n#define SIMPLE          0x2     /* Simple enough to be STAR/PLUS operand. */\n#define SPSTART         0x4     /* Starts with * or +. */\n#define HASNL           0x8     /* Contains some \\n. */\n#define HASLOOKBH       0x10    /* Contains \"\\@<=\" or \"\\@<!\". */\n#define WORST           0       /* Worst case. */\n\n/*\n * When regcode is set to this value, code is not emitted and size is computed\n * instead.\n */\n#define JUST_CALC_SIZE  ((char_u *) -1)\n\nstatic char_u           *reg_prev_sub = NULL;\n\n/*\n * REGEXP_INRANGE contains all characters which are always special in a []\n * range after '\\'.\n * REGEXP_ABBR contains all characters which act as abbreviations after '\\'.\n * These are:\n *  \\n\t- New line (NL).\n *  \\r\t- Carriage Return (CR).\n *  \\t\t- Tab (TAB).\n *  \\e\t- Escape (ESC).\n *  \\b\t- Backspace (Ctrl_H).\n *  \\d  - Character code in decimal, eg \\d123\n *  \\o\t- Character code in octal, eg \\o80\n *  \\x\t- Character code in hex, eg \\x4a\n *  \\u\t- Multibyte character code, eg \\u20ac\n *  \\U\t- Long multibyte character code, eg \\U12345678\n */\nstatic char_u REGEXP_INRANGE[] = \"]^-n\\\\\";\nstatic char_u REGEXP_ABBR[] = \"nrtebdoxuU\";\n\n\n/*\n * Translate '\\x' to its control character, except \"\\n\", which is Magic.\n */\nstatic int backslash_trans(int c)\n{\n  switch (c) {\n  case 'r':   return CAR;\n  case 't':   return TAB;\n  case 'e':   return ESC;\n  case 'b':   return BS;\n  }\n  return c;\n}\n\n/*\n * Check for a character class name \"[:name:]\".  \"pp\" points to the '['.\n * Returns one of the CLASS_ items. CLASS_NONE means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\nstatic int get_char_class(char_u **pp)\n{\n  static const char *(class_names[]) =\n  {\n    \"alnum:]\",\n#define CLASS_ALNUM 0\n    \"alpha:]\",\n#define CLASS_ALPHA 1\n    \"blank:]\",\n#define CLASS_BLANK 2\n    \"cntrl:]\",\n#define CLASS_CNTRL 3\n    \"digit:]\",\n#define CLASS_DIGIT 4\n    \"graph:]\",\n#define CLASS_GRAPH 5\n    \"lower:]\",\n#define CLASS_LOWER 6\n    \"print:]\",\n#define CLASS_PRINT 7\n    \"punct:]\",\n#define CLASS_PUNCT 8\n    \"space:]\",\n#define CLASS_SPACE 9\n    \"upper:]\",\n#define CLASS_UPPER 10\n    \"xdigit:]\",\n#define CLASS_XDIGIT 11\n    \"tab:]\",\n#define CLASS_TAB 12\n    \"return:]\",\n#define CLASS_RETURN 13\n    \"backspace:]\",\n#define CLASS_BACKSPACE 14\n    \"escape:]\",\n#define CLASS_ESCAPE 15\n    \"ident:]\",\n#define CLASS_IDENT 16\n    \"keyword:]\",\n#define CLASS_KEYWORD 17\n    \"fname:]\",\n#define CLASS_FNAME 18\n  };\n#define CLASS_NONE 99\n  int i;\n\n  if ((*pp)[1] == ':') {\n    for (i = 0; i < (int)ARRAY_SIZE(class_names); ++i)\n      if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0) {\n        *pp += STRLEN(class_names[i]) + 2;\n        return i;\n      }\n  }\n  return CLASS_NONE;\n}\n\n/*\n * Specific version of character class functions.\n * Using a table to keep this fast.\n */\nstatic short class_tab[256];\n\n#define     RI_DIGIT    0x01\n#define     RI_HEX      0x02\n#define     RI_OCTAL    0x04\n#define     RI_WORD     0x08\n#define     RI_HEAD     0x10\n#define     RI_ALPHA    0x20\n#define     RI_LOWER    0x40\n#define     RI_UPPER    0x80\n#define     RI_WHITE    0x100\n\nstatic void init_class_tab(void)\n{\n  int i;\n  static int done = false;\n\n  if (done)\n    return;\n\n  for (i = 0; i < 256; ++i) {\n    if (i >= '0' && i <= '7')\n      class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;\n    else if (i >= '8' && i <= '9')\n      class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;\n    else if (i >= 'a' && i <= 'f')\n      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n    else if (i >= 'g' && i <= 'z')\n      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n    else if (i >= 'A' && i <= 'F')\n      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n    else if (i >= 'G' && i <= 'Z')\n      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n    else if (i == '_')\n      class_tab[i] = RI_WORD + RI_HEAD;\n    else\n      class_tab[i] = 0;\n  }\n  class_tab[' '] |= RI_WHITE;\n  class_tab['\\t'] |= RI_WHITE;\n  done = true;\n}\n\n# define ri_digit(c)    (c < 0x100 && (class_tab[c] & RI_DIGIT))\n# define ri_hex(c)      (c < 0x100 && (class_tab[c] & RI_HEX))\n# define ri_octal(c)    (c < 0x100 && (class_tab[c] & RI_OCTAL))\n# define ri_word(c)     (c < 0x100 && (class_tab[c] & RI_WORD))\n# define ri_head(c)     (c < 0x100 && (class_tab[c] & RI_HEAD))\n# define ri_alpha(c)    (c < 0x100 && (class_tab[c] & RI_ALPHA))\n# define ri_lower(c)    (c < 0x100 && (class_tab[c] & RI_LOWER))\n# define ri_upper(c)    (c < 0x100 && (class_tab[c] & RI_UPPER))\n# define ri_white(c)    (c < 0x100 && (class_tab[c] & RI_WHITE))\n\n/* flags for regflags */\n#define RF_ICASE    1   /* ignore case */\n#define RF_NOICASE  2   /* don't ignore case */\n#define RF_HASNL    4   /* can match a NL */\n#define RF_ICOMBINE 8   /* ignore combining characters */\n#define RF_LOOKBH   16  /* uses \"\\@<=\" or \"\\@<!\" */\n\n// Global work variables for vim_regcomp().\n\nstatic char_u *regparse;        ///< Input-scan pointer.\nstatic int prevchr_len;         ///< byte length of previous char\nstatic int num_complex_braces;  ///< Complex \\{...} count\nstatic int regnpar;             ///< () count.\nstatic bool wants_nfa;          ///< regex should use NFA engine\nstatic int regnzpar;            ///< \\z() count.\nstatic int re_has_z;            ///< \\z item detected\nstatic char_u *regcode;         ///< Code-emit pointer, or JUST_CALC_SIZE\nstatic long regsize;            ///< Code size.\nstatic int reg_toolong;         ///< true when offset out of range\nstatic char_u had_endbrace[NSUBEXP];  ///< flags, true if end of () found\nstatic unsigned regflags;         ///< RF_ flags for prog\nstatic long brace_min[10];        ///< Minimums for complex brace repeats\nstatic long brace_max[10];        ///< Maximums for complex brace repeats\nstatic int brace_count[10];       ///< Current counts for complex brace repeats\nstatic int had_eol;               ///< true when EOL found by vim_regcomp()\nstatic int one_exactly = false;   ///< only do one char for EXACTLY\n\nstatic int reg_magic;           /* magicness of the pattern: */\n#define MAGIC_NONE      1       /* \"\\V\" very unmagic */\n#define MAGIC_OFF       2       /* \"\\M\" or 'magic' off */\n#define MAGIC_ON        3       /* \"\\m\" or 'magic' */\n#define MAGIC_ALL       4       /* \"\\v\" very magic */\n\nstatic int reg_string;          /* matching with a string instead of a buffer\n                                   line */\nstatic int reg_strict;          /* \"[abc\" is illegal */\n\n/*\n * META contains all characters that may be magic, except '^' and '$'.\n */\n\n/* META[] is used often enough to justify turning it into a table. */\nstatic char_u META_flags[] = {\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  /*\t\t   %  &     (  )  *  +\t      .    */\n  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,\n  /*     1  2  3\t4  5  6  7  8  9\t<  =  >  ? */\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,\n  /*  @  A     C\tD     F     H  I     K\tL  M\t O */\n  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,\n  /*  P\t     S\t   U  V  W  X\t  Z  [\t\t _ */\n  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,\n  /*     a     c\td     f     h  i     k\tl  m  n  o */\n  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,\n  /*  p\t     s\t   u  v  w  x\t  z  {\t|     ~    */\n  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1\n};\n\nstatic int curchr;              /* currently parsed character */\n/* Previous character.  Note: prevchr is sometimes -1 when we are not at the\n * start, eg in /[ ^I]^ the pattern was never found even if it existed,\n * because ^ was taken to be magic -- webb */\nstatic int prevchr;\nstatic int prevprevchr;         /* previous-previous character */\nstatic int nextchr;             /* used for ungetchr() */\n\n/* arguments for reg() */\n#define REG_NOPAREN     0       /* toplevel reg() */\n#define REG_PAREN       1       /* \\(\\) */\n#define REG_ZPAREN      2       /* \\z(\\) */\n#define REG_NPAREN      3       /* \\%(\\) */\n\n/*\n * Forward declarations for vim_regcomp()'s friends.\n */\n# define REGMBC(x) regmbc(x);\n# define CASEMBC(x) case x:\n\nstatic regengine_T bt_regengine;\nstatic regengine_T nfa_regengine;\n\n// Return true if compiled regular expression \"prog\" can match a line break.\nint re_multiline(const regprog_T *prog)\n  FUNC_ATTR_NONNULL_ALL\n{\n  return prog->regflags & RF_HASNL;\n}\n\n/*\n * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['.\n * Returns a character representing the class. Zero means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\nstatic int get_equi_class(char_u **pp)\n{\n  int c;\n  int l = 1;\n  char_u      *p = *pp;\n\n  if (p[1] == '=' && p[2] != NUL) {\n    l = (*mb_ptr2len)(p + 2);\n    if (p[l + 2] == '=' && p[l + 3] == ']') {\n      c = utf_ptr2char(p + 2);\n      *pp += l + 4;\n      return c;\n    }\n  }\n  return 0;\n}\n\n\n/*\n * Produce the bytes for equivalence class \"c\".\n * Currently only handles latin1, latin9 and utf-8.\n * NOTE: When changing this function, also change nfa_emit_equi_class()\n */\nstatic void reg_equi_class(int c)\n{\n  {\n    switch (c) {\n      // Do not use '\\300' style, it results in a negative number.\n    case 'A': case 0xc0: case 0xc1: case 0xc2:\n    case 0xc3: case 0xc4: case 0xc5:\n      CASEMBC(0x100) CASEMBC(0x102) CASEMBC(0x104) CASEMBC(0x1cd)\n      CASEMBC(0x1de) CASEMBC(0x1e0) CASEMBC(0x1ea2)\n      regmbc('A'); regmbc(0xc0); regmbc(0xc1);\n      regmbc(0xc2); regmbc(0xc3); regmbc(0xc4);\n      regmbc(0xc5);\n      REGMBC(0x100) REGMBC(0x102) REGMBC(0x104)\n      REGMBC(0x1cd) REGMBC(0x1de) REGMBC(0x1e0)\n      REGMBC(0x1ea2)\n      return;\n    case 'B': CASEMBC(0x1e02) CASEMBC(0x1e06)\n      regmbc('B'); REGMBC(0x1e02) REGMBC(0x1e06)\n      return;\n    case 'C': case 0xc7:\n      CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a) CASEMBC(0x10c)\n      regmbc('C'); regmbc(0xc7);\n      REGMBC(0x106) REGMBC(0x108) REGMBC(0x10a)\n      REGMBC(0x10c)\n      return;\n    case 'D': CASEMBC(0x10e) CASEMBC(0x110) CASEMBC(0x1e0a)\n      CASEMBC(0x1e0e) CASEMBC(0x1e10)\n      regmbc('D'); REGMBC(0x10e) REGMBC(0x110)\n      REGMBC(0x1e0a) REGMBC(0x1e0e) REGMBC(0x1e10)\n      return;\n    case 'E': case 0xc8: case 0xc9: case 0xca: case 0xcb:\n      CASEMBC(0x112) CASEMBC(0x114) CASEMBC(0x116) CASEMBC(0x118)\n      CASEMBC(0x11a) CASEMBC(0x1eba) CASEMBC(0x1ebc)\n      regmbc('E'); regmbc(0xc8); regmbc(0xc9);\n      regmbc(0xca); regmbc(0xcb);\n      REGMBC(0x112) REGMBC(0x114) REGMBC(0x116)\n      REGMBC(0x118) REGMBC(0x11a) REGMBC(0x1eba)\n      REGMBC(0x1ebc)\n      return;\n    case 'F': CASEMBC(0x1e1e)\n      regmbc('F'); REGMBC(0x1e1e)\n      return;\n    case 'G': CASEMBC(0x11c) CASEMBC(0x11e) CASEMBC(0x120)\n      CASEMBC(0x122) CASEMBC(0x1e4) CASEMBC(0x1e6) CASEMBC(0x1f4)\n      CASEMBC(0x1e20)\n      regmbc('G'); REGMBC(0x11c) REGMBC(0x11e)\n      REGMBC(0x120) REGMBC(0x122) REGMBC(0x1e4)\n      REGMBC(0x1e6) REGMBC(0x1f4) REGMBC(0x1e20)\n      return;\n    case 'H': CASEMBC(0x124) CASEMBC(0x126) CASEMBC(0x1e22)\n      CASEMBC(0x1e26) CASEMBC(0x1e28)\n      regmbc('H'); REGMBC(0x124) REGMBC(0x126)\n      REGMBC(0x1e22) REGMBC(0x1e26) REGMBC(0x1e28)\n      return;\n    case 'I': case 0xcc: case 0xcd: case 0xce: case 0xcf:\n      CASEMBC(0x128) CASEMBC(0x12a) CASEMBC(0x12c) CASEMBC(0x12e)\n      CASEMBC(0x130) CASEMBC(0x1cf) CASEMBC(0x1ec8)\n      regmbc('I'); regmbc(0xcc); regmbc(0xcd);\n      regmbc(0xce); regmbc(0xcf);\n      REGMBC(0x128) REGMBC(0x12a) REGMBC(0x12c)\n      REGMBC(0x12e) REGMBC(0x130) REGMBC(0x1cf)\n      REGMBC(0x1ec8)\n      return;\n    case 'J': CASEMBC(0x134)\n      regmbc('J'); REGMBC(0x134)\n      return;\n    case 'K': CASEMBC(0x136) CASEMBC(0x1e8) CASEMBC(0x1e30)\n      CASEMBC(0x1e34)\n      regmbc('K'); REGMBC(0x136) REGMBC(0x1e8)\n      REGMBC(0x1e30) REGMBC(0x1e34)\n      return;\n    case 'L': CASEMBC(0x139) CASEMBC(0x13b) CASEMBC(0x13d)\n      CASEMBC(0x13f) CASEMBC(0x141) CASEMBC(0x1e3a)\n      regmbc('L'); REGMBC(0x139) REGMBC(0x13b)\n      REGMBC(0x13d) REGMBC(0x13f) REGMBC(0x141)\n      REGMBC(0x1e3a)\n      return;\n    case 'M': CASEMBC(0x1e3e) CASEMBC(0x1e40)\n      regmbc('M'); REGMBC(0x1e3e) REGMBC(0x1e40)\n      return;\n    case 'N': case 0xd1:\n      CASEMBC(0x143) CASEMBC(0x145) CASEMBC(0x147) CASEMBC(0x1e44)\n      CASEMBC(0x1e48)\n      regmbc('N'); regmbc(0xd1);\n      REGMBC(0x143) REGMBC(0x145) REGMBC(0x147)\n      REGMBC(0x1e44) REGMBC(0x1e48)\n      return;\n    case 'O': case 0xd2: case 0xd3: case 0xd4: case 0xd5:\n    case 0xd6: case 0xd8:\n      CASEMBC(0x14c) CASEMBC(0x14e) CASEMBC(0x150) CASEMBC(0x1a0)\n      CASEMBC(0x1d1) CASEMBC(0x1ea) CASEMBC(0x1ec) CASEMBC(0x1ece)\n      regmbc('O'); regmbc(0xd2); regmbc(0xd3);\n      regmbc(0xd4); regmbc(0xd5); regmbc(0xd6);\n      regmbc(0xd8);\n      REGMBC(0x14c) REGMBC(0x14e) REGMBC(0x150)\n      REGMBC(0x1a0) REGMBC(0x1d1) REGMBC(0x1ea)\n      REGMBC(0x1ec) REGMBC(0x1ece)\n      return;\n    case 'P': case 0x1e54: case 0x1e56:\n      regmbc('P'); REGMBC(0x1e54) REGMBC(0x1e56)\n      return;\n    case 'R': CASEMBC(0x154) CASEMBC(0x156) CASEMBC(0x158)\n      CASEMBC(0x1e58) CASEMBC(0x1e5e)\n      regmbc('R'); REGMBC(0x154) REGMBC(0x156) REGMBC(0x158)\n      REGMBC(0x1e58) REGMBC(0x1e5e)\n      return;\n    case 'S': CASEMBC(0x15a) CASEMBC(0x15c) CASEMBC(0x15e)\n      CASEMBC(0x160) CASEMBC(0x1e60)\n      regmbc('S'); REGMBC(0x15a) REGMBC(0x15c)\n      REGMBC(0x15e) REGMBC(0x160) REGMBC(0x1e60)\n      return;\n    case 'T': CASEMBC(0x162) CASEMBC(0x164) CASEMBC(0x166)\n      CASEMBC(0x1e6a) CASEMBC(0x1e6e)\n      regmbc('T'); REGMBC(0x162) REGMBC(0x164)\n      REGMBC(0x166) REGMBC(0x1e6a) REGMBC(0x1e6e)\n      return;\n    case 'U': case 0xd9: case 0xda: case 0xdb: case 0xdc:\n      CASEMBC(0x168) CASEMBC(0x16a) CASEMBC(0x16c) CASEMBC(0x16e)\n      CASEMBC(0x170) CASEMBC(0x172) CASEMBC(0x1af) CASEMBC(0x1d3)\n      CASEMBC(0x1ee6)\n      regmbc('U'); regmbc(0xd9); regmbc(0xda);\n      regmbc(0xdb); regmbc(0xdc);\n      REGMBC(0x168) REGMBC(0x16a) REGMBC(0x16c)\n      REGMBC(0x16e) REGMBC(0x170) REGMBC(0x172)\n      REGMBC(0x1af) REGMBC(0x1d3) REGMBC(0x1ee6)\n      return;\n    case 'V': CASEMBC(0x1e7c)\n      regmbc('V'); REGMBC(0x1e7c)\n      return;\n    case 'W': CASEMBC(0x174) CASEMBC(0x1e80) CASEMBC(0x1e82)\n      CASEMBC(0x1e84) CASEMBC(0x1e86)\n      regmbc('W'); REGMBC(0x174) REGMBC(0x1e80)\n      REGMBC(0x1e82) REGMBC(0x1e84) REGMBC(0x1e86)\n      return;\n    case 'X': CASEMBC(0x1e8a) CASEMBC(0x1e8c)\n      regmbc('X'); REGMBC(0x1e8a) REGMBC(0x1e8c)\n      return;\n    case 'Y': case 0xdd:\n      CASEMBC(0x176) CASEMBC(0x178) CASEMBC(0x1e8e) CASEMBC(0x1ef2)\n      CASEMBC(0x1ef6) CASEMBC(0x1ef8)\n      regmbc('Y'); regmbc(0xdd);\n      REGMBC(0x176) REGMBC(0x178) REGMBC(0x1e8e)\n      REGMBC(0x1ef2) REGMBC(0x1ef6) REGMBC(0x1ef8)\n      return;\n    case 'Z': CASEMBC(0x179) CASEMBC(0x17b) CASEMBC(0x17d)\n      CASEMBC(0x1b5) CASEMBC(0x1e90) CASEMBC(0x1e94)\n      regmbc('Z'); REGMBC(0x179) REGMBC(0x17b)\n      REGMBC(0x17d) REGMBC(0x1b5) REGMBC(0x1e90)\n      REGMBC(0x1e94)\n      return;\n    case 'a': case 0xe0: case 0xe1: case 0xe2:\n    case 0xe3: case 0xe4: case 0xe5:\n      CASEMBC(0x101) CASEMBC(0x103) CASEMBC(0x105) CASEMBC(0x1ce)\n      CASEMBC(0x1df) CASEMBC(0x1e1) CASEMBC(0x1ea3)\n      regmbc('a'); regmbc(0xe0); regmbc(0xe1);\n      regmbc(0xe2); regmbc(0xe3); regmbc(0xe4);\n      regmbc(0xe5);\n      REGMBC(0x101) REGMBC(0x103) REGMBC(0x105)\n      REGMBC(0x1ce) REGMBC(0x1df) REGMBC(0x1e1)\n      REGMBC(0x1ea3)\n      return;\n    case 'b': CASEMBC(0x1e03) CASEMBC(0x1e07)\n      regmbc('b'); REGMBC(0x1e03) REGMBC(0x1e07)\n      return;\n    case 'c': case 0xe7:\n      CASEMBC(0x107) CASEMBC(0x109) CASEMBC(0x10b) CASEMBC(0x10d)\n      regmbc('c'); regmbc(0xe7);\n      REGMBC(0x107) REGMBC(0x109) REGMBC(0x10b)\n      REGMBC(0x10d)\n      return;\n    case 'd': CASEMBC(0x10f) CASEMBC(0x111) CASEMBC(0x1e0b)\n      CASEMBC(0x1e0f) CASEMBC(0x1e11)\n      regmbc('d'); REGMBC(0x10f) REGMBC(0x111)\n      REGMBC(0x1e0b) REGMBC(0x1e0f) REGMBC(0x1e11)\n      return;\n    case 'e': case 0xe8: case 0xe9: case 0xea: case 0xeb:\n      CASEMBC(0x113) CASEMBC(0x115) CASEMBC(0x117) CASEMBC(0x119)\n      CASEMBC(0x11b) CASEMBC(0x1ebb) CASEMBC(0x1ebd)\n      regmbc('e'); regmbc(0xe8); regmbc(0xe9);\n      regmbc(0xea); regmbc(0xeb);\n      REGMBC(0x113) REGMBC(0x115) REGMBC(0x117)\n      REGMBC(0x119) REGMBC(0x11b) REGMBC(0x1ebb)\n      REGMBC(0x1ebd)\n      return;\n    case 'f': CASEMBC(0x1e1f)\n      regmbc('f'); REGMBC(0x1e1f)\n      return;\n    case 'g': CASEMBC(0x11d) CASEMBC(0x11f) CASEMBC(0x121)\n      CASEMBC(0x123) CASEMBC(0x1e5) CASEMBC(0x1e7) CASEMBC(0x1f5)\n      CASEMBC(0x1e21)\n      regmbc('g'); REGMBC(0x11d) REGMBC(0x11f)\n      REGMBC(0x121) REGMBC(0x123) REGMBC(0x1e5)\n      REGMBC(0x1e7) REGMBC(0x1f5) REGMBC(0x1e21)\n      return;\n    case 'h': CASEMBC(0x125) CASEMBC(0x127) CASEMBC(0x1e23)\n      CASEMBC(0x1e27) CASEMBC(0x1e29) CASEMBC(0x1e96)\n      regmbc('h'); REGMBC(0x125) REGMBC(0x127)\n      REGMBC(0x1e23) REGMBC(0x1e27) REGMBC(0x1e29)\n      REGMBC(0x1e96)\n      return;\n    case 'i': case 0xec: case 0xed: case 0xee: case 0xef:\n      CASEMBC(0x129) CASEMBC(0x12b) CASEMBC(0x12d) CASEMBC(0x12f)\n      CASEMBC(0x1d0) CASEMBC(0x1ec9)\n      regmbc('i'); regmbc(0xec); regmbc(0xed);\n      regmbc(0xee); regmbc(0xef);\n      REGMBC(0x129) REGMBC(0x12b) REGMBC(0x12d)\n      REGMBC(0x12f) REGMBC(0x1d0) REGMBC(0x1ec9)\n      return;\n    case 'j': CASEMBC(0x135) CASEMBC(0x1f0)\n      regmbc('j'); REGMBC(0x135) REGMBC(0x1f0)\n      return;\n    case 'k': CASEMBC(0x137) CASEMBC(0x1e9) CASEMBC(0x1e31)\n      CASEMBC(0x1e35)\n      regmbc('k'); REGMBC(0x137) REGMBC(0x1e9)\n      REGMBC(0x1e31) REGMBC(0x1e35)\n      return;\n    case 'l': CASEMBC(0x13a) CASEMBC(0x13c) CASEMBC(0x13e)\n      CASEMBC(0x140) CASEMBC(0x142) CASEMBC(0x1e3b)\n      regmbc('l'); REGMBC(0x13a) REGMBC(0x13c)\n      REGMBC(0x13e) REGMBC(0x140) REGMBC(0x142)\n      REGMBC(0x1e3b)\n      return;\n    case 'm': CASEMBC(0x1e3f) CASEMBC(0x1e41)\n      regmbc('m'); REGMBC(0x1e3f) REGMBC(0x1e41)\n      return;\n    case 'n': case 0xf1:\n      CASEMBC(0x144) CASEMBC(0x146) CASEMBC(0x148) CASEMBC(0x149)\n      CASEMBC(0x1e45) CASEMBC(0x1e49)\n      regmbc('n'); regmbc(0xf1);\n      REGMBC(0x144) REGMBC(0x146) REGMBC(0x148)\n      REGMBC(0x149) REGMBC(0x1e45) REGMBC(0x1e49)\n      return;\n    case 'o': case 0xf2: case 0xf3: case 0xf4: case 0xf5:\n    case 0xf6: case 0xf8:\n      CASEMBC(0x14d) CASEMBC(0x14f) CASEMBC(0x151) CASEMBC(0x1a1)\n      CASEMBC(0x1d2) CASEMBC(0x1eb) CASEMBC(0x1ed) CASEMBC(0x1ecf)\n      regmbc('o'); regmbc(0xf2); regmbc(0xf3);\n      regmbc(0xf4); regmbc(0xf5); regmbc(0xf6);\n      regmbc(0xf8);\n      REGMBC(0x14d) REGMBC(0x14f) REGMBC(0x151)\n      REGMBC(0x1a1) REGMBC(0x1d2) REGMBC(0x1eb)\n      REGMBC(0x1ed) REGMBC(0x1ecf)\n      return;\n    case 'p': CASEMBC(0x1e55) CASEMBC(0x1e57)\n      regmbc('p'); REGMBC(0x1e55) REGMBC(0x1e57)\n      return;\n    case 'r': CASEMBC(0x155) CASEMBC(0x157) CASEMBC(0x159)\n      CASEMBC(0x1e59) CASEMBC(0x1e5f)\n      regmbc('r'); REGMBC(0x155) REGMBC(0x157) REGMBC(0x159)\n      REGMBC(0x1e59) REGMBC(0x1e5f)\n      return;\n    case 's': CASEMBC(0x15b) CASEMBC(0x15d) CASEMBC(0x15f)\n      CASEMBC(0x161) CASEMBC(0x1e61)\n      regmbc('s'); REGMBC(0x15b) REGMBC(0x15d)\n      REGMBC(0x15f) REGMBC(0x161) REGMBC(0x1e61)\n      return;\n    case 't': CASEMBC(0x163) CASEMBC(0x165) CASEMBC(0x167)\n      CASEMBC(0x1e6b) CASEMBC(0x1e6f) CASEMBC(0x1e97)\n      regmbc('t'); REGMBC(0x163) REGMBC(0x165) REGMBC(0x167)\n      REGMBC(0x1e6b) REGMBC(0x1e6f) REGMBC(0x1e97)\n      return;\n    case 'u': case 0xf9: case 0xfa: case 0xfb: case 0xfc:\n      CASEMBC(0x169) CASEMBC(0x16b) CASEMBC(0x16d) CASEMBC(0x16f)\n      CASEMBC(0x171) CASEMBC(0x173) CASEMBC(0x1b0) CASEMBC(0x1d4)\n      CASEMBC(0x1ee7)\n      regmbc('u'); regmbc(0xf9); regmbc(0xfa);\n      regmbc(0xfb); regmbc(0xfc);\n      REGMBC(0x169) REGMBC(0x16b) REGMBC(0x16d)\n      REGMBC(0x16f) REGMBC(0x171) REGMBC(0x173)\n      REGMBC(0x1b0) REGMBC(0x1d4) REGMBC(0x1ee7)\n      return;\n    case 'v': CASEMBC(0x1e7d)\n      regmbc('v'); REGMBC(0x1e7d)\n      return;\n    case 'w': CASEMBC(0x175) CASEMBC(0x1e81) CASEMBC(0x1e83)\n      CASEMBC(0x1e85) CASEMBC(0x1e87) CASEMBC(0x1e98)\n      regmbc('w'); REGMBC(0x175) REGMBC(0x1e81)\n      REGMBC(0x1e83) REGMBC(0x1e85) REGMBC(0x1e87)\n      REGMBC(0x1e98)\n      return;\n    case 'x': CASEMBC(0x1e8b) CASEMBC(0x1e8d)\n      regmbc('x'); REGMBC(0x1e8b) REGMBC(0x1e8d)\n      return;\n    case 'y': case 0xfd: case 0xff:\n      CASEMBC(0x177) CASEMBC(0x1e8f) CASEMBC(0x1e99)\n      CASEMBC(0x1ef3) CASEMBC(0x1ef7) CASEMBC(0x1ef9)\n      regmbc('y'); regmbc(0xfd); regmbc(0xff);\n      REGMBC(0x177) REGMBC(0x1e8f) REGMBC(0x1e99)\n      REGMBC(0x1ef3) REGMBC(0x1ef7) REGMBC(0x1ef9)\n      return;\n    case 'z': CASEMBC(0x17a) CASEMBC(0x17c) CASEMBC(0x17e)\n      CASEMBC(0x1b6) CASEMBC(0x1e91) CASEMBC(0x1e95)\n      regmbc('z'); REGMBC(0x17a) REGMBC(0x17c)\n      REGMBC(0x17e) REGMBC(0x1b6) REGMBC(0x1e91)\n      REGMBC(0x1e95)\n      return;\n    }\n  }\n  regmbc(c);\n}\n\n/*\n * Check for a collating element \"[.a.]\".  \"pp\" points to the '['.\n * Returns a character. Zero means that no item was recognized.  Otherwise\n * \"pp\" is advanced to after the item.\n * Currently only single characters are recognized!\n */\nstatic int get_coll_element(char_u **pp)\n{\n  int c;\n  int l = 1;\n  char_u      *p = *pp;\n\n  if (p[0] != NUL && p[1] == '.' && p[2] != NUL) {\n    l = utfc_ptr2len(p + 2);\n    if (p[l + 2] == '.' && p[l + 3] == ']') {\n      c = utf_ptr2char(p + 2);\n      *pp += l + 4;\n      return c;\n    }\n  }\n  return 0;\n}\n\nstatic int reg_cpo_lit; /* 'cpoptions' contains 'l' flag */\n\nstatic void get_cpo_flags(void)\n{\n  reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;\n}\n\n/*\n * Skip over a \"[]\" range.\n * \"p\" must point to the character after the '['.\n * The returned pointer is on the matching ']', or the terminating NUL.\n */\nstatic char_u *skip_anyof(char_u *p)\n{\n  int l;\n\n  if (*p == '^')        /* Complement of range. */\n    ++p;\n  if (*p == ']' || *p == '-')\n    ++p;\n  while (*p != NUL && *p != ']') {\n    if ((l = (*mb_ptr2len)(p)) > 1) {\n      p += l;\n    } else if (*p == '-')  {\n      p++;\n      if (*p != ']' && *p != NUL) {\n        MB_PTR_ADV(p);\n      }\n    } else if (*p == '\\\\'\n               && (vim_strchr(REGEXP_INRANGE, p[1]) != NULL\n                   || (!reg_cpo_lit\n                       && vim_strchr(REGEXP_ABBR, p[1]) != NULL))) {\n      p += 2;\n    } else if (*p == '[') {\n      if (get_char_class(&p) == CLASS_NONE\n          && get_equi_class(&p) == 0\n          && get_coll_element(&p) == 0\n          && *p != NUL) {\n        p++;          // It is not a class name and not NUL\n      }\n    } else {\n      p++;\n    }\n  }\n\n  return p;\n}\n\n/*\n * Skip past regular expression.\n * Stop at end of \"startp\" or where \"dirc\" is found ('/', '?', etc).\n * Take care of characters with a backslash in front of it.\n * Skip strings inside [ and ].\n * When \"newp\" is not NULL and \"dirc\" is '?', make an allocated copy of the\n * expression and change \"\\?\" to \"?\".  If \"*newp\" is not NULL the expression\n * is changed in-place.\n */\nchar_u *skip_regexp(char_u *startp, int dirc, int magic, char_u **newp)\n{\n  int mymagic;\n  char_u      *p = startp;\n\n  if (magic)\n    mymagic = MAGIC_ON;\n  else\n    mymagic = MAGIC_OFF;\n  get_cpo_flags();\n\n  for (; p[0] != NUL; MB_PTR_ADV(p)) {\n    if (p[0] == dirc) {         // found end of regexp\n      break;\n    }\n    if ((p[0] == '[' && mymagic >= MAGIC_ON)\n        || (p[0] == '\\\\' && p[1] == '[' && mymagic <= MAGIC_OFF)) {\n      p = skip_anyof(p + 1);\n      if (p[0] == NUL)\n        break;\n    } else if (p[0] == '\\\\' && p[1] != NUL)   {\n      if (dirc == '?' && newp != NULL && p[1] == '?') {\n        /* change \"\\?\" to \"?\", make a copy first. */\n        if (*newp == NULL) {\n          *newp = vim_strsave(startp);\n          p = *newp + (p - startp);\n        }\n        STRMOVE(p, p + 1);\n      } else\n        ++p;            /* skip next character */\n      if (*p == 'v')\n        mymagic = MAGIC_ALL;\n      else if (*p == 'V')\n        mymagic = MAGIC_NONE;\n    }\n  }\n  return p;\n}\n\n/// Return true if the back reference is legal. We must have seen the close\n/// brace.\n/// TODO(vim): Should also check that we don't refer to something repeated\n/// (+*=): what instance of the repetition should we match?\nstatic int seen_endbrace(int refnum)\n{\n  if (!had_endbrace[refnum]) {\n      char_u *p;\n\n      // Trick: check if \"@<=\" or \"@<!\" follows, in which case\n      // the \\1 can appear before the referenced match.\n      for (p = regparse; *p != NUL; p++) {\n        if (p[0] == '@' && p[1] == '<' && (p[2] == '!' || p[2] == '=')) {\n          break;\n        }\n      }\n\n    if (*p == NUL) {\n      EMSG(_(\"E65: Illegal back reference\"));\n      rc_did_emsg = true;\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n * bt_regcomp() - compile a regular expression into internal code for the\n * traditional back track matcher.\n * Returns the program in allocated space.  Returns NULL for an error.\n *\n * We can't allocate space until we know how big the compiled form will be,\n * but we can't compile it (and thus know how big it is) until we've got a\n * place to put the code.  So we cheat:  we compile it twice, once with code\n * generation turned off and size counting turned on, and once \"for real\".\n * This also means that we don't allocate space until we are sure that the\n * thing really will compile successfully, and we never have to move the\n * code and thus invalidate pointers into it.  (Note that it has to be in\n * one piece because free() must be able to free it all.)\n *\n * Whether upper/lower case is to be ignored is decided when executing the\n * program, it does not matter here.\n *\n * Beware that the optimization-preparation code in here knows about some\n * of the structure of the compiled regexp.\n * \"re_flags\": RE_MAGIC and/or RE_STRING.\n */\nstatic regprog_T *bt_regcomp(char_u *expr, int re_flags)\n{\n  char_u      *scan;\n  char_u      *longest;\n  int len;\n  int flags;\n\n  if (expr == NULL) {\n    IEMSG_RET_NULL(_(e_null));\n  }\n\n  init_class_tab();\n\n  /*\n   * First pass: determine size, legality.\n   */\n  regcomp_start(expr, re_flags);\n  regcode = JUST_CALC_SIZE;\n  regc(REGMAGIC);\n  if (reg(REG_NOPAREN, &flags) == NULL)\n    return NULL;\n\n  /* Allocate space. */\n  bt_regprog_T *r = xmalloc(sizeof(bt_regprog_T) + regsize);\n  r->re_in_use = false;\n\n  /*\n   * Second pass: emit code.\n   */\n  regcomp_start(expr, re_flags);\n  regcode = r->program;\n  regc(REGMAGIC);\n  if (reg(REG_NOPAREN, &flags) == NULL || reg_toolong) {\n    xfree(r);\n    if (reg_toolong)\n      EMSG_RET_NULL(_(\"E339: Pattern too long\"));\n    return NULL;\n  }\n\n  /* Dig out information for optimizations. */\n  r->regstart = NUL;            /* Worst-case defaults. */\n  r->reganch = 0;\n  r->regmust = NULL;\n  r->regmlen = 0;\n  r->regflags = regflags;\n  if (flags & HASNL)\n    r->regflags |= RF_HASNL;\n  if (flags & HASLOOKBH)\n    r->regflags |= RF_LOOKBH;\n  /* Remember whether this pattern has any \\z specials in it. */\n  r->reghasz = re_has_z;\n  scan = r->program + 1;        /* First BRANCH. */\n  if (OP(regnext(scan)) == END) {   /* Only one top-level choice. */\n    scan = OPERAND(scan);\n\n    /* Starting-point info. */\n    if (OP(scan) == BOL || OP(scan) == RE_BOF) {\n      r->reganch++;\n      scan = regnext(scan);\n    }\n\n    if (OP(scan) == EXACTLY) {\n      r->regstart = utf_ptr2char(OPERAND(scan));\n    } else if (OP(scan) == BOW\n               || OP(scan) == EOW\n               || OP(scan) == NOTHING\n               || OP(scan) == MOPEN  + 0 || OP(scan) == NOPEN\n               || OP(scan) == MCLOSE + 0 || OP(scan) == NCLOSE) {\n      char_u *regnext_scan = regnext(scan);\n      if (OP(regnext_scan) == EXACTLY) {\n        r->regstart = utf_ptr2char(OPERAND(regnext_scan));\n      }\n    }\n\n    /*\n     * If there's something expensive in the r.e., find the longest\n     * literal string that must appear and make it the regmust.  Resolve\n     * ties in favor of later strings, since the regstart check works\n     * with the beginning of the r.e. and avoiding duplication\n     * strengthens checking.  Not a strong reason, but sufficient in the\n     * absence of others.\n     */\n    /*\n     * When the r.e. starts with BOW, it is faster to look for a regmust\n     * first. Used a lot for \"#\" and \"*\" commands. (Added by mool).\n     */\n    if ((flags & SPSTART || OP(scan) == BOW || OP(scan) == EOW)\n        && !(flags & HASNL)) {\n      longest = NULL;\n      len = 0;\n      for (; scan != NULL; scan = regnext(scan))\n        if (OP(scan) == EXACTLY && STRLEN(OPERAND(scan)) >= (size_t)len) {\n          longest = OPERAND(scan);\n          len = (int)STRLEN(OPERAND(scan));\n        }\n      r->regmust = longest;\n      r->regmlen = len;\n    }\n  }\n#ifdef BT_REGEXP_DUMP\n  regdump(expr, r);\n#endif\n  r->engine = &bt_regengine;\n  return (regprog_T *)r;\n}\n\n/*\n * Free a compiled regexp program, returned by bt_regcomp().\n */\nstatic void bt_regfree(regprog_T *prog)\n{\n  xfree(prog);\n}\n\n/*\n * Setup to parse the regexp.  Used once to get the length and once to do it.\n */\nstatic void \nregcomp_start (\n    char_u *expr,\n    int re_flags                       /* see vim_regcomp() */\n)\n{\n  initchr(expr);\n  if (re_flags & RE_MAGIC)\n    reg_magic = MAGIC_ON;\n  else\n    reg_magic = MAGIC_OFF;\n  reg_string = (re_flags & RE_STRING);\n  reg_strict = (re_flags & RE_STRICT);\n  get_cpo_flags();\n\n  num_complex_braces = 0;\n  regnpar = 1;\n  memset(had_endbrace, 0, sizeof(had_endbrace));\n  regnzpar = 1;\n  re_has_z = 0;\n  regsize = 0L;\n  reg_toolong = false;\n  regflags = 0;\n  had_eol = false;\n}\n\n/*\n * Check if during the previous call to vim_regcomp the EOL item \"$\" has been\n * found.  This is messy, but it works fine.\n */\nint vim_regcomp_had_eol(void)\n{\n  return had_eol;\n}\n\n// variables used for parsing\nstatic int at_start;       // True when on the first character\nstatic int prev_at_start;  // True when on the second character\n\n/*\n * Parse regular expression, i.e. main body or parenthesized thing.\n *\n * Caller must absorb opening parenthesis.\n *\n * Combining parenthesis handling with the base level of regular expression\n * is a trifle forced, but the need to tie the tails of the branches to what\n * follows makes it hard to avoid.\n */\nstatic char_u *\nreg (\n    int paren,              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */\n    int *flagp\n)\n{\n  char_u      *ret;\n  char_u      *br;\n  char_u      *ender;\n  int parno = 0;\n  int flags;\n\n  *flagp = HASWIDTH;            /* Tentatively. */\n\n  if (paren == REG_ZPAREN) {\n    /* Make a ZOPEN node. */\n    if (regnzpar >= NSUBEXP)\n      EMSG_RET_NULL(_(\"E50: Too many \\\\z(\"));\n    parno = regnzpar;\n    regnzpar++;\n    ret = regnode(ZOPEN + parno);\n  } else if (paren == REG_PAREN)    {\n    /* Make a MOPEN node. */\n    if (regnpar >= NSUBEXP)\n      EMSG2_RET_NULL(_(\"E51: Too many %s(\"), reg_magic == MAGIC_ALL);\n    parno = regnpar;\n    ++regnpar;\n    ret = regnode(MOPEN + parno);\n  } else if (paren == REG_NPAREN)   {\n    /* Make a NOPEN node. */\n    ret = regnode(NOPEN);\n  } else\n    ret = NULL;\n\n  /* Pick up the branches, linking them together. */\n  br = regbranch(&flags);\n  if (br == NULL)\n    return NULL;\n  if (ret != NULL)\n    regtail(ret, br);           /* [MZ]OPEN -> first. */\n  else\n    ret = br;\n  /* If one of the branches can be zero-width, the whole thing can.\n   * If one of the branches has * at start or matches a line-break, the\n   * whole thing can. */\n  if (!(flags & HASWIDTH))\n    *flagp &= ~HASWIDTH;\n  *flagp |= flags & (SPSTART | HASNL | HASLOOKBH);\n  while (peekchr() == Magic('|')) {\n    skipchr();\n    br = regbranch(&flags);\n    if (br == NULL || reg_toolong)\n      return NULL;\n    regtail(ret, br);           /* BRANCH -> BRANCH. */\n    if (!(flags & HASWIDTH))\n      *flagp &= ~HASWIDTH;\n    *flagp |= flags & (SPSTART | HASNL | HASLOOKBH);\n  }\n\n  /* Make a closing node, and hook it on the end. */\n  ender = regnode(\n      paren == REG_ZPAREN ? ZCLOSE + parno :\n      paren == REG_PAREN ? MCLOSE + parno :\n      paren == REG_NPAREN ? NCLOSE : END);\n  regtail(ret, ender);\n\n  /* Hook the tails of the branches to the closing node. */\n  for (br = ret; br != NULL; br = regnext(br))\n    regoptail(br, ender);\n\n  /* Check for proper termination. */\n  if (paren != REG_NOPAREN && getchr() != Magic(')')) {\n    if (paren == REG_ZPAREN)\n      EMSG_RET_NULL(_(\"E52: Unmatched \\\\z(\"));\n    else if (paren == REG_NPAREN)\n      EMSG2_RET_NULL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);\n    else\n      EMSG2_RET_NULL(_(e_unmatchedp), reg_magic == MAGIC_ALL);\n  } else if (paren == REG_NOPAREN && peekchr() != NUL) {\n    if (curchr == Magic(')'))\n      EMSG2_RET_NULL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);\n    else\n      EMSG_RET_NULL(_(e_trailing));             /* \"Can't happen\". */\n    /* NOTREACHED */\n  }\n  // Here we set the flag allowing back references to this set of\n  // parentheses.\n  if (paren == REG_PAREN) {\n    had_endbrace[parno] = true;  // have seen the close paren\n  }\n  return ret;\n}\n\n/*\n * Parse one alternative of an | operator.\n * Implements the & operator.\n */\nstatic char_u *regbranch(int *flagp)\n{\n  char_u      *ret;\n  char_u      *chain = NULL;\n  char_u      *latest;\n  int flags;\n\n  *flagp = WORST | HASNL;               /* Tentatively. */\n\n  ret = regnode(BRANCH);\n  for (;; ) {\n    latest = regconcat(&flags);\n    if (latest == NULL)\n      return NULL;\n    /* If one of the branches has width, the whole thing has.  If one of\n     * the branches anchors at start-of-line, the whole thing does.\n     * If one of the branches uses look-behind, the whole thing does. */\n    *flagp |= flags & (HASWIDTH | SPSTART | HASLOOKBH);\n    /* If one of the branches doesn't match a line-break, the whole thing\n     * doesn't. */\n    *flagp &= ~HASNL | (flags & HASNL);\n    if (chain != NULL)\n      regtail(chain, latest);\n    if (peekchr() != Magic('&'))\n      break;\n    skipchr();\n    regtail(latest, regnode(END));     /* operand ends */\n    if (reg_toolong)\n      break;\n    reginsert(MATCH, latest);\n    chain = latest;\n  }\n\n  return ret;\n}\n\n/*\n * Parse one alternative of an | or & operator.\n * Implements the concatenation operator.\n */\nstatic char_u *regconcat(int *flagp)\n{\n  char_u      *first = NULL;\n  char_u      *chain = NULL;\n  char_u      *latest;\n  int flags;\n  int cont = true;\n\n  *flagp = WORST;               /* Tentatively. */\n\n  while (cont) {\n    switch (peekchr()) {\n    case NUL:\n    case Magic('|'):\n    case Magic('&'):\n    case Magic(')'):\n      cont = false;\n      break;\n    case Magic('Z'):\n      regflags |= RF_ICOMBINE;\n      skipchr_keepstart();\n      break;\n    case Magic('c'):\n      regflags |= RF_ICASE;\n      skipchr_keepstart();\n      break;\n    case Magic('C'):\n      regflags |= RF_NOICASE;\n      skipchr_keepstart();\n      break;\n    case Magic('v'):\n      reg_magic = MAGIC_ALL;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n    case Magic('m'):\n      reg_magic = MAGIC_ON;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n    case Magic('M'):\n      reg_magic = MAGIC_OFF;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n    case Magic('V'):\n      reg_magic = MAGIC_NONE;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n    default:\n      latest = regpiece(&flags);\n      if (latest == NULL || reg_toolong)\n        return NULL;\n      *flagp |= flags & (HASWIDTH | HASNL | HASLOOKBH);\n      if (chain == NULL)                        /* First piece. */\n        *flagp |= flags & SPSTART;\n      else\n        regtail(chain, latest);\n      chain = latest;\n      if (first == NULL)\n        first = latest;\n      break;\n    }\n  }\n  if (first == NULL)            /* Loop ran zero times. */\n    first = regnode(NOTHING);\n  return first;\n}\n\n/*\n * Parse something followed by possible [*+=].\n *\n * Note that the branching code sequences used for = and the general cases\n * of * and + are somewhat optimized:  they use the same NOTHING node as\n * both the endmarker for their branch list and the body of the last branch.\n * It might seem that this node could be dispensed with entirely, but the\n * endmarker role is not redundant.\n */\nstatic char_u *regpiece(int *flagp)\n{\n  char_u          *ret;\n  int op;\n  char_u          *next;\n  int flags;\n  long minval;\n  long maxval;\n\n  ret = regatom(&flags);\n  if (ret == NULL)\n    return NULL;\n\n  op = peekchr();\n  if (re_multi_type(op) == NOT_MULTI) {\n    *flagp = flags;\n    return ret;\n  }\n  /* default flags */\n  *flagp = (WORST | SPSTART | (flags & (HASNL | HASLOOKBH)));\n\n  skipchr();\n  switch (op) {\n  case Magic('*'):\n    if (flags & SIMPLE)\n      reginsert(STAR, ret);\n    else {\n      /* Emit x* as (x&|), where & means \"self\". */\n      reginsert(BRANCH, ret);           /* Either x */\n      regoptail(ret, regnode(BACK));            /* and loop */\n      regoptail(ret, ret);              /* back */\n      regtail(ret, regnode(BRANCH));            /* or */\n      regtail(ret, regnode(NOTHING));           /* null. */\n    }\n    break;\n\n  case Magic('+'):\n    if (flags & SIMPLE)\n      reginsert(PLUS, ret);\n    else {\n      /* Emit x+ as x(&|), where & means \"self\". */\n      next = regnode(BRANCH);           /* Either */\n      regtail(ret, next);\n      regtail(regnode(BACK), ret);              /* loop back */\n      regtail(next, regnode(BRANCH));           /* or */\n      regtail(ret, regnode(NOTHING));           /* null. */\n    }\n    *flagp = (WORST | HASWIDTH | (flags & (HASNL | HASLOOKBH)));\n    break;\n\n  case Magic('@'):\n  {\n    int lop = END;\n    int64_t nr = getdecchrs();\n\n    switch (no_Magic(getchr())) {\n    case '=': lop = MATCH; break;                                 /* \\@= */\n    case '!': lop = NOMATCH; break;                               /* \\@! */\n    case '>': lop = SUBPAT; break;                                /* \\@> */\n    case '<': switch (no_Magic(getchr())) {\n      case '=': lop = BEHIND; break;                               /* \\@<= */\n      case '!': lop = NOBEHIND; break;                             /* \\@<! */\n    }\n    }\n    if (lop == END)\n      EMSG2_RET_NULL(_(\"E59: invalid character after %s@\"),\n          reg_magic == MAGIC_ALL);\n    /* Look behind must match with behind_pos. */\n    if (lop == BEHIND || lop == NOBEHIND) {\n      regtail(ret, regnode(BHPOS));\n      *flagp |= HASLOOKBH;\n    }\n    regtail(ret, regnode(END));             /* operand ends */\n    if (lop == BEHIND || lop == NOBEHIND) {\n      if (nr < 0)\n        nr = 0;                 /* no limit is same as zero limit */\n      reginsert_nr(lop, (uint32_t)nr, ret);\n    } else\n      reginsert(lop, ret);\n    break;\n  }\n\n  case Magic('?'):\n  case Magic('='):\n    /* Emit x= as (x|) */\n    reginsert(BRANCH, ret);                     /* Either x */\n    regtail(ret, regnode(BRANCH));              /* or */\n    next = regnode(NOTHING);                    /* null. */\n    regtail(ret, next);\n    regoptail(ret, next);\n    break;\n\n  case Magic('{'):\n    if (!read_limits(&minval, &maxval))\n      return NULL;\n    if (flags & SIMPLE) {\n      reginsert(BRACE_SIMPLE, ret);\n      reginsert_limits(BRACE_LIMITS, minval, maxval, ret);\n    } else {\n      if (num_complex_braces >= 10)\n        EMSG2_RET_NULL(_(\"E60: Too many complex %s{...}s\"),\n            reg_magic == MAGIC_ALL);\n      reginsert(BRACE_COMPLEX + num_complex_braces, ret);\n      regoptail(ret, regnode(BACK));\n      regoptail(ret, ret);\n      reginsert_limits(BRACE_LIMITS, minval, maxval, ret);\n      ++num_complex_braces;\n    }\n    if (minval > 0 && maxval > 0)\n      *flagp = (HASWIDTH | (flags & (HASNL | HASLOOKBH)));\n    break;\n  }\n  if (re_multi_type(peekchr()) != NOT_MULTI) {\n    /* Can't have a multi follow a multi. */\n    if (peekchr() == Magic('*'))\n      sprintf((char *)IObuff, _(\"E61: Nested %s*\"),\n          reg_magic >= MAGIC_ON ? \"\" : \"\\\\\");\n    else\n      sprintf((char *)IObuff, _(\"E62: Nested %s%c\"),\n          reg_magic == MAGIC_ALL ? \"\" : \"\\\\\", no_Magic(peekchr()));\n    EMSG_RET_NULL(IObuff);\n  }\n\n  return ret;\n}\n\n/* When making changes to classchars also change nfa_classcodes. */\nstatic char_u   *classchars = (char_u *)\".iIkKfFpPsSdDxXoOwWhHaAlLuU\";\nstatic int classcodes[] = {\n  ANY, IDENT, SIDENT, KWORD, SKWORD,\n  FNAME, SFNAME, PRINT, SPRINT,\n  WHITE, NWHITE, DIGIT, NDIGIT,\n  HEX, NHEX, OCTAL, NOCTAL,\n  WORD, NWORD, HEAD, NHEAD,\n  ALPHA, NALPHA, LOWER, NLOWER,\n  UPPER, NUPPER\n};\n\n/*\n * Parse the lowest level.\n *\n * Optimization:  gobbles an entire sequence of ordinary characters so that\n * it can turn them into a single node, which is smaller to store and\n * faster to run.  Don't do this when one_exactly is set.\n */\nstatic char_u *regatom(int *flagp)\n{\n  char_u          *ret;\n  int flags;\n  int c;\n  char_u          *p;\n  int extra = 0;\n  int save_prev_at_start = prev_at_start;\n\n  *flagp = WORST;               /* Tentatively. */\n\n  c = getchr();\n  switch (c) {\n  case Magic('^'):\n    ret = regnode(BOL);\n    break;\n\n  case Magic('$'):\n    ret = regnode(EOL);\n    had_eol = true;\n    break;\n\n  case Magic('<'):\n    ret = regnode(BOW);\n    break;\n\n  case Magic('>'):\n    ret = regnode(EOW);\n    break;\n\n  case Magic('_'):\n    c = no_Magic(getchr());\n    if (c == '^') {             /* \"\\_^\" is start-of-line */\n      ret = regnode(BOL);\n      break;\n    }\n    if (c == '$') {             /* \"\\_$\" is end-of-line */\n      ret = regnode(EOL);\n      had_eol = true;\n      break;\n    }\n\n    extra = ADD_NL;\n    *flagp |= HASNL;\n\n    /* \"\\_[\" is character range plus newline */\n    if (c == '[')\n      goto collection;\n\n  // \"\\_x\" is character class plus newline\n  FALLTHROUGH;\n\n  /*\n   * Character classes.\n   */\n  case Magic('.'):\n  case Magic('i'):\n  case Magic('I'):\n  case Magic('k'):\n  case Magic('K'):\n  case Magic('f'):\n  case Magic('F'):\n  case Magic('p'):\n  case Magic('P'):\n  case Magic('s'):\n  case Magic('S'):\n  case Magic('d'):\n  case Magic('D'):\n  case Magic('x'):\n  case Magic('X'):\n  case Magic('o'):\n  case Magic('O'):\n  case Magic('w'):\n  case Magic('W'):\n  case Magic('h'):\n  case Magic('H'):\n  case Magic('a'):\n  case Magic('A'):\n  case Magic('l'):\n  case Magic('L'):\n  case Magic('u'):\n  case Magic('U'):\n    p = vim_strchr(classchars, no_Magic(c));\n    if (p == NULL)\n      EMSG_RET_NULL(_(\"E63: invalid use of \\\\_\"));\n    /* When '.' is followed by a composing char ignore the dot, so that\n     * the composing char is matched here. */\n    if (c == Magic('.') && utf_iscomposing(peekchr())) {\n      c = getchr();\n      goto do_multibyte;\n    }\n    ret = regnode(classcodes[p - classchars] + extra);\n    *flagp |= HASWIDTH | SIMPLE;\n    break;\n\n  case Magic('n'):\n    if (reg_string) {\n      /* In a string \"\\n\" matches a newline character. */\n      ret = regnode(EXACTLY);\n      regc(NL);\n      regc(NUL);\n      *flagp |= HASWIDTH | SIMPLE;\n    } else {\n      /* In buffer text \"\\n\" matches the end of a line. */\n      ret = regnode(NEWL);\n      *flagp |= HASWIDTH | HASNL;\n    }\n    break;\n\n  case Magic('('):\n    if (one_exactly)\n      EMSG_ONE_RET_NULL;\n    ret = reg(REG_PAREN, &flags);\n    if (ret == NULL)\n      return NULL;\n    *flagp |= flags & (HASWIDTH | SPSTART | HASNL | HASLOOKBH);\n    break;\n\n  case NUL:\n  case Magic('|'):\n  case Magic('&'):\n  case Magic(')'):\n    if (one_exactly)\n      EMSG_ONE_RET_NULL;\n    IEMSG_RET_NULL(_(e_internal));       // Supposed to be caught earlier.\n  // NOTREACHED\n\n  case Magic('='):\n  case Magic('?'):\n  case Magic('+'):\n  case Magic('@'):\n  case Magic('{'):\n  case Magic('*'):\n    c = no_Magic(c);\n    sprintf((char *)IObuff, _(\"E64: %s%c follows nothing\"),\n        (c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL)\n        ? \"\" : \"\\\\\", c);\n    EMSG_RET_NULL(IObuff);\n  /* NOTREACHED */\n\n  case Magic('~'):              /* previous substitute pattern */\n    if (reg_prev_sub != NULL) {\n      char_u      *lp;\n\n      ret = regnode(EXACTLY);\n      lp = reg_prev_sub;\n      while (*lp != NUL)\n        regc(*lp++);\n      regc(NUL);\n      if (*reg_prev_sub != NUL) {\n        *flagp |= HASWIDTH;\n        if ((lp - reg_prev_sub) == 1)\n          *flagp |= SIMPLE;\n      }\n    } else\n      EMSG_RET_NULL(_(e_nopresub));\n    break;\n\n  case Magic('1'):\n  case Magic('2'):\n  case Magic('3'):\n  case Magic('4'):\n  case Magic('5'):\n  case Magic('6'):\n  case Magic('7'):\n  case Magic('8'):\n  case Magic('9'):\n  {\n    int refnum;\n\n    refnum = c - Magic('0');\n    if (!seen_endbrace(refnum)) {\n      return NULL;\n    }\n    ret = regnode(BACKREF + refnum);\n  }\n  break;\n\n  case Magic('z'):\n  {\n    c = no_Magic(getchr());\n    switch (c) {\n    case '(': if ((reg_do_extmatch & REX_SET) == 0)\n        EMSG_RET_NULL(_(e_z_not_allowed));\n      if (one_exactly)\n        EMSG_ONE_RET_NULL;\n      ret = reg(REG_ZPAREN, &flags);\n      if (ret == NULL)\n        return NULL;\n      *flagp |= flags & (HASWIDTH|SPSTART|HASNL|HASLOOKBH);\n      re_has_z = REX_SET;\n      break;\n\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9': if ((reg_do_extmatch & REX_USE) == 0)\n        EMSG_RET_NULL(_(e_z1_not_allowed));\n      ret = regnode(ZREF + c - '0');\n      re_has_z = REX_USE;\n      break;\n\n    case 's': ret = regnode(MOPEN + 0);\n      if (!re_mult_next(\"\\\\zs\")) {\n        return NULL;\n      }\n      break;\n\n    case 'e': ret = regnode(MCLOSE + 0);\n      if (!re_mult_next(\"\\\\ze\")) {\n        return NULL;\n      }\n      break;\n\n    default:  EMSG_RET_NULL(_(\"E68: Invalid character after \\\\z\"));\n    }\n  }\n  break;\n\n  case Magic('%'):\n  {\n    c = no_Magic(getchr());\n    switch (c) {\n    /* () without a back reference */\n    case '(':\n      if (one_exactly)\n        EMSG_ONE_RET_NULL;\n      ret = reg(REG_NPAREN, &flags);\n      if (ret == NULL)\n        return NULL;\n      *flagp |= flags & (HASWIDTH | SPSTART | HASNL | HASLOOKBH);\n      break;\n\n    /* Catch \\%^ and \\%$ regardless of where they appear in the\n     * pattern -- regardless of whether or not it makes sense. */\n    case '^':\n      ret = regnode(RE_BOF);\n      break;\n\n    case '$':\n      ret = regnode(RE_EOF);\n      break;\n\n    case '#':\n      ret = regnode(CURSOR);\n      break;\n\n    case 'V':\n      ret = regnode(RE_VISUAL);\n      break;\n\n    case 'C':\n      ret = regnode(RE_COMPOSING);\n      break;\n\n    /* \\%[abc]: Emit as a list of branches, all ending at the last\n     * branch which matches nothing. */\n    case '[':\n      if (one_exactly)                          /* doesn't nest */\n        EMSG_ONE_RET_NULL;\n      {\n        char_u    *lastbranch;\n        char_u    *lastnode = NULL;\n        char_u    *br;\n\n        ret = NULL;\n        while ((c = getchr()) != ']') {\n          if (c == NUL)\n            EMSG2_RET_NULL(_(e_missing_sb),\n                reg_magic == MAGIC_ALL);\n          br = regnode(BRANCH);\n          if (ret == NULL) {\n            ret = br;\n          } else {\n            regtail(lastnode, br);\n            if (reg_toolong) {\n              return NULL;\n            }\n          }\n\n          ungetchr();\n          one_exactly = true;\n          lastnode = regatom(flagp);\n          one_exactly = false;\n          if (lastnode == NULL) {\n            return NULL;\n          }\n        }\n        if (ret == NULL)\n          EMSG2_RET_NULL(_(e_empty_sb),\n              reg_magic == MAGIC_ALL);\n        lastbranch = regnode(BRANCH);\n        br = regnode(NOTHING);\n        if (ret != JUST_CALC_SIZE) {\n          regtail(lastnode, br);\n          regtail(lastbranch, br);\n          /* connect all branches to the NOTHING\n           * branch at the end */\n          for (br = ret; br != lastnode; ) {\n            if (OP(br) == BRANCH) {\n              regtail(br, lastbranch);\n              if (reg_toolong) {\n                return NULL;\n              }\n              br = OPERAND(br);\n            } else\n              br = regnext(br);\n          }\n        }\n        *flagp &= ~(HASWIDTH | SIMPLE);\n        break;\n      }\n\n    case 'd':               /* %d123 decimal */\n    case 'o':               /* %o123 octal */\n    case 'x':               /* %xab hex 2 */\n    case 'u':               /* %uabcd hex 4 */\n    case 'U':               /* %U1234abcd hex 8 */\n    {\n      int64_t i;\n\n      switch (c) {\n      case 'd': i = getdecchrs(); break;\n      case 'o': i = getoctchrs(); break;\n      case 'x': i = gethexchrs(2); break;\n      case 'u': i = gethexchrs(4); break;\n      case 'U': i = gethexchrs(8); break;\n      default:  i = -1; break;\n      }\n\n      if (i < 0 || i > INT_MAX) {\n        EMSG2_RET_NULL(_(\"E678: Invalid character after %s%%[dxouU]\"),\n                       reg_magic == MAGIC_ALL);\n      }\n      if (use_multibytecode(i)) {\n        ret = regnode(MULTIBYTECODE);\n      } else {\n        ret = regnode(EXACTLY);\n      }\n      if (i == 0) {\n        regc(0x0a);\n      } else {\n        regmbc(i);\n      }\n      regc(NUL);\n      *flagp |= HASWIDTH;\n      break;\n    }\n\n    default:\n      if (ascii_isdigit(c) || c == '<' || c == '>'\n          || c == '\\'') {\n        uint32_t n = 0;\n        int cmp;\n\n        cmp = c;\n        if (cmp == '<' || cmp == '>')\n          c = getchr();\n        while (ascii_isdigit(c)) {\n          n = n * 10 + (uint32_t)(c - '0');\n          c = getchr();\n        }\n        if (c == '\\'' && n == 0) {\n          /* \"\\%'m\", \"\\%<'m\" and \"\\%>'m\": Mark */\n          c = getchr();\n          ret = regnode(RE_MARK);\n          if (ret == JUST_CALC_SIZE)\n            regsize += 2;\n          else {\n            *regcode++ = c;\n            *regcode++ = cmp;\n          }\n          break;\n        } else if (c == 'l' || c == 'c' || c == 'v') {\n          if (c == 'l') {\n            ret = regnode(RE_LNUM);\n            if (save_prev_at_start) {\n              at_start = true;\n            }\n          } else if (c == 'c') {\n            ret = regnode(RE_COL);\n          } else {\n            ret = regnode(RE_VCOL);\n          }\n          if (ret == JUST_CALC_SIZE) {\n            regsize += 5;\n          } else {\n            // put the number and the optional\n            // comparator after the opcode\n            regcode = re_put_uint32(regcode, n);\n            *regcode++ = cmp;\n          }\n          break;\n        }\n      }\n\n      EMSG2_RET_NULL(_(\"E71: Invalid character after %s%%\"),\n          reg_magic == MAGIC_ALL);\n    }\n  }\n  break;\n\n  case Magic('['):\ncollection:\n    {\n      char_u      *lp;\n\n      /*\n       * If there is no matching ']', we assume the '[' is a normal\n       * character.  This makes 'incsearch' and \":help [\" work.\n       */\n      lp = skip_anyof(regparse);\n      if (*lp == ']') {         /* there is a matching ']' */\n        int startc = -1;                /* > 0 when next '-' is a range */\n        int endc;\n\n        /*\n         * In a character class, different parsing rules apply.\n         * Not even \\ is special anymore, nothing is.\n         */\n        if (*regparse == '^') {             /* Complement of range. */\n          ret = regnode(ANYBUT + extra);\n          regparse++;\n        } else\n          ret = regnode(ANYOF + extra);\n\n        /* At the start ']' and '-' mean the literal character. */\n        if (*regparse == ']' || *regparse == '-') {\n          startc = *regparse;\n          regc(*regparse++);\n        }\n\n        while (*regparse != NUL && *regparse != ']') {\n          if (*regparse == '-') {\n            ++regparse;\n            /* The '-' is not used for a range at the end and\n             * after or before a '\\n'. */\n            if (*regparse == ']' || *regparse == NUL\n                || startc == -1\n                || (regparse[0] == '\\\\' && regparse[1] == 'n')) {\n              regc('-');\n              startc = '-';                     /* [--x] is a range */\n            } else {\n              /* Also accept \"a-[.z.]\" */\n              endc = 0;\n              if (*regparse == '[')\n                endc = get_coll_element(&regparse);\n              if (endc == 0) {\n                endc = mb_ptr2char_adv((const char_u **)&regparse);\n              }\n\n              /* Handle \\o40, \\x20 and \\u20AC style sequences */\n              if (endc == '\\\\' && !reg_cpo_lit)\n                endc = coll_get_char();\n\n              if (startc > endc) {\n                EMSG_RET_NULL(_(e_reverse_range));\n              }\n              if ((*mb_char2len)(startc) > 1\n                  || (*mb_char2len)(endc) > 1) {\n                // Limit to a range of 256 chars\n                if (endc > startc + 256) {\n                  EMSG_RET_NULL(_(e_large_class));\n                }\n                while (++startc <= endc) {\n                  regmbc(startc);\n                }\n              } else {\n                while (++startc <= endc)\n                  regc(startc);\n              }\n              startc = -1;\n            }\n          }\n          /*\n           * Only \"\\]\", \"\\^\", \"\\]\" and \"\\\\\" are special in Vi.  Vim\n           * accepts \"\\t\", \"\\e\", etc., but only when the 'l' flag in\n           * 'cpoptions' is not included.\n           */\n          else if (*regparse == '\\\\'\n                   && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL\n                       || (!reg_cpo_lit\n                           && vim_strchr(REGEXP_ABBR,\n                               regparse[1]) != NULL))) {\n            regparse++;\n            if (*regparse == 'n') {\n              /* '\\n' in range: also match NL */\n              if (ret != JUST_CALC_SIZE) {\n                /* Using \\n inside [^] does not change what\n                 * matches. \"[^\\n]\" is the same as \".\". */\n                if (*ret == ANYOF) {\n                  *ret = ANYOF + ADD_NL;\n                  *flagp |= HASNL;\n                }\n                /* else: must have had a \\n already */\n              }\n              regparse++;\n              startc = -1;\n            } else if (*regparse == 'd'\n                       || *regparse == 'o'\n                       || *regparse == 'x'\n                       || *regparse == 'u'\n                       || *regparse == 'U') {\n              startc = coll_get_char();\n              if (startc == 0)\n                regc(0x0a);\n              else\n                regmbc(startc);\n            } else {\n              startc = backslash_trans(*regparse++);\n              regc(startc);\n            }\n          } else if (*regparse == '[') {\n            int c_class;\n            int cu;\n\n            c_class = get_char_class(&regparse);\n            startc = -1;\n            /* Characters assumed to be 8 bits! */\n            switch (c_class) {\n            case CLASS_NONE:\n              c_class = get_equi_class(&regparse);\n              if (c_class != 0) {\n                /* produce equivalence class */\n                reg_equi_class(c_class);\n              } else if ((c_class =\n                            get_coll_element(&regparse)) != 0) {\n                /* produce a collating element */\n                regmbc(c_class);\n              } else {\n                /* literal '[', allow [[-x] as a range */\n                startc = *regparse++;\n                regc(startc);\n              }\n              break;\n            case CLASS_ALNUM:\n              for (cu = 1; cu < 128; cu++) {\n                if (isalnum(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_ALPHA:\n              for (cu = 1; cu < 128; cu++) {\n                if (isalpha(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_BLANK:\n              regc(' ');\n              regc('\\t');\n              break;\n            case CLASS_CNTRL:\n              for (cu = 1; cu <= 127; cu++) {\n                if (iscntrl(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_DIGIT:\n              for (cu = 1; cu <= 127; cu++) {\n                if (ascii_isdigit(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_GRAPH:\n              for (cu = 1; cu <= 127; cu++) {\n                if (isgraph(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_LOWER:\n              for (cu = 1; cu <= 255; cu++) {\n                if (mb_islower(cu) && cu != 170 && cu != 186) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_PRINT:\n              for (cu = 1; cu <= 255; cu++) {\n                if (vim_isprintc(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_PUNCT:\n              for (cu = 1; cu < 128; cu++) {\n                if (ispunct(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_SPACE:\n              for (cu = 9; cu <= 13; cu++)\n                regc(cu);\n              regc(' ');\n              break;\n            case CLASS_UPPER:\n              for (cu = 1; cu <= 255; cu++) {\n                if (mb_isupper(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_XDIGIT:\n              for (cu = 1; cu <= 255; cu++) {\n                if (ascii_isxdigit(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_TAB:\n              regc('\\t');\n              break;\n            case CLASS_RETURN:\n              regc('\\r');\n              break;\n            case CLASS_BACKSPACE:\n              regc('\\b');\n              break;\n            case CLASS_ESCAPE:\n              regc(ESC);\n              break;\n            case CLASS_IDENT:\n              for (cu = 1; cu <= 255; cu++) {\n                if (vim_isIDc(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_KEYWORD:\n              for (cu = 1; cu <= 255; cu++) {\n                if (reg_iswordc(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_FNAME:\n              for (cu = 1; cu <= 255; cu++) {\n                if (vim_isfilec(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            }\n          } else {\n            // produce a multibyte character, including any\n            // following composing characters.\n            startc = utf_ptr2char(regparse);\n            int len = utfc_ptr2len(regparse);\n            if (utf_char2len(startc) != len) {\n              // composing chars\n              startc = -1;\n            }\n            while (--len >= 0) {\n              regc(*regparse++);\n            }\n          }\n        }\n        regc(NUL);\n        prevchr_len = 1;                /* last char was the ']' */\n        if (*regparse != ']')\n          EMSG_RET_NULL(_(e_toomsbra));                 /* Cannot happen? */\n        skipchr();                  /* let's be friends with the lexer again */\n        *flagp |= HASWIDTH | SIMPLE;\n        break;\n      } else if (reg_strict)\n        EMSG2_RET_NULL(_(e_missingbracket), reg_magic > MAGIC_OFF);\n    }\n    FALLTHROUGH;\n\n  default:\n  {\n    int len;\n\n    /* A multi-byte character is handled as a separate atom if it's\n     * before a multi and when it's a composing char. */\n    if (use_multibytecode(c)) {\ndo_multibyte:\n      ret = regnode(MULTIBYTECODE);\n      regmbc(c);\n      *flagp |= HASWIDTH | SIMPLE;\n      break;\n    }\n\n    ret = regnode(EXACTLY);\n\n    /*\n     * Append characters as long as:\n     * - there is no following multi, we then need the character in\n     *   front of it as a single character operand\n     * - not running into a Magic character\n     * - \"one_exactly\" is not set\n     * But always emit at least one character.  Might be a Multi,\n     * e.g., a \"[\" without matching \"]\".\n     */\n    for (len = 0; c != NUL && (len == 0\n                               || (re_multi_type(peekchr()) == NOT_MULTI\n                                   && !one_exactly\n                                   && !is_Magic(c))); ++len) {\n      c = no_Magic(c);\n      {\n        regmbc(c);\n        {\n          int l;\n\n          /* Need to get composing character too. */\n          for (;; ) {\n            l = utf_ptr2len(regparse);\n            if (!UTF_COMPOSINGLIKE(regparse, regparse + l))\n              break;\n            regmbc(utf_ptr2char(regparse));\n            skipchr();\n          }\n        }\n      }\n      c = getchr();\n    }\n    ungetchr();\n\n    regc(NUL);\n    *flagp |= HASWIDTH;\n    if (len == 1)\n      *flagp |= SIMPLE;\n  }\n  break;\n  }\n\n  return ret;\n}\n\n/// Used in a place where no * or \\+ can follow.\nstatic bool re_mult_next(char *what)\n{\n  if (re_multi_type(peekchr()) == MULTI_MULT) {\n    EMSG2_RET_FAIL(_(\"E888: (NFA regexp) cannot repeat %s\"), what);\n  }\n  return true;\n}\n\n// Return true if MULTIBYTECODE should be used instead of EXACTLY for\n// character \"c\".\nstatic bool use_multibytecode(int c)\n{\n  return utf_char2len(c) > 1\n         && (re_multi_type(peekchr()) != NOT_MULTI\n             || utf_iscomposing(c));\n}\n\n/*\n * Emit a node.\n * Return pointer to generated code.\n */\nstatic char_u *regnode(int op)\n{\n  char_u  *ret;\n\n  ret = regcode;\n  if (ret == JUST_CALC_SIZE)\n    regsize += 3;\n  else {\n    *regcode++ = op;\n    *regcode++ = NUL;                   /* Null \"next\" pointer. */\n    *regcode++ = NUL;\n  }\n  return ret;\n}\n\n/*\n * Emit (if appropriate) a byte of code\n */\nstatic void regc(int b)\n{\n  if (regcode == JUST_CALC_SIZE)\n    regsize++;\n  else\n    *regcode++ = b;\n}\n\n/*\n * Emit (if appropriate) a multi-byte character of code\n */\nstatic void regmbc(int c)\n{\n  if (regcode == JUST_CALC_SIZE) {\n    regsize += utf_char2len(c);\n  } else {\n    regcode += utf_char2bytes(c, regcode);\n  }\n}\n\n/*\n * Insert an operator in front of already-emitted operand\n *\n * Means relocating the operand.\n */\nstatic void reginsert(int op, char_u *opnd)\n{\n  char_u      *src;\n  char_u      *dst;\n  char_u      *place;\n\n  if (regcode == JUST_CALC_SIZE) {\n    regsize += 3;\n    return;\n  }\n  src = regcode;\n  regcode += 3;\n  dst = regcode;\n  while (src > opnd)\n    *--dst = *--src;\n\n  place = opnd;                 /* Op node, where operand used to be. */\n  *place++ = op;\n  *place++ = NUL;\n  *place = NUL;\n}\n\n/*\n * Insert an operator in front of already-emitted operand.\n * Add a number to the operator.\n */\nstatic void reginsert_nr(int op, long val, char_u *opnd)\n{\n  char_u      *src;\n  char_u      *dst;\n  char_u      *place;\n\n  if (regcode == JUST_CALC_SIZE) {\n    regsize += 7;\n    return;\n  }\n  src = regcode;\n  regcode += 7;\n  dst = regcode;\n  while (src > opnd)\n    *--dst = *--src;\n\n  place = opnd;                 /* Op node, where operand used to be. */\n  *place++ = op;\n  *place++ = NUL;\n  *place++ = NUL;\n  assert(val >= 0 && (uintmax_t)val <= UINT32_MAX);\n  re_put_uint32(place, (uint32_t)val);\n}\n\n/*\n * Insert an operator in front of already-emitted operand.\n * The operator has the given limit values as operands.  Also set next pointer.\n *\n * Means relocating the operand.\n */\nstatic void reginsert_limits(int op, long minval, long maxval, char_u *opnd)\n{\n  char_u      *src;\n  char_u      *dst;\n  char_u      *place;\n\n  if (regcode == JUST_CALC_SIZE) {\n    regsize += 11;\n    return;\n  }\n  src = regcode;\n  regcode += 11;\n  dst = regcode;\n  while (src > opnd)\n    *--dst = *--src;\n\n  place = opnd;                 /* Op node, where operand used to be. */\n  *place++ = op;\n  *place++ = NUL;\n  *place++ = NUL;\n  assert(minval >= 0 && (uintmax_t)minval <= UINT32_MAX);\n  place = re_put_uint32(place, (uint32_t)minval);\n  assert(maxval >= 0 && (uintmax_t)maxval <= UINT32_MAX);\n  place = re_put_uint32(place, (uint32_t)maxval);\n  regtail(opnd, place);\n}\n\n/*\n * Write a four bytes number at \"p\" and return pointer to the next char.\n */\nstatic char_u *re_put_uint32(char_u *p, uint32_t val)\n{\n  *p++ = (char_u) ((val >> 24) & 0377);\n  *p++ = (char_u) ((val >> 16) & 0377);\n  *p++ = (char_u) ((val >> 8) & 0377);\n  *p++ = (char_u) (val & 0377);\n  return p;\n}\n\n// Set the next-pointer at the end of a node chain.\nstatic void regtail(char_u *p, char_u *val)\n{\n  int offset;\n\n  if (p == JUST_CALC_SIZE) {\n    return;\n  }\n\n  // Find last node.\n  char_u *scan = p;\n  for (;; ) {\n    char_u *temp = regnext(scan);\n    if (temp == NULL) {\n      break;\n    }\n    scan = temp;\n  }\n\n  if (OP(scan) == BACK) {\n    offset = (int)(scan - val);\n  } else {\n    offset = (int)(val - scan);\n  }\n  // When the offset uses more than 16 bits it can no longer fit in the two\n  // bytes available.  Use a global flag to avoid having to check return\n  // values in too many places.\n  if (offset > 0xffff) {\n    reg_toolong = true;\n  } else {\n    *(scan + 1) = (char_u)(((unsigned)offset >> 8) & 0377);\n    *(scan + 2) = (char_u)(offset & 0377);\n  }\n}\n\n/*\n * Like regtail, on item after a BRANCH; nop if none.\n */\nstatic void regoptail(char_u *p, char_u *val)\n{\n  /* When op is neither BRANCH nor BRACE_COMPLEX0-9, it is \"operandless\" */\n  if (p == NULL || p == JUST_CALC_SIZE\n      || (OP(p) != BRANCH\n          && (OP(p) < BRACE_COMPLEX || OP(p) > BRACE_COMPLEX + 9)))\n    return;\n  regtail(OPERAND(p), val);\n}\n\n/*\n * Functions for getting characters from the regexp input.\n */\n\n/*\n * Start parsing at \"str\".\n */\nstatic void initchr(char_u *str)\n{\n  regparse = str;\n  prevchr_len = 0;\n  curchr = prevprevchr = prevchr = nextchr = -1;\n  at_start = true;\n  prev_at_start = false;\n}\n\n/*\n * Save the current parse state, so that it can be restored and parsing\n * starts in the same state again.\n */\nstatic void save_parse_state(parse_state_T *ps)\n{\n  ps->regparse = regparse;\n  ps->prevchr_len = prevchr_len;\n  ps->curchr = curchr;\n  ps->prevchr = prevchr;\n  ps->prevprevchr = prevprevchr;\n  ps->nextchr = nextchr;\n  ps->at_start = at_start;\n  ps->prev_at_start = prev_at_start;\n  ps->regnpar = regnpar;\n}\n\n/*\n * Restore a previously saved parse state.\n */\nstatic void restore_parse_state(parse_state_T *ps)\n{\n  regparse = ps->regparse;\n  prevchr_len = ps->prevchr_len;\n  curchr = ps->curchr;\n  prevchr = ps->prevchr;\n  prevprevchr = ps->prevprevchr;\n  nextchr = ps->nextchr;\n  at_start = ps->at_start;\n  prev_at_start = ps->prev_at_start;\n  regnpar = ps->regnpar;\n}\n\n\n/*\n * Get the next character without advancing.\n */\nstatic int peekchr(void)\n{\n  static int after_slash = false;\n\n  if (curchr != -1) {\n    return curchr;\n  }\n\n  switch (curchr = regparse[0]) {\n  case '.':\n  case '[':\n  case '~':\n    /* magic when 'magic' is on */\n    if (reg_magic >= MAGIC_ON)\n      curchr = Magic(curchr);\n    break;\n  case '(':\n  case ')':\n  case '{':\n  case '%':\n  case '+':\n  case '=':\n  case '?':\n  case '@':\n  case '!':\n  case '&':\n  case '|':\n  case '<':\n  case '>':\n  case '#':           /* future ext. */\n  case '\"':           /* future ext. */\n  case '\\'':          /* future ext. */\n  case ',':           /* future ext. */\n  case '-':           /* future ext. */\n  case ':':           /* future ext. */\n  case ';':           /* future ext. */\n  case '`':           /* future ext. */\n  case '/':           /* Can't be used in / command */\n    /* magic only after \"\\v\" */\n    if (reg_magic == MAGIC_ALL)\n      curchr = Magic(curchr);\n    break;\n  case '*':\n    /* * is not magic as the very first character, eg \"?*ptr\", when\n     * after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But\n     * \"\\(\\*\" is not magic, thus must be magic if \"after_slash\" */\n    if (reg_magic >= MAGIC_ON\n        && !at_start\n        && !(prev_at_start && prevchr == Magic('^'))\n        && (after_slash\n            || (prevchr != Magic('(')\n                && prevchr != Magic('&')\n                && prevchr != Magic('|'))))\n      curchr = Magic('*');\n    break;\n  case '^':\n    /* '^' is only magic as the very first character and if it's after\n     * \"\\(\", \"\\|\", \"\\&' or \"\\n\" */\n    if (reg_magic >= MAGIC_OFF\n        && (at_start\n            || reg_magic == MAGIC_ALL\n            || prevchr == Magic('(')\n            || prevchr == Magic('|')\n            || prevchr == Magic('&')\n            || prevchr == Magic('n')\n            || (no_Magic(prevchr) == '('\n                && prevprevchr == Magic('%')))) {\n      curchr = Magic('^');\n      at_start = true;\n      prev_at_start = false;\n    }\n    break;\n  case '$':\n    /* '$' is only magic as the very last char and if it's in front of\n     * either \"\\|\", \"\\)\", \"\\&\", or \"\\n\" */\n    if (reg_magic >= MAGIC_OFF) {\n      char_u *p = regparse + 1;\n      bool is_magic_all = (reg_magic == MAGIC_ALL);\n\n      // ignore \\c \\C \\m \\M \\v \\V and \\Z after '$'\n      while (p[0] == '\\\\' && (p[1] == 'c' || p[1] == 'C'\n                              || p[1] == 'm' || p[1] == 'M'\n                              || p[1] == 'v' || p[1] == 'V'\n                              || p[1] == 'Z')) {\n        if (p[1] == 'v') {\n          is_magic_all = true;\n        } else if (p[1] == 'm' || p[1] == 'M' || p[1] == 'V') {\n          is_magic_all = false;\n        }\n        p += 2;\n      }\n      if (p[0] == NUL\n          || (p[0] == '\\\\'\n              && (p[1] == '|' || p[1] == '&' || p[1] == ')'\n                  || p[1] == 'n'))\n          || (is_magic_all\n              && (p[0] == '|' || p[0] == '&' || p[0] == ')'))\n          || reg_magic == MAGIC_ALL) {\n        curchr = Magic('$');\n      }\n    }\n    break;\n  case '\\\\':\n  {\n    int c = regparse[1];\n\n    if (c == NUL)\n      curchr = '\\\\';                  /* trailing '\\' */\n    else if (\n      c <= '~' && META_flags[c]\n      ) {\n      /*\n       * META contains everything that may be magic sometimes,\n       * except ^ and $ (\"\\^\" and \"\\$\" are only magic after\n       * \"\\V\").  We now fetch the next character and toggle its\n       * magicness.  Therefore, \\ is so meta-magic that it is\n       * not in META.\n       */\n      curchr = -1;\n      prev_at_start = at_start;\n      at_start = false;  // be able to say \"/\\*ptr\"\n      regparse++;\n      after_slash++;\n      (void)peekchr();\n      regparse--;\n      after_slash--;\n      curchr = toggle_Magic(curchr);\n    } else if (vim_strchr(REGEXP_ABBR, c)) {\n      /*\n       * Handle abbreviations, like \"\\t\" for TAB -- webb\n       */\n      curchr = backslash_trans(c);\n    } else if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))\n      curchr = toggle_Magic(c);\n    else {\n      /*\n       * Next character can never be (made) magic?\n       * Then backslashing it won't do anything.\n       */\n      curchr = utf_ptr2char(regparse + 1);\n    }\n    break;\n  }\n\n  default:\n    curchr = utf_ptr2char(regparse);\n  }\n\n  return curchr;\n}\n\n/*\n * Eat one lexed character.  Do this in a way that we can undo it.\n */\nstatic void skipchr(void)\n{\n  /* peekchr() eats a backslash, do the same here */\n  if (*regparse == '\\\\')\n    prevchr_len = 1;\n  else\n    prevchr_len = 0;\n  if (regparse[prevchr_len] != NUL) {\n    // Exclude composing chars that utfc_ptr2len does include.\n    prevchr_len += utf_ptr2len(regparse + prevchr_len);\n  }\n  regparse += prevchr_len;\n  prev_at_start = at_start;\n  at_start = false;\n  prevprevchr = prevchr;\n  prevchr = curchr;\n  curchr = nextchr;         /* use previously unget char, or -1 */\n  nextchr = -1;\n}\n\n/*\n * Skip a character while keeping the value of prev_at_start for at_start.\n * prevchr and prevprevchr are also kept.\n */\nstatic void skipchr_keepstart(void)\n{\n  int as = prev_at_start;\n  int pr = prevchr;\n  int prpr = prevprevchr;\n\n  skipchr();\n  at_start = as;\n  prevchr = pr;\n  prevprevchr = prpr;\n}\n\n/*\n * Get the next character from the pattern. We know about magic and such, so\n * therefore we need a lexical analyzer.\n */\nstatic int getchr(void)\n{\n  int chr = peekchr();\n\n  skipchr();\n  return chr;\n}\n\n/*\n * put character back.  Works only once!\n */\nstatic void ungetchr(void)\n{\n  nextchr = curchr;\n  curchr = prevchr;\n  prevchr = prevprevchr;\n  at_start = prev_at_start;\n  prev_at_start = false;\n\n  /* Backup regparse, so that it's at the same position as before the\n   * getchr(). */\n  regparse -= prevchr_len;\n}\n\n/*\n * Get and return the value of the hex string at the current position.\n * Return -1 if there is no valid hex number.\n * The position is updated:\n *     blahblah\\%x20asdf\n *\t   before-^ ^-after\n * The parameter controls the maximum number of input characters. This will be\n * 2 when reading a \\%x20 sequence and 4 when reading a \\%u20AC sequence.\n */\nstatic int64_t gethexchrs(int maxinputlen)\n{\n  int64_t nr = 0;\n  int c;\n  int i;\n\n  for (i = 0; i < maxinputlen; ++i) {\n    c = regparse[0];\n    if (!ascii_isxdigit(c))\n      break;\n    nr <<= 4;\n    nr |= hex2nr(c);\n    ++regparse;\n  }\n\n  if (i == 0)\n    return -1;\n  return nr;\n}\n\n/*\n * Get and return the value of the decimal string immediately after the\n * current position. Return -1 for invalid.  Consumes all digits.\n */\nstatic int64_t getdecchrs(void)\n{\n  int64_t nr = 0;\n  int c;\n  int i;\n\n  for (i = 0;; ++i) {\n    c = regparse[0];\n    if (c < '0' || c > '9')\n      break;\n    nr *= 10;\n    nr += c - '0';\n    ++regparse;\n    curchr = -1;     /* no longer valid */\n  }\n\n  if (i == 0)\n    return -1;\n  return nr;\n}\n\n/*\n * get and return the value of the octal string immediately after the current\n * position. Return -1 for invalid, or 0-255 for valid. Smart enough to handle\n * numbers > 377 correctly (for example, 400 is treated as 40) and doesn't\n * treat 8 or 9 as recognised characters. Position is updated:\n *     blahblah\\%o210asdf\n *\t   before-^  ^-after\n */\nstatic int64_t getoctchrs(void)\n{\n  int64_t nr = 0;\n  int c;\n  int i;\n\n  for (i = 0; i < 3 && nr < 040; i++) {  // -V536\n    c = regparse[0];\n    if (c < '0' || c > '7')\n      break;\n    nr <<= 3;\n    nr |= hex2nr(c);\n    ++regparse;\n  }\n\n  if (i == 0)\n    return -1;\n  return nr;\n}\n\n/*\n * Get a number after a backslash that is inside [].\n * When nothing is recognized return a backslash.\n */\nstatic int coll_get_char(void)\n{\n  int64_t nr = -1;\n\n  switch (*regparse++) {\n  case 'd': nr = getdecchrs(); break;\n  case 'o': nr = getoctchrs(); break;\n  case 'x': nr = gethexchrs(2); break;\n  case 'u': nr = gethexchrs(4); break;\n  case 'U': nr = gethexchrs(8); break;\n  }\n  if (nr < 0 || nr > INT_MAX) {\n    // If getting the number fails be backwards compatible: the character\n    // is a backslash.\n    regparse--;\n    nr = '\\\\';\n  }\n  return nr;\n}\n\n/*\n * read_limits - Read two integers to be taken as a minimum and maximum.\n * If the first character is '-', then the range is reversed.\n * Should end with 'end'.  If minval is missing, zero is default, if maxval is\n * missing, a very big number is the default.\n */\nstatic int read_limits(long *minval, long *maxval)\n{\n  int reverse = false;\n  char_u      *first_char;\n  long tmp;\n\n  if (*regparse == '-') {\n    // Starts with '-', so reverse the range later.\n    regparse++;\n    reverse = true;\n  }\n  first_char = regparse;\n  *minval = getdigits_long(&regparse, false, 0);\n  if (*regparse == ',') {           // There is a comma.\n    if (ascii_isdigit(*++regparse)) {\n      *maxval = getdigits_long(&regparse, false, MAX_LIMIT);\n    } else {\n      *maxval = MAX_LIMIT;\n    }\n  } else if (ascii_isdigit(*first_char)) {\n    *maxval = *minval;              // It was \\{n} or \\{-n}\n  } else {\n    *maxval = MAX_LIMIT;            // It was \\{} or \\{-}\n  }\n  if (*regparse == '\\\\') {\n    regparse++;         // Allow either \\{...} or \\{...\\}\n  }\n  if (*regparse != '}') {\n    sprintf((char *)IObuff, _(\"E554: Syntax error in %s{...}\"),\n        reg_magic == MAGIC_ALL ? \"\" : \"\\\\\");\n    EMSG_RET_FAIL(IObuff);\n  }\n\n  /*\n   * Reverse the range if there was a '-', or make sure it is in the right\n   * order otherwise.\n   */\n  if ((!reverse && *minval > *maxval) || (reverse && *minval < *maxval)) {\n    tmp = *minval;\n    *minval = *maxval;\n    *maxval = tmp;\n  }\n  skipchr();            /* let's be friends with the lexer again */\n  return OK;\n}\n\n/*\n * vim_regexec and friends\n */\n\n/*\n * Global work variables for vim_regexec().\n */\n\n/* Save the sub-expressions before attempting a match. */\n#define save_se(savep, posp, pp) \\\n  REG_MULTI ? save_se_multi((savep), (posp)) : save_se_one((savep), (pp))\n\n/* After a failed match restore the sub-expressions. */\n#define restore_se(savep, posp, pp) { \\\n    if (REG_MULTI) \\\n      *(posp) = (savep)->se_u.pos; \\\n    else \\\n      *(pp) = (savep)->se_u.ptr; }\n\n\n#ifdef REGEXP_DEBUG\nint regnarrate = 0;\n#endif\n\n// Sometimes need to save a copy of a line.  Since alloc()/free() is very\n// slow, we keep one allocated piece of memory and only re-allocate it when\n// it's too small.  It's freed in bt_regexec_both() when finished.\nstatic char_u   *reg_tofree = NULL;\nstatic unsigned reg_tofreelen;\n\n// Structure used to store the execution state of the regex engine.\n// Which ones are set depends on whether a single-line or multi-line match is\n// done:\n//                      single-line             multi-line\n// reg_match            &regmatch_T             NULL\n// reg_mmatch           NULL                    &regmmatch_T\n// reg_startp           reg_match->startp       <invalid>\n// reg_endp             reg_match->endp         <invalid>\n// reg_startpos         <invalid>               reg_mmatch->startpos\n// reg_endpos           <invalid>               reg_mmatch->endpos\n// reg_win              NULL                    window in which to search\n// reg_buf              curbuf                  buffer in which to search\n// reg_firstlnum        <invalid>               first line in which to search\n// reg_maxline          0                       last line nr\n// reg_line_lbr         false or true           false\ntypedef struct {\n  regmatch_T *reg_match;\n  regmmatch_T *reg_mmatch;\n  char_u **reg_startp;\n  char_u **reg_endp;\n  lpos_T *reg_startpos;\n  lpos_T *reg_endpos;\n  win_T *reg_win;\n  buf_T *reg_buf;\n  linenr_T reg_firstlnum;\n  linenr_T reg_maxline;\n  bool reg_line_lbr;  // \"\\n\" in string is line break\n\n  // The current match-position is remembered with these variables:\n  linenr_T lnum;  ///< line number, relative to first line\n  char_u *line;   ///< start of current line\n  char_u *input;  ///< current input, points into \"regline\"\n\n  int need_clear_subexpr;   ///< subexpressions still need to be cleared\n  int need_clear_zsubexpr;  ///< extmatch subexpressions still need to be\n                            ///< cleared\n\n\n  // Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().\n  // Normally it gets the value of \"rm_ic\" or \"rmm_ic\", but when the pattern\n  // contains '\\c' or '\\C' the value is overruled.\n  bool reg_ic;\n\n  // Similar to \"reg_ic\", but only for 'combining' characters.  Set with \\Z\n  // flag in the regexp.  Defaults to false, always.\n  bool reg_icombine;\n\n  // Copy of \"rmm_maxcol\": maximum column to search for a match.  Zero when\n  // there is no maximum.\n  colnr_T reg_maxcol;\n\n  // State for the NFA engine regexec.\n  int nfa_has_zend;     ///< NFA regexp \\ze operator encountered.\n  int nfa_has_backref;  ///< NFA regexp \\1 .. \\9 encountered.\n  int nfa_nsubexpr;     ///< Number of sub expressions actually being used\n                        ///< during execution. 1 if only the whole match\n                        ///< (subexpr 0) is used.\n  // listid is global, so that it increases on recursive calls to\n  // nfa_regmatch(), which means we don't have to clear the lastlist field of\n  // all the states.\n  int nfa_listid;\n  int nfa_alt_listid;\n\n  int nfa_has_zsubexpr;  ///< NFA regexp has \\z( ), set zsubexpr.\n} regexec_T;\n\nstatic regexec_T rex;\nstatic bool rex_in_use = false;\n\n/*\n * \"regstack\" and \"backpos\" are used by regmatch().  They are kept over calls\n * to avoid invoking malloc() and free() often.\n * \"regstack\" is a stack with regitem_T items, sometimes preceded by regstar_T\n * or regbehind_T.\n * \"backpos_T\" is a table with backpos_T for BACK\n */\nstatic garray_T regstack = GA_EMPTY_INIT_VALUE;\nstatic garray_T backpos = GA_EMPTY_INIT_VALUE;\n\n/*\n * Both for regstack and backpos tables we use the following strategy of\n * allocation (to reduce malloc/free calls):\n * - Initial size is fairly small.\n * - When needed, the tables are grown bigger (8 times at first, double after\n *   that).\n * - After executing the match we free the memory only if the array has grown.\n *   Thus the memory is kept allocated when it's at the initial size.\n * This makes it fast while not keeping a lot of memory allocated.\n * A three times speed increase was observed when using many simple patterns.\n */\n#define REGSTACK_INITIAL        2048\n#define BACKPOS_INITIAL         64\n\n#if defined(EXITFREE)\nvoid free_regexp_stuff(void)\n{\n  ga_clear(&regstack);\n  ga_clear(&backpos);\n  xfree(reg_tofree);\n  xfree(reg_prev_sub);\n}\n\n#endif\n\n// Return true if character 'c' is included in 'iskeyword' option for\n// \"reg_buf\" buffer.\nstatic bool reg_iswordc(int c)\n{\n  return vim_iswordc_buf(c, rex.reg_buf);\n}\n\n/*\n * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\".\n */\nstatic char_u *reg_getline(linenr_T lnum)\n{\n  // when looking behind for a match/no-match lnum is negative.  But we\n  // can't go before line 1\n  if (rex.reg_firstlnum + lnum < 1) {\n    return NULL;\n  }\n  if (lnum > rex.reg_maxline) {\n    // Must have matched the \"\\n\" in the last line.\n    return (char_u *)\"\";\n  }\n  return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, false);\n}\n\nstatic regsave_T behind_pos;\n\nstatic char_u   *reg_startzp[NSUBEXP];  /* Workspace to mark beginning */\nstatic char_u   *reg_endzp[NSUBEXP];    /*   and end of \\z(...\\) matches */\nstatic lpos_T reg_startzpos[NSUBEXP];   /* idem, beginning pos */\nstatic lpos_T reg_endzpos[NSUBEXP];     /* idem, end pos */\n\n// true if using multi-line regexp.\n#define REG_MULTI       (rex.reg_match == NULL)\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n * Uses curbuf for line count and 'iskeyword'.\n * If \"line_lbr\" is true, consider a \"\\n\" in \"line\" to be a line break.\n *\n * Returns 0 for failure, number of lines contained in the match otherwise.\n */\nstatic int \nbt_regexec_nl (\n    regmatch_T *rmp,\n    char_u *line,      /* string to match against */\n    colnr_T col,       /* column to start looking for match */\n    bool line_lbr\n)\n{\n  rex.reg_match = rmp;\n  rex.reg_mmatch = NULL;\n  rex.reg_maxline = 0;\n  rex.reg_line_lbr = line_lbr;\n  rex.reg_buf = curbuf;\n  rex.reg_win = NULL;\n  rex.reg_ic = rmp->rm_ic;\n  rex.reg_icombine = false;\n  rex.reg_maxcol = 0;\n\n  long r = bt_regexec_both(line, col, NULL, NULL);\n  assert(r <= INT_MAX);\n  return (int)r;\n}\n\n/// Wrapper around strchr which accounts for case-insensitive searches and\n/// non-ASCII characters.\n///\n/// This function is used a lot for simple searches, keep it fast!\n///\n/// @param  s  string to search\n/// @param  c  character to find in @a s\n///\n/// @return  NULL if no match, otherwise pointer to the position in @a s\nstatic inline char_u *cstrchr(const char_u *const s, const int c)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n  FUNC_ATTR_ALWAYS_INLINE\n{\n  if (!rex.reg_ic) {\n    return vim_strchr(s, c);\n  }\n\n  // Use folded case for UTF-8, slow! For ASCII use libc strpbrk which is\n  // expected to be highly optimized.\n  if (c > 0x80) {\n    const int folded_c = utf_fold(c);\n    for (const char_u *p = s; *p != NUL; p += utfc_ptr2len(p)) {\n      if (utf_fold(utf_ptr2char(p)) == folded_c) {\n        return (char_u *)p;\n      }\n    }\n    return NULL;\n  }\n\n  int cc;\n  if (ASCII_ISUPPER(c)) {\n    cc = TOLOWER_ASC(c);\n  } else if (ASCII_ISLOWER(c)) {\n    cc = TOUPPER_ASC(c);\n  } else {\n    return vim_strchr(s, c);\n  }\n\n  char tofind[] = { (char)c, (char)cc, NUL };\n  return (char_u *)strpbrk((const char *)s, tofind);\n}\n\n/// Matches a regexp against multiple lines.\n/// \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n/// Uses curbuf for line count and 'iskeyword'.\n/// \n/// @param win Window in which to search or NULL\n/// @param buf Buffer in which to search\n/// @param lnum Number of line to start looking for match \n/// @param col Column to start looking for match\n/// @param tm Timeout limit or NULL\n///\n/// @return zero if there is no match and number of lines contained in the match\n///         otherwise.\nstatic long bt_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf,\n                             linenr_T lnum, colnr_T col,\n                             proftime_T *tm, int *timed_out)\n{\n  rex.reg_match = NULL;\n  rex.reg_mmatch = rmp;\n  rex.reg_buf = buf;\n  rex.reg_win = win;\n  rex.reg_firstlnum = lnum;\n  rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;\n  rex.reg_line_lbr = false;\n  rex.reg_ic = rmp->rmm_ic;\n  rex.reg_icombine = false;\n  rex.reg_maxcol = rmp->rmm_maxcol;\n\n  return bt_regexec_both(NULL, col, tm, timed_out);\n}\n\n/// Match a regexp against a string (\"line\" points to the string) or multiple\n/// lines (if \"line\" is NULL, use reg_getline()).\n/// @return 0 for failure, or number of lines contained in the match.\nstatic long bt_regexec_both(char_u *line,\n                            colnr_T col,      // column to start search\n                            proftime_T *tm,   // timeout limit or NULL\n                            int *timed_out)   // flag set on timeout or NULL\n{\n  bt_regprog_T        *prog;\n  char_u      *s;\n  long retval = 0L;\n\n  /* Create \"regstack\" and \"backpos\" if they are not allocated yet.\n   * We allocate *_INITIAL amount of bytes first and then set the grow size\n   * to much bigger value to avoid many malloc calls in case of deep regular\n   * expressions.  */\n  if (regstack.ga_data == NULL) {\n    /* Use an item size of 1 byte, since we push different things\n     * onto the regstack. */\n    ga_init(&regstack, 1, REGSTACK_INITIAL);\n    ga_grow(&regstack, REGSTACK_INITIAL);\n    ga_set_growsize(&regstack, REGSTACK_INITIAL * 8);\n  }\n\n  if (backpos.ga_data == NULL) {\n    ga_init(&backpos, sizeof(backpos_T), BACKPOS_INITIAL);\n    ga_grow(&backpos, BACKPOS_INITIAL);\n    ga_set_growsize(&backpos, BACKPOS_INITIAL * 8);\n  }\n\n  if (REG_MULTI) {\n    prog = (bt_regprog_T *)rex.reg_mmatch->regprog;\n    line = reg_getline((linenr_T)0);\n    rex.reg_startpos = rex.reg_mmatch->startpos;\n    rex.reg_endpos = rex.reg_mmatch->endpos;\n  } else {\n    prog = (bt_regprog_T *)rex.reg_match->regprog;\n    rex.reg_startp = rex.reg_match->startp;\n    rex.reg_endp = rex.reg_match->endp;\n  }\n\n  /* Be paranoid... */\n  if (prog == NULL || line == NULL) {\n    IEMSG(_(e_null));\n    goto theend;\n  }\n\n  /* Check validity of program. */\n  if (prog_magic_wrong())\n    goto theend;\n\n  // If the start column is past the maximum column: no need to try.\n  if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol) {\n    goto theend;\n  }\n\n  // If pattern contains \"\\c\" or \"\\C\": overrule value of rex.reg_ic\n  if (prog->regflags & RF_ICASE) {\n    rex.reg_ic = true;\n  } else if (prog->regflags & RF_NOICASE) {\n    rex.reg_ic = false;\n  }\n\n  // If pattern contains \"\\Z\" overrule value of rex.reg_icombine\n  if (prog->regflags & RF_ICOMBINE) {\n    rex.reg_icombine = true;\n  }\n\n  /* If there is a \"must appear\" string, look for it. */\n  if (prog->regmust != NULL) {\n    int c = utf_ptr2char(prog->regmust);\n    s = line + col;\n\n    // This is used very often, esp. for \":global\".  Use two versions of\n    // the loop to avoid overhead of conditions.\n    if (!rex.reg_ic) {\n      while ((s = vim_strchr(s, c)) != NULL) {\n        if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0) {\n          break;  // Found it.\n        }\n        MB_PTR_ADV(s);\n      }\n    } else {\n      while ((s = cstrchr(s, c)) != NULL) {\n        if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0) {\n          break;  // Found it.\n        }\n        MB_PTR_ADV(s);\n      }\n    }\n    if (s == NULL) {  // Not present.\n      goto theend;\n    }\n  }\n\n  rex.line = line;\n  rex.lnum = 0;\n  reg_toolong = false;\n\n  /* Simplest case: Anchored match need be tried only once. */\n  if (prog->reganch) {\n    int c = utf_ptr2char(rex.line + col);\n    if (prog->regstart == NUL\n        || prog->regstart == c\n        || (rex.reg_ic\n            && (utf_fold(prog->regstart) == utf_fold(c)\n                || (c < 255 && prog->regstart < 255\n                    && mb_tolower(prog->regstart) == mb_tolower(c))))) {\n      retval = regtry(prog, col, tm, timed_out);\n    } else {\n      retval = 0;\n    }\n  } else {\n    int tm_count = 0;\n    /* Messy cases:  unanchored match. */\n    while (!got_int) {\n      if (prog->regstart != NUL) {\n        // Skip until the char we know it must start with.\n        s = cstrchr(rex.line + col, prog->regstart);\n        if (s == NULL) {\n          retval = 0;\n          break;\n        }\n        col = (int)(s - rex.line);\n      }\n\n      // Check for maximum column to try.\n      if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol) {\n        retval = 0;\n        break;\n      }\n\n      retval = regtry(prog, col, tm, timed_out);\n      if (retval > 0) {\n        break;\n      }\n\n      // if not currently on the first line, get it again\n      if (rex.lnum != 0) {\n        rex.lnum = 0;\n        rex.line = reg_getline((linenr_T)0);\n      }\n      if (rex.line[col] == NUL) {\n        break;\n      }\n      col += (*mb_ptr2len)(rex.line + col);\n      // Check for timeout once in a twenty times to avoid overhead.\n      if (tm != NULL && ++tm_count == 20) {\n        tm_count = 0;\n        if (profile_passed_limit(*tm)) {\n          if (timed_out != NULL) {\n            *timed_out = true;\n          }\n          break;\n        }\n      }\n    }\n  }\n\ntheend:\n  /* Free \"reg_tofree\" when it's a bit big.\n   * Free regstack and backpos if they are bigger than their initial size. */\n  if (reg_tofreelen > 400) {\n    XFREE_CLEAR(reg_tofree);\n  }\n  if (regstack.ga_maxlen > REGSTACK_INITIAL)\n    ga_clear(&regstack);\n  if (backpos.ga_maxlen > BACKPOS_INITIAL)\n    ga_clear(&backpos);\n\n  if (retval > 0) {\n    // Make sure the end is never before the start.  Can happen when \\zs\n    // and \\ze are used.\n    if (REG_MULTI) {\n      const lpos_T *const start = &rex.reg_mmatch->startpos[0];\n      const lpos_T *const end = &rex.reg_mmatch->endpos[0];\n\n      if (end->lnum < start->lnum\n          || (end->lnum == start->lnum && end->col < start->col)) {\n        rex.reg_mmatch->endpos[0] = rex.reg_mmatch->startpos[0];\n      }\n    } else {\n      if (rex.reg_match->endp[0] < rex.reg_match->startp[0]) {\n        rex.reg_match->endp[0] = rex.reg_match->startp[0];\n      }\n    }\n  }\n\n  return retval;\n}\n\n\n/*\n * Create a new extmatch and mark it as referenced once.\n */\nstatic reg_extmatch_T *make_extmatch(void)\n  FUNC_ATTR_NONNULL_RET\n{\n  reg_extmatch_T *em = xcalloc(1, sizeof(reg_extmatch_T));\n  em->refcnt = 1;\n  return em;\n}\n\n/*\n * Add a reference to an extmatch.\n */\nreg_extmatch_T *ref_extmatch(reg_extmatch_T *em)\n{\n  if (em != NULL)\n    em->refcnt++;\n  return em;\n}\n\n/*\n * Remove a reference to an extmatch.  If there are no references left, free\n * the info.\n */\nvoid unref_extmatch(reg_extmatch_T *em)\n{\n  int i;\n\n  if (em != NULL && --em->refcnt <= 0) {\n    for (i = 0; i < NSUBEXP; ++i)\n      xfree(em->matches[i]);\n    xfree(em);\n  }\n}\n\n/// Try match of \"prog\" with at rex.line[\"col\"].\n/// @returns 0 for failure, or number of lines contained in the match.\nstatic long regtry(bt_regprog_T *prog,\n                   colnr_T col,\n                   proftime_T *tm,    // timeout limit or NULL\n                   int *timed_out)    // flag set on timeout or NULL\n{\n  rex.input = rex.line + col;\n  rex.need_clear_subexpr = true;\n  // Clear the external match subpointers if necessaey.\n  rex.need_clear_zsubexpr = (prog->reghasz == REX_SET);\n\n  if (regmatch(prog->program + 1, tm, timed_out) == 0) {\n    return 0;\n  }\n\n  cleanup_subexpr();\n  if (REG_MULTI) {\n    if (rex.reg_startpos[0].lnum < 0) {\n      rex.reg_startpos[0].lnum = 0;\n      rex.reg_startpos[0].col = col;\n    }\n    if (rex.reg_endpos[0].lnum < 0) {\n      rex.reg_endpos[0].lnum = rex.lnum;\n      rex.reg_endpos[0].col = (int)(rex.input - rex.line);\n    } else {\n      // Use line number of \"\\ze\".\n      rex.lnum = rex.reg_endpos[0].lnum;\n    }\n  } else {\n    if (rex.reg_startp[0] == NULL) {\n      rex.reg_startp[0] = rex.line + col;\n    }\n    if (rex.reg_endp[0] == NULL) {\n      rex.reg_endp[0] = rex.input;\n    }\n  }\n  /* Package any found \\z(...\\) matches for export. Default is none. */\n  unref_extmatch(re_extmatch_out);\n  re_extmatch_out = NULL;\n\n  if (prog->reghasz == REX_SET) {\n    int i;\n\n    cleanup_zsubexpr();\n    re_extmatch_out = make_extmatch();\n    for (i = 0; i < NSUBEXP; i++) {\n      if (REG_MULTI) {\n        /* Only accept single line matches. */\n        if (reg_startzpos[i].lnum >= 0\n            && reg_endzpos[i].lnum == reg_startzpos[i].lnum\n            && reg_endzpos[i].col >= reg_startzpos[i].col) {\n          re_extmatch_out->matches[i] =\n            vim_strnsave(reg_getline(reg_startzpos[i].lnum)\n                         + reg_startzpos[i].col,\n                         reg_endzpos[i].col\n                         - reg_startzpos[i].col);\n        }\n      } else {\n        if (reg_startzp[i] != NULL && reg_endzp[i] != NULL)\n          re_extmatch_out->matches[i] =\n            vim_strnsave(reg_startzp[i], reg_endzp[i] - reg_startzp[i]);\n      }\n    }\n  }\n  return 1 + rex.lnum;\n}\n\n\n// Get class of previous character.\nstatic int reg_prev_class(void)\n{\n  if (rex.input > rex.line) {\n    return mb_get_class_tab(\n        rex.input - 1 - utf_head_off(rex.line, rex.input - 1),\n        rex.reg_buf->b_chartab);\n  }\n  return -1;\n}\n\n\n// Return true if the current rex.input position matches the Visual area.\nstatic bool reg_match_visual(void)\n{\n  pos_T top, bot;\n  linenr_T lnum;\n  colnr_T col;\n  win_T *wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n  int mode;\n  colnr_T start, end;\n  colnr_T start2, end2;\n  colnr_T curswant;\n\n  // Check if the buffer is the current buffer.\n  if (rex.reg_buf != curbuf || VIsual.lnum == 0) {\n    return false;\n  }\n\n  if (VIsual_active) {\n    if (lt(VIsual, wp->w_cursor)) {\n      top = VIsual;\n      bot = wp->w_cursor;\n    } else {\n      top = wp->w_cursor;\n      bot = VIsual;\n    }\n    mode = VIsual_mode;\n    curswant = wp->w_curswant;\n  } else {\n    if (lt(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end)) {\n      top = curbuf->b_visual.vi_start;\n      bot = curbuf->b_visual.vi_end;\n    } else {\n      top = curbuf->b_visual.vi_end;\n      bot = curbuf->b_visual.vi_start;\n    }\n    mode = curbuf->b_visual.vi_mode;\n    curswant = curbuf->b_visual.vi_curswant;\n  }\n  lnum = rex.lnum + rex.reg_firstlnum;\n  if (lnum < top.lnum || lnum > bot.lnum) {\n    return false;\n  }\n\n  if (mode == 'v') {\n    col = (colnr_T)(rex.input - rex.line);\n    if ((lnum == top.lnum && col < top.col)\n        || (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e'))) {\n      return false;\n    }\n  } else if (mode == Ctrl_V) {\n    getvvcol(wp, &top, &start, NULL, &end);\n    getvvcol(wp, &bot, &start2, NULL, &end2);\n    if (start2 < start)\n      start = start2;\n    if (end2 > end)\n      end = end2;\n    if (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL) {\n      end = MAXCOL;\n    }\n    unsigned int cols_u = win_linetabsize(wp, rex.line,\n                                          (colnr_T)(rex.input - rex.line));\n    assert(cols_u <= MAXCOL);\n    colnr_T cols = (colnr_T)cols_u;\n    if (cols < start || cols > end - (*p_sel == 'e')) {\n      return false;\n    }\n  }\n  return true;\n}\n\n#define ADVANCE_REGINPUT() MB_PTR_ADV(rex.input)\n\n/*\n * The arguments from BRACE_LIMITS are stored here.  They are actually local\n * to regmatch(), but they are here to reduce the amount of stack space used\n * (it can be called recursively many times).\n */\nstatic long bl_minval;\nstatic long bl_maxval;\n\n/// Main matching routine\n///\n/// Conceptually the strategy is simple: Check to see whether the current node\n/// matches, push an item onto the regstack and loop to see whether the rest\n/// matches, and then act accordingly.  In practice we make some effort to\n/// avoid using the regstack, in particular by going through \"ordinary\" nodes\n/// (that don't need to know whether the rest of the match failed) by a nested\n/// loop.\n///\n/// Returns true when there is a match.  Leaves rex.input and rex.lnum\n/// just after the last matched character.\n/// Returns false when there is no match.  Leaves rex.input and rex.lnum in an\n/// undefined state!\nstatic bool regmatch(\n    char_u *scan,               // Current node.\n    proftime_T *tm,             // timeout limit or NULL\n    int *timed_out              // flag set on timeout or NULL\n)\n{\n  char_u        *next;          /* Next node. */\n  int op;\n  int c;\n  regitem_T     *rp;\n  int no;\n  int status;                   // one of the RA_ values:\n  int tm_count = 0;\n#define RA_FAIL         1       // something failed, abort\n#define RA_CONT         2       // continue in inner loop\n#define RA_BREAK        3       // break inner loop\n#define RA_MATCH        4       // successful match\n#define RA_NOMATCH      5       // didn't match\n\n  // Make \"regstack\" and \"backpos\" empty.  They are allocated and freed in\n  // bt_regexec_both() to reduce malloc()/free() calls.\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n\n  /*\n   * Repeat until \"regstack\" is empty.\n   */\n  for (;; ) {\n    /* Some patterns may take a long time to match, e.g., \"\\([a-z]\\+\\)\\+Q\".\n     * Allow interrupting them with CTRL-C. */\n    fast_breakcheck();\n\n#ifdef REGEXP_DEBUG\n    if (scan != NULL && regnarrate) {\n      mch_errmsg((char *)regprop(scan));\n      mch_errmsg(\"(\\n\");\n    }\n#endif\n\n    /*\n     * Repeat for items that can be matched sequentially, without using the\n     * regstack.\n     */\n    for (;; ) {\n      if (got_int || scan == NULL) {\n        status = RA_FAIL;\n        break;\n      }\n      // Check for timeout once in a 100 times to avoid overhead.\n      if (tm != NULL && ++tm_count == 100) {\n        tm_count = 0;\n        if (profile_passed_limit(*tm)) {\n          if (timed_out != NULL) {\n            *timed_out = true;\n          }\n          status = RA_FAIL;\n          break;\n        }\n      }\n      status = RA_CONT;\n\n#ifdef REGEXP_DEBUG\n      if (regnarrate) {\n        mch_errmsg((char *)regprop(scan));\n        mch_errmsg(\"...\\n\");\n        if (re_extmatch_in != NULL) {\n          int i;\n\n          mch_errmsg(_(\"External submatches:\\n\"));\n          for (i = 0; i < NSUBEXP; i++) {\n            mch_errmsg(\"    \\\"\");\n            if (re_extmatch_in->matches[i] != NULL)\n              mch_errmsg((char *)re_extmatch_in->matches[i]);\n            mch_errmsg(\"\\\"\\n\");\n          }\n        }\n      }\n#endif\n      next = regnext(scan);\n\n      op = OP(scan);\n      // Check for character class with NL added.\n      if (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n          && *rex.input == NUL && rex.lnum <= rex.reg_maxline) {\n        reg_nextline();\n      } else if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n') {\n        ADVANCE_REGINPUT();\n      } else {\n        if (WITH_NL(op)) {\n          op -= ADD_NL;\n        }\n        c = utf_ptr2char(rex.input);\n        switch (op) {\n        case BOL:\n          if (rex.input != rex.line) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case EOL:\n          if (c != NUL) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case RE_BOF:\n          // We're not at the beginning of the file when below the first\n          // line where we started, not at the start of the line or we\n          // didn't start at the first line of the buffer.\n          if (rex.lnum != 0 || rex.input != rex.line\n              || (REG_MULTI && rex.reg_firstlnum > 1)) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case RE_EOF:\n          if (rex.lnum != rex.reg_maxline || c != NUL) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case CURSOR:\n          // Check if the buffer is in a window and compare the\n          // rex.reg_win->w_cursor position to the match position.\n          if (rex.reg_win == NULL\n              || (rex.lnum + rex.reg_firstlnum != rex.reg_win->w_cursor.lnum)\n              || ((colnr_T)(rex.input - rex.line) !=\n                  rex.reg_win->w_cursor.col)) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case RE_MARK:\n          /* Compare the mark position to the match position. */\n        {\n          int mark = OPERAND(scan)[0];\n          int cmp = OPERAND(scan)[1];\n          pos_T   *pos;\n\n          pos = getmark_buf(rex.reg_buf, mark, false);\n          if (pos == NULL                    // mark doesn't exist\n              || pos->lnum <= 0) {           // mark isn't set in reg_buf\n            status = RA_NOMATCH;\n          } else {\n            const colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n              && pos->col == MAXCOL\n              ? (colnr_T)STRLEN(reg_getline(pos->lnum - rex.reg_firstlnum))\n              : pos->col;\n\n            if (pos->lnum == rex.lnum + rex.reg_firstlnum\n                ? (pos_col == (colnr_T)(rex.input - rex.line)\n                   ? (cmp == '<' || cmp == '>')\n                   : (pos_col < (colnr_T)(rex.input - rex.line)\n                      ? cmp != '>'\n                      : cmp != '<'))\n                : (pos->lnum < rex.lnum + rex.reg_firstlnum\n                   ? cmp != '>'\n                   : cmp != '<')) {\n              status = RA_NOMATCH;\n            }\n          }\n        }\n        break;\n\n        case RE_VISUAL:\n          if (!reg_match_visual())\n            status = RA_NOMATCH;\n          break;\n\n        case RE_LNUM:\n          assert(rex.lnum + rex.reg_firstlnum >= 0\n                 && (uintmax_t)(rex.lnum + rex.reg_firstlnum) <= UINT32_MAX);\n          if (!REG_MULTI\n              || !re_num_cmp((uint32_t)(rex.lnum + rex.reg_firstlnum), scan)) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case RE_COL:\n          assert(rex.input - rex.line + 1 >= 0\n                 && (uintmax_t)(rex.input - rex.line + 1) <= UINT32_MAX);\n          if (!re_num_cmp((uint32_t)(rex.input - rex.line + 1), scan)) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case RE_VCOL:\n          if (!re_num_cmp(win_linetabsize(rex.reg_win == NULL\n                                          ? curwin : rex.reg_win,\n                                          rex.line,\n                                          (colnr_T)(rex.input - rex.line)) + 1,\n                          scan)) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case BOW:  // \\<word; rex.input points to w\n          if (c == NUL) {  // Can't match at end of line\n            status = RA_NOMATCH;\n          } else {\n            // Get class of current and previous char (if it exists).\n            const int this_class =\n              mb_get_class_tab(rex.input, rex.reg_buf->b_chartab);\n            if (this_class <= 1) {\n              status = RA_NOMATCH;  // Not on a word at all.\n            } else if (reg_prev_class() == this_class) {\n              status = RA_NOMATCH;  // Previous char is in same word.\n            }\n          }\n          break;\n\n        case EOW:  // word\\>; rex.input points after d\n          if (rex.input == rex.line) {  // Can't match at start of line\n            status = RA_NOMATCH;\n          } else {\n            int this_class, prev_class;\n\n            // Get class of current and previous char (if it exists).\n            this_class = mb_get_class_tab(rex.input, rex.reg_buf->b_chartab);\n            prev_class = reg_prev_class();\n            if (this_class == prev_class\n                || prev_class == 0 || prev_class == 1) {\n              status = RA_NOMATCH;\n            }\n          }\n          break;  // Matched with EOW\n\n        case ANY:\n          // ANY does not match new lines.\n          if (c == NUL) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case IDENT:\n          if (!vim_isIDc(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case SIDENT:\n          if (ascii_isdigit(*rex.input) || !vim_isIDc(c)) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case KWORD:\n          if (!vim_iswordp_buf(rex.input, rex.reg_buf)) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case SKWORD:\n          if (ascii_isdigit(*rex.input)\n              || !vim_iswordp_buf(rex.input, rex.reg_buf)) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case FNAME:\n          if (!vim_isfilec(c)) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case SFNAME:\n          if (ascii_isdigit(*rex.input) || !vim_isfilec(c)) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case PRINT:\n          if (!vim_isprintc(PTR2CHAR(rex.input))) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case SPRINT:\n          if (ascii_isdigit(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input))) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case WHITE:\n          if (!ascii_iswhite(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NWHITE:\n          if (c == NUL || ascii_iswhite(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case DIGIT:\n          if (!ri_digit(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NDIGIT:\n          if (c == NUL || ri_digit(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case HEX:\n          if (!ri_hex(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NHEX:\n          if (c == NUL || ri_hex(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case OCTAL:\n          if (!ri_octal(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NOCTAL:\n          if (c == NUL || ri_octal(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case WORD:\n          if (!ri_word(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NWORD:\n          if (c == NUL || ri_word(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case HEAD:\n          if (!ri_head(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NHEAD:\n          if (c == NUL || ri_head(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case ALPHA:\n          if (!ri_alpha(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NALPHA:\n          if (c == NUL || ri_alpha(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case LOWER:\n          if (!ri_lower(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NLOWER:\n          if (c == NUL || ri_lower(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case UPPER:\n          if (!ri_upper(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NUPPER:\n          if (c == NUL || ri_upper(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case EXACTLY:\n        {\n          int len;\n          char_u  *opnd;\n\n          opnd = OPERAND(scan);\n          // Inline the first byte, for speed.\n          if (*opnd != *rex.input\n              && (!rex.reg_ic)) {\n            status = RA_NOMATCH;\n          } else if (*opnd == NUL) {\n            // match empty string always works; happens when \"~\" is\n            // empty.\n          } else {\n            if (opnd[1] == NUL && !rex.reg_ic) {\n              len = 1;  // matched a single byte above\n            } else {\n              // Need to match first byte again for multi-byte.\n              len = (int)STRLEN(opnd);\n              if (cstrncmp(opnd, rex.input, &len) != 0) {\n                status = RA_NOMATCH;\n              }\n            }\n            // Check for following composing character, unless %C\n            // follows (skips over all composing chars).\n            if (status != RA_NOMATCH\n                && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n                && !rex.reg_icombine\n                && OP(next) != RE_COMPOSING) {\n              // raaron: This code makes a composing character get\n              // ignored, which is the correct behavior (sometimes)\n              // for voweled Hebrew texts.\n              status = RA_NOMATCH;\n            }\n            if (status != RA_NOMATCH) {\n              rex.input += len;\n            }\n          }\n        }\n        break;\n\n        case ANYOF:\n        case ANYBUT:\n          if (c == NUL)\n            status = RA_NOMATCH;\n          else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case MULTIBYTECODE:\n          {\n            int i, len;\n\n            const char_u *opnd = OPERAND(scan);\n            // Safety check (just in case 'encoding' was changed since\n            // compiling the program).\n            if ((len = (*mb_ptr2len)(opnd)) < 2) {\n              status = RA_NOMATCH;\n              break;\n            }\n            const int opndc = utf_ptr2char(opnd);\n            if (utf_iscomposing(opndc)) {\n              // When only a composing char is given match at any\n              // position where that composing char appears.\n              status = RA_NOMATCH;\n              for (i = 0; rex.input[i] != NUL;\n                   i += utf_ptr2len(rex.input + i)) {\n                const int inpc = utf_ptr2char(rex.input + i);\n                if (!utf_iscomposing(inpc)) {\n                  if (i > 0) {\n                    break;\n                  }\n                } else if (opndc == inpc) {\n                  // Include all following composing chars.\n                  len = i + utfc_ptr2len(rex.input + i);\n                  status = RA_MATCH;\n                  break;\n                }\n              }\n            } else {\n              for (i = 0; i < len; i++) {\n                if (opnd[i] != rex.input[i]) {\n                  status = RA_NOMATCH;\n                  break;\n                }\n              }\n            }\n            rex.input += len;\n          }\n          break;\n\n        case RE_COMPOSING:\n          {\n            // Skip composing characters.\n            while (utf_iscomposing(utf_ptr2char(rex.input))) {\n              MB_CPTR_ADV(rex.input);\n            }\n          }\n          break;\n\n        case NOTHING:\n          break;\n\n        case BACK:\n        {\n          int i;\n\n          /*\n           * When we run into BACK we need to check if we don't keep\n           * looping without matching any input.  The second and later\n           * times a BACK is encountered it fails if the input is still\n           * at the same position as the previous time.\n           * The positions are stored in \"backpos\" and found by the\n           * current value of \"scan\", the position in the RE program.\n           */\n          backpos_T *bp = (backpos_T *)backpos.ga_data;\n          for (i = 0; i < backpos.ga_len; ++i)\n            if (bp[i].bp_scan == scan)\n              break;\n          if (i == backpos.ga_len) {\n            backpos_T *p = GA_APPEND_VIA_PTR(backpos_T, &backpos);\n            p->bp_scan = scan;\n          } else if (reg_save_equal(&bp[i].bp_pos))\n            /* Still at same position as last time, fail. */\n            status = RA_NOMATCH;\n\n          assert(status != RA_FAIL);\n          if (status != RA_NOMATCH) {\n            reg_save(&bp[i].bp_pos, &backpos);\n          }\n        }\n        break;\n\n        case MOPEN + 0:     /* Match start: \\zs */\n        case MOPEN + 1:     /* \\( */\n        case MOPEN + 2:\n        case MOPEN + 3:\n        case MOPEN + 4:\n        case MOPEN + 5:\n        case MOPEN + 6:\n        case MOPEN + 7:\n        case MOPEN + 8:\n        case MOPEN + 9:\n        {\n          no = op - MOPEN;\n          cleanup_subexpr();\n          rp = regstack_push(RS_MOPEN, scan);\n          if (rp == NULL)\n            status = RA_FAIL;\n          else {\n            rp->rs_no = no;\n            save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n                    &rex.reg_startp[no]);\n            // We simply continue and handle the result when done.\n          }\n        }\n        break;\n\n        case NOPEN:         /* \\%( */\n        case NCLOSE:        /* \\) after \\%( */\n          if (regstack_push(RS_NOPEN, scan) == NULL)\n            status = RA_FAIL;\n          /* We simply continue and handle the result when done. */\n          break;\n\n        case ZOPEN + 1:\n        case ZOPEN + 2:\n        case ZOPEN + 3:\n        case ZOPEN + 4:\n        case ZOPEN + 5:\n        case ZOPEN + 6:\n        case ZOPEN + 7:\n        case ZOPEN + 8:\n        case ZOPEN + 9:\n        {\n          no = op - ZOPEN;\n          cleanup_zsubexpr();\n          rp = regstack_push(RS_ZOPEN, scan);\n          if (rp == NULL)\n            status = RA_FAIL;\n          else {\n            rp->rs_no = no;\n            save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n                &reg_startzp[no]);\n            /* We simply continue and handle the result when done. */\n          }\n        }\n        break;\n\n        case MCLOSE + 0:    /* Match end: \\ze */\n        case MCLOSE + 1:    /* \\) */\n        case MCLOSE + 2:\n        case MCLOSE + 3:\n        case MCLOSE + 4:\n        case MCLOSE + 5:\n        case MCLOSE + 6:\n        case MCLOSE + 7:\n        case MCLOSE + 8:\n        case MCLOSE + 9:\n        {\n          no = op - MCLOSE;\n          cleanup_subexpr();\n          rp = regstack_push(RS_MCLOSE, scan);\n          if (rp == NULL) {\n            status = RA_FAIL;\n          } else {\n            rp->rs_no = no;\n            save_se(&rp->rs_un.sesave, &rex.reg_endpos[no], &rex.reg_endp[no]);\n            // We simply continue and handle the result when done.\n          }\n        }\n        break;\n\n        case ZCLOSE + 1:    /* \\) after \\z( */\n        case ZCLOSE + 2:\n        case ZCLOSE + 3:\n        case ZCLOSE + 4:\n        case ZCLOSE + 5:\n        case ZCLOSE + 6:\n        case ZCLOSE + 7:\n        case ZCLOSE + 8:\n        case ZCLOSE + 9:\n        {\n          no = op - ZCLOSE;\n          cleanup_zsubexpr();\n          rp = regstack_push(RS_ZCLOSE, scan);\n          if (rp == NULL)\n            status = RA_FAIL;\n          else {\n            rp->rs_no = no;\n            save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n                &reg_endzp[no]);\n            /* We simply continue and handle the result when done. */\n          }\n        }\n        break;\n\n        case BACKREF + 1:\n        case BACKREF + 2:\n        case BACKREF + 3:\n        case BACKREF + 4:\n        case BACKREF + 5:\n        case BACKREF + 6:\n        case BACKREF + 7:\n        case BACKREF + 8:\n        case BACKREF + 9:\n        {\n          int len;\n\n          no = op - BACKREF;\n          cleanup_subexpr();\n          if (!REG_MULTI) {  // Single-line regexp\n            if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL) {\n              // Backref was not set: Match an empty string.\n              len = 0;\n            } else {\n              // Compare current input with back-ref in the same line.\n              len = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n              if (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0) {\n                status = RA_NOMATCH;\n              }\n            }\n          } else {  // Multi-line regexp\n            if (rex.reg_startpos[no].lnum < 0 || rex.reg_endpos[no].lnum < 0) {\n              // Backref was not set: Match an empty string.\n              len = 0;\n            } else {\n              if (rex.reg_startpos[no].lnum == rex.lnum\n                  && rex.reg_endpos[no].lnum == rex.lnum) {\n                // Compare back-ref within the current line.\n                len = rex.reg_endpos[no].col - rex.reg_startpos[no].col;\n                if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n                             rex.input, &len) != 0) {\n                  status = RA_NOMATCH;\n                }\n              } else {\n                // Messy situation: Need to compare between two lines.\n                int r = match_with_backref(rex.reg_startpos[no].lnum,\n                                           rex.reg_startpos[no].col,\n                                           rex.reg_endpos[no].lnum,\n                                           rex.reg_endpos[no].col,\n                                           &len);\n                if (r != RA_MATCH) {\n                  status = r;\n                }\n              }\n            }\n          }\n\n          // Matched the backref, skip over it.\n          rex.input += len;\n        }\n        break;\n\n        case ZREF + 1:\n        case ZREF + 2:\n        case ZREF + 3:\n        case ZREF + 4:\n        case ZREF + 5:\n        case ZREF + 6:\n        case ZREF + 7:\n        case ZREF + 8:\n        case ZREF + 9:\n        {\n          cleanup_zsubexpr();\n          no = op - ZREF;\n          if (re_extmatch_in != NULL\n              && re_extmatch_in->matches[no] != NULL) {\n            int len = (int)STRLEN(re_extmatch_in->matches[no]);\n            if (cstrncmp(re_extmatch_in->matches[no], rex.input, &len) != 0) {\n              status = RA_NOMATCH;\n            } else {\n              rex.input += len;\n            }\n          } else {\n            // Backref was not set: Match an empty string.\n          }\n        }\n        break;\n\n        case BRANCH:\n        {\n          if (OP(next) != BRANCH)       /* No choice. */\n            next = OPERAND(scan);               /* Avoid recursion. */\n          else {\n            rp = regstack_push(RS_BRANCH, scan);\n            if (rp == NULL)\n              status = RA_FAIL;\n            else\n              status = RA_BREAK;                /* rest is below */\n          }\n        }\n        break;\n\n        case BRACE_LIMITS:\n        {\n          if (OP(next) == BRACE_SIMPLE) {\n            bl_minval = OPERAND_MIN(scan);\n            bl_maxval = OPERAND_MAX(scan);\n          } else if (OP(next) >= BRACE_COMPLEX\n                     && OP(next) < BRACE_COMPLEX + 10) {\n            no = OP(next) - BRACE_COMPLEX;\n            brace_min[no] = OPERAND_MIN(scan);\n            brace_max[no] = OPERAND_MAX(scan);\n            brace_count[no] = 0;\n          } else {\n            internal_error(\"BRACE_LIMITS\");\n            status = RA_FAIL;\n          }\n        }\n        break;\n\n        case BRACE_COMPLEX + 0:\n        case BRACE_COMPLEX + 1:\n        case BRACE_COMPLEX + 2:\n        case BRACE_COMPLEX + 3:\n        case BRACE_COMPLEX + 4:\n        case BRACE_COMPLEX + 5:\n        case BRACE_COMPLEX + 6:\n        case BRACE_COMPLEX + 7:\n        case BRACE_COMPLEX + 8:\n        case BRACE_COMPLEX + 9:\n        {\n          no = op - BRACE_COMPLEX;\n          ++brace_count[no];\n\n          /* If not matched enough times yet, try one more */\n          if (brace_count[no] <= (brace_min[no] <= brace_max[no]\n                                  ? brace_min[no] : brace_max[no])) {\n            rp = regstack_push(RS_BRCPLX_MORE, scan);\n            if (rp == NULL)\n              status = RA_FAIL;\n            else {\n              rp->rs_no = no;\n              reg_save(&rp->rs_un.regsave, &backpos);\n              next = OPERAND(scan);\n              /* We continue and handle the result when done. */\n            }\n            break;\n          }\n\n          /* If matched enough times, may try matching some more */\n          if (brace_min[no] <= brace_max[no]) {\n            /* Range is the normal way around, use longest match */\n            if (brace_count[no] <= brace_max[no]) {\n              rp = regstack_push(RS_BRCPLX_LONG, scan);\n              if (rp == NULL)\n                status = RA_FAIL;\n              else {\n                rp->rs_no = no;\n                reg_save(&rp->rs_un.regsave, &backpos);\n                next = OPERAND(scan);\n                /* We continue and handle the result when done. */\n              }\n            }\n          } else {\n            /* Range is backwards, use shortest match first */\n            if (brace_count[no] <= brace_min[no]) {\n              rp = regstack_push(RS_BRCPLX_SHORT, scan);\n              if (rp == NULL)\n                status = RA_FAIL;\n              else {\n                reg_save(&rp->rs_un.regsave, &backpos);\n                /* We continue and handle the result when done. */\n              }\n            }\n          }\n        }\n        break;\n\n        case BRACE_SIMPLE:\n        case STAR:\n        case PLUS:\n        {\n          regstar_T rst;\n\n          /*\n           * Lookahead to avoid useless match attempts when we know\n           * what character comes next.\n           */\n          if (OP(next) == EXACTLY) {\n            rst.nextb = *OPERAND(next);\n            if (rex.reg_ic) {\n              if (mb_isupper(rst.nextb)) {\n                rst.nextb_ic = mb_tolower(rst.nextb);\n              } else {\n                rst.nextb_ic = mb_toupper(rst.nextb);\n              }\n            } else {\n              rst.nextb_ic = rst.nextb;\n            }\n          } else {\n            rst.nextb = NUL;\n            rst.nextb_ic = NUL;\n          }\n          if (op != BRACE_SIMPLE) {\n            rst.minval = (op == STAR) ? 0 : 1;\n            rst.maxval = MAX_LIMIT;\n          } else {\n            rst.minval = bl_minval;\n            rst.maxval = bl_maxval;\n          }\n\n          /*\n           * When maxval > minval, try matching as much as possible, up\n           * to maxval.  When maxval < minval, try matching at least the\n           * minimal number (since the range is backwards, that's also\n           * maxval!).\n           */\n          rst.count = regrepeat(OPERAND(scan), rst.maxval);\n          if (got_int) {\n            status = RA_FAIL;\n            break;\n          }\n          if (rst.minval <= rst.maxval\n              ? rst.count >= rst.minval : rst.count >= rst.maxval) {\n            /* It could match.  Prepare for trying to match what\n             * follows.  The code is below.  Parameters are stored in\n             * a regstar_T on the regstack. */\n            if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) {\n              EMSG(_(e_maxmempat));\n              status = RA_FAIL;\n            } else {\n              ga_grow(&regstack, sizeof(regstar_T));\n              regstack.ga_len += sizeof(regstar_T);\n              rp = regstack_push(rst.minval <= rst.maxval\n                  ? RS_STAR_LONG : RS_STAR_SHORT, scan);\n              if (rp == NULL)\n                status = RA_FAIL;\n              else {\n                *(((regstar_T *)rp) - 1) = rst;\n                status = RA_BREAK;                  /* skip the restore bits */\n              }\n            }\n          } else\n            status = RA_NOMATCH;\n\n        }\n        break;\n\n        case NOMATCH:\n        case MATCH:\n        case SUBPAT:\n          rp = regstack_push(RS_NOMATCH, scan);\n          if (rp == NULL)\n            status = RA_FAIL;\n          else {\n            rp->rs_no = op;\n            reg_save(&rp->rs_un.regsave, &backpos);\n            next = OPERAND(scan);\n            /* We continue and handle the result when done. */\n          }\n          break;\n\n        case BEHIND:\n        case NOBEHIND:\n          /* Need a bit of room to store extra positions. */\n          if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) {\n            EMSG(_(e_maxmempat));\n            status = RA_FAIL;\n          } else {\n            ga_grow(&regstack, sizeof(regbehind_T));\n            regstack.ga_len += sizeof(regbehind_T);\n            rp = regstack_push(RS_BEHIND1, scan);\n            if (rp == NULL)\n              status = RA_FAIL;\n            else {\n              /* Need to save the subexpr to be able to restore them\n               * when there is a match but we don't use it. */\n              save_subexpr(((regbehind_T *)rp) - 1);\n\n              rp->rs_no = op;\n              reg_save(&rp->rs_un.regsave, &backpos);\n              /* First try if what follows matches.  If it does then we\n               * check the behind match by looping. */\n            }\n          }\n          break;\n\n        case BHPOS:\n          if (REG_MULTI) {\n            if (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n                || behind_pos.rs_u.pos.lnum != rex.lnum) {\n              status = RA_NOMATCH;\n            }\n          } else if (behind_pos.rs_u.ptr != rex.input) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case NEWL:\n          if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n               || rex.reg_line_lbr) && (c != '\\n' || !rex.reg_line_lbr)) {\n            status = RA_NOMATCH;\n          } else if (rex.reg_line_lbr) {\n            ADVANCE_REGINPUT();\n          } else {\n            reg_nextline();\n          }\n          break;\n\n        case END:\n          status = RA_MATCH;    /* Success! */\n          break;\n\n        default:\n          IEMSG(_(e_re_corr));\n#ifdef REGEXP_DEBUG\n          printf(\"Illegal op code %d\\n\", op);\n#endif\n          status = RA_FAIL;\n          break;\n        }\n      }\n\n      /* If we can't continue sequentially, break the inner loop. */\n      if (status != RA_CONT)\n        break;\n\n      /* Continue in inner loop, advance to next item. */\n      scan = next;\n\n    } /* end of inner loop */\n\n    /*\n     * If there is something on the regstack execute the code for the state.\n     * If the state is popped then loop and use the older state.\n     */\n    while (!GA_EMPTY(&regstack) && status != RA_FAIL) {\n      rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n      switch (rp->rs_state) {\n      case RS_NOPEN:\n        /* Result is passed on as-is, simply pop the state. */\n        regstack_pop(&scan);\n        break;\n\n      case RS_MOPEN:\n        // Pop the state.  Restore pointers when there is no match.\n        if (status == RA_NOMATCH) {\n          restore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n                     &rex.reg_startp[rp->rs_no]);\n        }\n        regstack_pop(&scan);\n        break;\n\n      case RS_ZOPEN:\n        /* Pop the state.  Restore pointers when there is no match. */\n        if (status == RA_NOMATCH)\n          restore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n              &reg_startzp[rp->rs_no]);\n        regstack_pop(&scan);\n        break;\n\n      case RS_MCLOSE:\n        // Pop the state.  Restore pointers when there is no match.\n        if (status == RA_NOMATCH) {\n          restore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n                     &rex.reg_endp[rp->rs_no]);\n        }\n        regstack_pop(&scan);\n        break;\n\n      case RS_ZCLOSE:\n        /* Pop the state.  Restore pointers when there is no match. */\n        if (status == RA_NOMATCH)\n          restore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n              &reg_endzp[rp->rs_no]);\n        regstack_pop(&scan);\n        break;\n\n      case RS_BRANCH:\n        if (status == RA_MATCH)\n          /* this branch matched, use it */\n          regstack_pop(&scan);\n        else {\n          if (status != RA_BREAK) {\n            /* After a non-matching branch: try next one. */\n            reg_restore(&rp->rs_un.regsave, &backpos);\n            scan = rp->rs_scan;\n          }\n          if (scan == NULL || OP(scan) != BRANCH) {\n            /* no more branches, didn't find a match */\n            status = RA_NOMATCH;\n            regstack_pop(&scan);\n          } else {\n            /* Prepare to try a branch. */\n            rp->rs_scan = regnext(scan);\n            reg_save(&rp->rs_un.regsave, &backpos);\n            scan = OPERAND(scan);\n          }\n        }\n        break;\n\n      case RS_BRCPLX_MORE:\n        /* Pop the state.  Restore pointers when there is no match. */\n        if (status == RA_NOMATCH) {\n          reg_restore(&rp->rs_un.regsave, &backpos);\n          --brace_count[rp->rs_no];             /* decrement match count */\n        }\n        regstack_pop(&scan);\n        break;\n\n      case RS_BRCPLX_LONG:\n        /* Pop the state.  Restore pointers when there is no match. */\n        if (status == RA_NOMATCH) {\n          /* There was no match, but we did find enough matches. */\n          reg_restore(&rp->rs_un.regsave, &backpos);\n          --brace_count[rp->rs_no];\n          /* continue with the items after \"\\{}\" */\n          status = RA_CONT;\n        }\n        regstack_pop(&scan);\n        if (status == RA_CONT)\n          scan = regnext(scan);\n        break;\n\n      case RS_BRCPLX_SHORT:\n        /* Pop the state.  Restore pointers when there is no match. */\n        if (status == RA_NOMATCH)\n          /* There was no match, try to match one more item. */\n          reg_restore(&rp->rs_un.regsave, &backpos);\n        regstack_pop(&scan);\n        if (status == RA_NOMATCH) {\n          scan = OPERAND(scan);\n          status = RA_CONT;\n        }\n        break;\n\n      case RS_NOMATCH:\n        /* Pop the state.  If the operand matches for NOMATCH or\n        * doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,\n        * except for SUBPAT, and continue with the next item. */\n        if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n          status = RA_NOMATCH;\n        else {\n          status = RA_CONT;\n          if (rp->rs_no != SUBPAT)              /* zero-width */\n            reg_restore(&rp->rs_un.regsave, &backpos);\n        }\n        regstack_pop(&scan);\n        if (status == RA_CONT)\n          scan = regnext(scan);\n        break;\n\n      case RS_BEHIND1:\n        if (status == RA_NOMATCH) {\n          regstack_pop(&scan);\n          regstack.ga_len -= sizeof(regbehind_T);\n        } else {\n          /* The stuff after BEHIND/NOBEHIND matches.  Now try if\n           * the behind part does (not) match before the current\n           * position in the input.  This must be done at every\n           * position in the input and checking if the match ends at\n           * the current position. */\n\n          /* save the position after the found match for next */\n          reg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\n          /* Start looking for a match with operand at the current\n           * position.  Go back one character until we find the\n           * result, hitting the start of the line or the previous\n           * line (for multi-line matching).\n           * Set behind_pos to where the match should end, BHPOS\n           * will match it.  Save the current value. */\n          (((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n          behind_pos = rp->rs_un.regsave;\n\n          rp->rs_state = RS_BEHIND2;\n\n          reg_restore(&rp->rs_un.regsave, &backpos);\n          scan = OPERAND(rp->rs_scan) + 4;\n        }\n        break;\n\n      case RS_BEHIND2:\n        /*\n         * Looping for BEHIND / NOBEHIND match.\n         */\n        if (status == RA_MATCH && reg_save_equal(&behind_pos)) {\n          /* found a match that ends where \"next\" started */\n          behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n          if (rp->rs_no == BEHIND)\n            reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n                &backpos);\n          else {\n            /* But we didn't want a match.  Need to restore the\n             * subexpr, because what follows matched, so they have\n             * been set. */\n            status = RA_NOMATCH;\n            restore_subexpr(((regbehind_T *)rp) - 1);\n          }\n          regstack_pop(&scan);\n          regstack.ga_len -= sizeof(regbehind_T);\n        } else {\n          long limit;\n\n          /* No match or a match that doesn't end where we want it: Go\n           * back one character.  May go to previous line once. */\n          no = OK;\n          limit = OPERAND_MIN(rp->rs_scan);\n          if (REG_MULTI) {\n            if (limit > 0\n                && ((rp->rs_un.regsave.rs_u.pos.lnum\n                     < behind_pos.rs_u.pos.lnum\n                     ? (colnr_T)STRLEN(rex.line)\n                     : behind_pos.rs_u.pos.col)\n                    - rp->rs_un.regsave.rs_u.pos.col >= limit))\n              no = FAIL;\n            else if (rp->rs_un.regsave.rs_u.pos.col == 0) {\n              if (rp->rs_un.regsave.rs_u.pos.lnum\n                  < behind_pos.rs_u.pos.lnum\n                  || reg_getline(\n                      --rp->rs_un.regsave.rs_u.pos.lnum)\n                  == NULL)\n                no = FAIL;\n              else {\n                reg_restore(&rp->rs_un.regsave, &backpos);\n                rp->rs_un.regsave.rs_u.pos.col =\n                  (colnr_T)STRLEN(rex.line);\n              }\n            } else {\n              const char_u *const line =\n                  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\n              rp->rs_un.regsave.rs_u.pos.col -=\n                  utf_head_off(line,\n                               line + rp->rs_un.regsave.rs_u.pos.col - 1)\n                  + 1;\n            }\n          } else {\n            if (rp->rs_un.regsave.rs_u.ptr == rex.line) {\n              no = FAIL;\n            } else {\n              MB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n              if (limit > 0\n                  && (long)(behind_pos.rs_u.ptr\n                            - rp->rs_un.regsave.rs_u.ptr) > limit) {\n                no = FAIL;\n              }\n            }\n          }\n          if (no == OK) {\n            /* Advanced, prepare for finding match again. */\n            reg_restore(&rp->rs_un.regsave, &backpos);\n            scan = OPERAND(rp->rs_scan) + 4;\n            if (status == RA_MATCH) {\n              /* We did match, so subexpr may have been changed,\n               * need to restore them for the next try. */\n              status = RA_NOMATCH;\n              restore_subexpr(((regbehind_T *)rp) - 1);\n            }\n          } else {\n            /* Can't advance.  For NOBEHIND that's a match. */\n            behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n            if (rp->rs_no == NOBEHIND) {\n              reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n                  &backpos);\n              status = RA_MATCH;\n            } else {\n              /* We do want a proper match.  Need to restore the\n               * subexpr if we had a match, because they may have\n               * been set. */\n              if (status == RA_MATCH) {\n                status = RA_NOMATCH;\n                restore_subexpr(((regbehind_T *)rp) - 1);\n              }\n            }\n            regstack_pop(&scan);\n            regstack.ga_len -= sizeof(regbehind_T);\n          }\n        }\n        break;\n\n      case RS_STAR_LONG:\n      case RS_STAR_SHORT:\n      {\n        regstar_T           *rst = ((regstar_T *)rp) - 1;\n\n        if (status == RA_MATCH) {\n          regstack_pop(&scan);\n          regstack.ga_len -= sizeof(regstar_T);\n          break;\n        }\n\n        /* Tried once already, restore input pointers. */\n        if (status != RA_BREAK)\n          reg_restore(&rp->rs_un.regsave, &backpos);\n\n        /* Repeat until we found a position where it could match. */\n        for (;; ) {\n          if (status != RA_BREAK) {\n            /* Tried first position already, advance. */\n            if (rp->rs_state == RS_STAR_LONG) {\n              /* Trying for longest match, but couldn't or\n               * didn't match -- back up one char. */\n              if (--rst->count < rst->minval)\n                break;\n              if (rex.input == rex.line) {\n                // backup to last char of previous line\n                rex.lnum--;\n                rex.line = reg_getline(rex.lnum);\n                // Just in case regrepeat() didn't count right.\n                if (rex.line == NULL) {\n                  break;\n                }\n                rex.input = rex.line + STRLEN(rex.line);\n                fast_breakcheck();\n              } else {\n                MB_PTR_BACK(rex.line, rex.input);\n              }\n            } else {\n              /* Range is backwards, use shortest match first.\n               * Careful: maxval and minval are exchanged!\n               * Couldn't or didn't match: try advancing one\n               * char. */\n              if (rst->count == rst->minval\n                  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n                break;\n              ++rst->count;\n            }\n            if (got_int)\n              break;\n          } else\n            status = RA_NOMATCH;\n\n          // If it could match, try it.\n          if (rst->nextb == NUL || *rex.input == rst->nextb\n              || *rex.input == rst->nextb_ic) {\n            reg_save(&rp->rs_un.regsave, &backpos);\n            scan = regnext(rp->rs_scan);\n            status = RA_CONT;\n            break;\n          }\n        }\n        if (status != RA_CONT) {\n          /* Failed. */\n          regstack_pop(&scan);\n          regstack.ga_len -= sizeof(regstar_T);\n          status = RA_NOMATCH;\n        }\n      }\n      break;\n      }\n\n      /* If we want to continue the inner loop or didn't pop a state\n       * continue matching loop */\n      if (status == RA_CONT || rp == (regitem_T *)\n          ((char *)regstack.ga_data + regstack.ga_len) - 1)\n        break;\n    }\n\n    /* May need to continue with the inner loop, starting at \"scan\". */\n    if (status == RA_CONT)\n      continue;\n\n    /*\n     * If the regstack is empty or something failed we are done.\n     */\n    if (GA_EMPTY(&regstack) || status == RA_FAIL) {\n      if (scan == NULL) {\n        /*\n         * We get here only if there's trouble -- normally \"case END\" is\n         * the terminating point.\n         */\n        IEMSG(_(e_re_corr));\n#ifdef REGEXP_DEBUG\n        printf(\"Premature EOL\\n\");\n#endif\n      }\n      return status == RA_MATCH;\n    }\n\n  } /* End of loop until the regstack is empty. */\n\n  /* NOTREACHED */\n}\n\n/*\n * Push an item onto the regstack.\n * Returns pointer to new item.  Returns NULL when out of memory.\n */\nstatic regitem_T *regstack_push(regstate_T state, char_u *scan)\n{\n  regitem_T   *rp;\n\n  if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) {\n    EMSG(_(e_maxmempat));\n    return NULL;\n  }\n  ga_grow(&regstack, sizeof(regitem_T));\n\n  rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len);\n  rp->rs_state = state;\n  rp->rs_scan = scan;\n\n  regstack.ga_len += sizeof(regitem_T);\n  return rp;\n}\n\n/*\n * Pop an item from the regstack.\n */\nstatic void regstack_pop(char_u **scan)\n{\n  regitem_T   *rp;\n\n  rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n  *scan = rp->rs_scan;\n\n  regstack.ga_len -= sizeof(regitem_T);\n}\n\n/*\n * regrepeat - repeatedly match something simple, return how many.\n * Advances rex.input (and rex.lnum) to just after the matched chars.\n */\nstatic int \nregrepeat (\n    char_u *p,\n    long maxcount              /* maximum number of matches allowed */\n)\n{\n  long count = 0;\n  char_u      *opnd;\n  int mask;\n  int testval = 0;\n\n  char_u *scan = rex.input;  // Make local copy of rex.input for speed.\n  opnd = OPERAND(p);\n  switch (OP(p)) {\n  case ANY:\n  case ANY + ADD_NL:\n    while (count < maxcount) {\n      /* Matching anything means we continue until end-of-line (or\n       * end-of-file for ANY + ADD_NL), only limited by maxcount. */\n      while (*scan != NUL && count < maxcount) {\n        count++;\n        MB_PTR_ADV(scan);\n      }\n      if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n          || rex.reg_line_lbr || count == maxcount) {\n        break;\n      }\n      count++;  // count the line-break\n      reg_nextline();\n      scan = rex.input;\n      if (got_int) {\n        break;\n      }\n    }\n    break;\n\n  case IDENT:\n  case IDENT + ADD_NL:\n    testval = 1;\n    FALLTHROUGH;\n  case SIDENT:\n  case SIDENT + ADD_NL:\n    while (count < maxcount) {\n      if (vim_isIDc(PTR2CHAR(scan)) && (testval || !ascii_isdigit(*scan))) {\n        MB_PTR_ADV(scan);\n      } else if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else {\n        break;\n      }\n      ++count;\n    }\n    break;\n\n  case KWORD:\n  case KWORD + ADD_NL:\n    testval = 1;\n    FALLTHROUGH;\n  case SKWORD:\n  case SKWORD + ADD_NL:\n    while (count < maxcount) {\n      if (vim_iswordp_buf(scan, rex.reg_buf)\n          && (testval || !ascii_isdigit(*scan))) {\n        MB_PTR_ADV(scan);\n      } else if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else {\n        break;\n      }\n      count++;\n    }\n    break;\n\n  case FNAME:\n  case FNAME + ADD_NL:\n    testval = 1;\n    FALLTHROUGH;\n  case SFNAME:\n  case SFNAME + ADD_NL:\n    while (count < maxcount) {\n      if (vim_isfilec(PTR2CHAR(scan)) && (testval || !ascii_isdigit(*scan))) {\n        MB_PTR_ADV(scan);\n      } else if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else {\n        break;\n      }\n      count++;\n    }\n    break;\n\n  case PRINT:\n  case PRINT + ADD_NL:\n    testval = 1;\n    FALLTHROUGH;\n  case SPRINT:\n  case SPRINT + ADD_NL:\n    while (count < maxcount) {\n      if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if (vim_isprintc(PTR2CHAR(scan)) == 1\n                 && (testval || !ascii_isdigit(*scan))) {\n        MB_PTR_ADV(scan);\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else {\n        break;\n      }\n      count++;\n    }\n    break;\n\n  case WHITE:\n  case WHITE + ADD_NL:\n    testval = mask = RI_WHITE;\ndo_class:\n    while (count < maxcount) {\n      int l;\n      if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if ((l = (*mb_ptr2len)(scan)) > 1) {\n        if (testval != 0) {\n          break;\n        }\n        scan += l;\n      } else if ((class_tab[*scan] & mask) == testval) {\n        scan++;\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else {\n        break;\n      }\n      ++count;\n    }\n    break;\n\n  case NWHITE:\n  case NWHITE + ADD_NL:\n    mask = RI_WHITE;\n    goto do_class;\n  case DIGIT:\n  case DIGIT + ADD_NL:\n    testval = mask = RI_DIGIT;\n    goto do_class;\n  case NDIGIT:\n  case NDIGIT + ADD_NL:\n    mask = RI_DIGIT;\n    goto do_class;\n  case HEX:\n  case HEX + ADD_NL:\n    testval = mask = RI_HEX;\n    goto do_class;\n  case NHEX:\n  case NHEX + ADD_NL:\n    mask = RI_HEX;\n    goto do_class;\n  case OCTAL:\n  case OCTAL + ADD_NL:\n    testval = mask = RI_OCTAL;\n    goto do_class;\n  case NOCTAL:\n  case NOCTAL + ADD_NL:\n    mask = RI_OCTAL;\n    goto do_class;\n  case WORD:\n  case WORD + ADD_NL:\n    testval = mask = RI_WORD;\n    goto do_class;\n  case NWORD:\n  case NWORD + ADD_NL:\n    mask = RI_WORD;\n    goto do_class;\n  case HEAD:\n  case HEAD + ADD_NL:\n    testval = mask = RI_HEAD;\n    goto do_class;\n  case NHEAD:\n  case NHEAD + ADD_NL:\n    mask = RI_HEAD;\n    goto do_class;\n  case ALPHA:\n  case ALPHA + ADD_NL:\n    testval = mask = RI_ALPHA;\n    goto do_class;\n  case NALPHA:\n  case NALPHA + ADD_NL:\n    mask = RI_ALPHA;\n    goto do_class;\n  case LOWER:\n  case LOWER + ADD_NL:\n    testval = mask = RI_LOWER;\n    goto do_class;\n  case NLOWER:\n  case NLOWER + ADD_NL:\n    mask = RI_LOWER;\n    goto do_class;\n  case UPPER:\n  case UPPER + ADD_NL:\n    testval = mask = RI_UPPER;\n    goto do_class;\n  case NUPPER:\n  case NUPPER + ADD_NL:\n    mask = RI_UPPER;\n    goto do_class;\n\n  case EXACTLY:\n  {\n    int cu, cl;\n\n    // This doesn't do a multi-byte character, because a MULTIBYTECODE\n    // would have been used for it.  It does handle single-byte\n    // characters, such as latin1.\n    if (rex.reg_ic) {\n      cu = mb_toupper(*opnd);\n      cl = mb_tolower(*opnd);\n      while (count < maxcount && (*scan == cu || *scan == cl)) {\n        count++;\n        scan++;\n      }\n    } else {\n      cu = *opnd;\n      while (count < maxcount && *scan == cu) {\n        count++;\n        scan++;\n      }\n    }\n    break;\n  }\n\n  case MULTIBYTECODE:\n  {\n    int i, len, cf = 0;\n\n    /* Safety check (just in case 'encoding' was changed since\n     * compiling the program). */\n    if ((len = (*mb_ptr2len)(opnd)) > 1) {\n      if (rex.reg_ic) {\n        cf = utf_fold(utf_ptr2char(opnd));\n      }\n      while (count < maxcount && (*mb_ptr2len)(scan) >= len) {\n        for (i = 0; i < len; ++i) {\n          if (opnd[i] != scan[i]) {\n            break;\n          }\n        }\n        if (i < len && (!rex.reg_ic\n                        || utf_fold(utf_ptr2char(scan)) != cf)) {\n          break;\n        }\n        scan += len;\n        ++count;\n      }\n    }\n  }\n  break;\n\n  case ANYOF:\n  case ANYOF + ADD_NL:\n    testval = 1;\n    FALLTHROUGH;\n\n  case ANYBUT:\n  case ANYBUT + ADD_NL:\n    while (count < maxcount) {\n      int len;\n      if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else if ((len = utfc_ptr2len(scan)) > 1) {\n        if ((cstrchr(opnd, utf_ptr2char(scan)) == NULL) == testval) {\n          break;\n        }\n        scan += len;\n      } else {\n        if ((cstrchr(opnd, *scan) == NULL) == testval)\n          break;\n        ++scan;\n      }\n      ++count;\n    }\n    break;\n\n  case NEWL:\n    while (count < maxcount\n           && ((*scan == NUL && rex.lnum <= rex.reg_maxline && !rex.reg_line_lbr\n                && REG_MULTI) || (*scan == '\\n' && rex.reg_line_lbr))) {\n      count++;\n      if (rex.reg_line_lbr) {\n        ADVANCE_REGINPUT();\n      } else {\n        reg_nextline();\n      }\n      scan = rex.input;\n      if (got_int) {\n        break;\n      }\n    }\n    break;\n\n  default:  // Oh dear.  Called inappropriately.\n    IEMSG(_(e_re_corr));\n#ifdef REGEXP_DEBUG\n    printf(\"Called regrepeat with op code %d\\n\", OP(p));\n#endif\n    break;\n  }\n\n  rex.input = scan;\n\n  return (int)count;\n}\n\n/*\n * regnext - dig the \"next\" pointer out of a node\n * Returns NULL when calculating size, when there is no next item and when\n * there is an error.\n */\nstatic char_u *regnext(char_u *p)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int offset;\n\n  if (p == JUST_CALC_SIZE || reg_toolong)\n    return NULL;\n\n  offset = NEXT(p);\n  if (offset == 0)\n    return NULL;\n\n  if (OP(p) == BACK)\n    return p - offset;\n  else\n    return p + offset;\n}\n\n/*\n * Check the regexp program for its magic number.\n * Return true if it's wrong.\n */\nstatic int prog_magic_wrong(void)\n{\n  regprog_T   *prog;\n\n  prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;\n  if (prog->engine == &nfa_regengine) {\n    // For NFA matcher we don't check the magic\n    return false;\n  }\n\n  if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC) {\n    EMSG(_(e_re_corr));\n    return true;\n  }\n  return false;\n}\n\n/*\n * Cleanup the subexpressions, if this wasn't done yet.\n * This construction is used to clear the subexpressions only when they are\n * used (to increase speed).\n */\nstatic void cleanup_subexpr(void)\n{\n  if (rex.need_clear_subexpr) {\n    if (REG_MULTI) {\n      // Use 0xff to set lnum to -1\n      memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n      memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n    } else {\n      memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);\n      memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);\n    }\n    rex.need_clear_subexpr = false;\n  }\n}\n\nstatic void cleanup_zsubexpr(void)\n{\n  if (rex.need_clear_zsubexpr) {\n    if (REG_MULTI) {\n      /* Use 0xff to set lnum to -1 */\n      memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n      memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n    } else {\n      memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);\n      memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);\n    }\n    rex.need_clear_zsubexpr = false;\n  }\n}\n\n// Save the current subexpr to \"bp\", so that they can be restored\n// later by restore_subexpr().\nstatic void save_subexpr(regbehind_T *bp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // When \"rex.need_clear_subexpr\" is set we don't need to save the values, only\n  // remember that this flag needs to be set again when restoring.\n  bp->save_need_clear_subexpr = rex.need_clear_subexpr;\n  if (!rex.need_clear_subexpr) {\n    for (int i = 0; i < NSUBEXP; i++) {\n      if (REG_MULTI) {\n        bp->save_start[i].se_u.pos = rex.reg_startpos[i];\n        bp->save_end[i].se_u.pos = rex.reg_endpos[i];\n      } else {\n        bp->save_start[i].se_u.ptr = rex.reg_startp[i];\n        bp->save_end[i].se_u.ptr = rex.reg_endp[i];\n      }\n    }\n  }\n}\n\n// Restore the subexpr from \"bp\".\nstatic void restore_subexpr(regbehind_T *bp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Only need to restore saved values when they are not to be cleared.\n  rex.need_clear_subexpr = bp->save_need_clear_subexpr;\n  if (!rex.need_clear_subexpr) {\n    for (int i = 0; i < NSUBEXP; i++) {\n      if (REG_MULTI) {\n        rex.reg_startpos[i] = bp->save_start[i].se_u.pos;\n        rex.reg_endpos[i] = bp->save_end[i].se_u.pos;\n      } else {\n        rex.reg_startp[i] = bp->save_start[i].se_u.ptr;\n        rex.reg_endp[i] = bp->save_end[i].se_u.ptr;\n      }\n    }\n  }\n}\n\n// Advance rex.lnum, rex.line and rex.input to the next line.\nstatic void reg_nextline(void)\n{\n  rex.line = reg_getline(++rex.lnum);\n  rex.input = rex.line;\n  fast_breakcheck();\n}\n\n// Save the input line and position in a regsave_T.\nstatic void reg_save(regsave_T *save, garray_T *gap)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (REG_MULTI) {\n    save->rs_u.pos.col = (colnr_T)(rex.input - rex.line);\n    save->rs_u.pos.lnum = rex.lnum;\n  } else {\n    save->rs_u.ptr = rex.input;\n  }\n  save->rs_len = gap->ga_len;\n}\n\n// Restore the input line and position from a regsave_T.\nstatic void reg_restore(regsave_T *save, garray_T *gap)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (REG_MULTI) {\n    if (rex.lnum != save->rs_u.pos.lnum) {\n      // only call reg_getline() when the line number changed to save\n      // a bit of time\n      rex.lnum = save->rs_u.pos.lnum;\n      rex.line = reg_getline(rex.lnum);\n    }\n    rex.input = rex.line + save->rs_u.pos.col;\n  } else {\n    rex.input = save->rs_u.ptr;\n  }\n  gap->ga_len = save->rs_len;\n}\n\n// Return true if current position is equal to saved position.\nstatic bool reg_save_equal(const regsave_T *save)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (REG_MULTI) {\n    return rex.lnum == save->rs_u.pos.lnum\n           && rex.input == rex.line + save->rs_u.pos.col;\n  }\n  return rex.input == save->rs_u.ptr;\n}\n\n/*\n * Tentatively set the sub-expression start to the current position (after\n * calling regmatch() they will have changed).  Need to save the existing\n * values for when there is no match.\n * Use se_save() to use pointer (save_se_multi()) or position (save_se_one()),\n * depending on REG_MULTI.\n */\nstatic void save_se_multi(save_se_T *savep, lpos_T *posp)\n{\n  savep->se_u.pos = *posp;\n  posp->lnum = rex.lnum;\n  posp->col = (colnr_T)(rex.input - rex.line);\n}\n\nstatic void save_se_one(save_se_T *savep, char_u **pp)\n{\n  savep->se_u.ptr = *pp;\n  *pp = rex.input;\n}\n\n/*\n * Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL.\n */\nstatic int re_num_cmp(uint32_t val, char_u *scan)\n{\n  uint32_t n = (uint32_t)OPERAND_MIN(scan);\n\n  if (OPERAND_CMP(scan) == '>')\n    return val > n;\n  if (OPERAND_CMP(scan) == '<')\n    return val < n;\n  return val == n;\n}\n\n/*\n * Check whether a backreference matches.\n * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.\n * If \"bytelen\" is not NULL, it is set to the byte length of the match in the\n * last line.\n */\nstatic int match_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen)\n{\n  linenr_T clnum = start_lnum;\n  colnr_T ccol = start_col;\n  int len;\n  char_u      *p;\n\n  if (bytelen != NULL)\n    *bytelen = 0;\n  for (;; ) {\n    /* Since getting one line may invalidate the other, need to make copy.\n     * Slow! */\n    if (rex.line != reg_tofree) {\n      len = (int)STRLEN(rex.line);\n      if (reg_tofree == NULL || len >= (int)reg_tofreelen) {\n        len += 50;              /* get some extra */\n        xfree(reg_tofree);\n        reg_tofree = xmalloc(len);\n        reg_tofreelen = len;\n      }\n      STRCPY(reg_tofree, rex.line);\n      rex.input = reg_tofree + (rex.input - rex.line);\n      rex.line = reg_tofree;\n    }\n\n    /* Get the line to compare with. */\n    p = reg_getline(clnum);\n    assert(p);\n\n    if (clnum == end_lnum)\n      len = end_col - ccol;\n    else\n      len = (int)STRLEN(p + ccol);\n\n    if (cstrncmp(p + ccol, rex.input, &len) != 0) {\n      return RA_NOMATCH;  // doesn't match\n    }\n    if (bytelen != NULL) {\n      *bytelen += len;\n    }\n    if (clnum == end_lnum) {\n      break;  // match and at end!\n    }\n    if (rex.lnum >= rex.reg_maxline) {\n      return RA_NOMATCH;  // text too short\n    }\n\n    /* Advance to next line. */\n    reg_nextline();\n    if (bytelen != NULL)\n      *bytelen = 0;\n    ++clnum;\n    ccol = 0;\n    if (got_int)\n      return RA_FAIL;\n  }\n\n  // found a match!  Note that rex.line may now point to a copy of the line,\n  // that should not matter.\n  return RA_MATCH;\n}\n\n#ifdef BT_REGEXP_DUMP\n\n/*\n * regdump - dump a regexp onto stdout in vaguely comprehensible form\n */\nstatic void regdump(char_u *pattern, bt_regprog_T *r)\n{\n  char_u  *s;\n  int op = EXACTLY;             /* Arbitrary non-END op. */\n  char_u  *next;\n  char_u  *end = NULL;\n  FILE    *f;\n\n#ifdef BT_REGEXP_LOG\n  f = fopen(\"bt_regexp_log.log\", \"a\");\n#else\n  f = stdout;\n#endif\n  if (f == NULL)\n    return;\n  fprintf(f, \"-------------------------------------\\n\\r\\nregcomp(%s):\\r\\n\",\n      pattern);\n\n  s = r->program + 1;\n  /*\n   * Loop until we find the END that isn't before a referred next (an END\n   * can also appear in a NOMATCH operand).\n   */\n  while (op != END || s <= end) {\n    op = OP(s);\n    fprintf(f, \"%2d%s\", (int)(s - r->program), regprop(s));     /* Where, what. */\n    next = regnext(s);\n    if (next == NULL)           /* Next ptr. */\n      fprintf(f, \"(0)\");\n    else\n      fprintf(f, \"(%d)\", (int)((s - r->program) + (next - s)));\n    if (end < next)\n      end = next;\n    if (op == BRACE_LIMITS) {\n      /* Two ints */\n      fprintf(f, \" minval %\" PRId64 \", maxval %\" PRId64,\n              (int64_t)OPERAND_MIN(s), (int64_t)OPERAND_MAX(s));\n      s += 8;\n    } else if (op == BEHIND || op == NOBEHIND) {\n      /* one int */\n      fprintf(f, \" count %\" PRId64, (int64_t)OPERAND_MIN(s));\n      s += 4;\n    } else if (op == RE_LNUM || op == RE_COL || op == RE_VCOL) {\n      // one int plus comparator\n      fprintf(f, \" count %\" PRId64, (int64_t)OPERAND_MIN(s));\n      s += 5;\n    }\n    s += 3;\n    if (op == ANYOF || op == ANYOF + ADD_NL\n        || op == ANYBUT || op == ANYBUT + ADD_NL\n        || op == EXACTLY) {\n      /* Literal string, where present. */\n      fprintf(f, \"\\nxxxxxxxxx\\n\");\n      while (*s != NUL)\n        fprintf(f, \"%c\", *s++);\n      fprintf(f, \"\\nxxxxxxxxx\\n\");\n      s++;\n    }\n    fprintf(f, \"\\r\\n\");\n  }\n\n  /* Header fields of interest. */\n  if (r->regstart != NUL)\n    fprintf(f, \"start `%s' 0x%x; \", r->regstart < 256\n        ? (char *)transchar(r->regstart)\n        : \"multibyte\", r->regstart);\n  if (r->reganch)\n    fprintf(f, \"anchored; \");\n  if (r->regmust != NULL)\n    fprintf(f, \"must have \\\"%s\\\"\", r->regmust);\n  fprintf(f, \"\\r\\n\");\n\n#ifdef BT_REGEXP_LOG\n  fclose(f);\n#endif\n}\n#endif      /* BT_REGEXP_DUMP */\n\n#ifdef REGEXP_DEBUG\n/*\n * regprop - printable representation of opcode\n */\nstatic char_u *regprop(char_u *op)\n{\n  char            *p;\n  static char buf[50];\n\n  STRCPY(buf, \":\");\n\n  switch ((int) OP(op)) {\n  case BOL:\n    p = \"BOL\";\n    break;\n  case EOL:\n    p = \"EOL\";\n    break;\n  case RE_BOF:\n    p = \"BOF\";\n    break;\n  case RE_EOF:\n    p = \"EOF\";\n    break;\n  case CURSOR:\n    p = \"CURSOR\";\n    break;\n  case RE_VISUAL:\n    p = \"RE_VISUAL\";\n    break;\n  case RE_LNUM:\n    p = \"RE_LNUM\";\n    break;\n  case RE_MARK:\n    p = \"RE_MARK\";\n    break;\n  case RE_COL:\n    p = \"RE_COL\";\n    break;\n  case RE_VCOL:\n    p = \"RE_VCOL\";\n    break;\n  case BOW:\n    p = \"BOW\";\n    break;\n  case EOW:\n    p = \"EOW\";\n    break;\n  case ANY:\n    p = \"ANY\";\n    break;\n  case ANY + ADD_NL:\n    p = \"ANY+NL\";\n    break;\n  case ANYOF:\n    p = \"ANYOF\";\n    break;\n  case ANYOF + ADD_NL:\n    p = \"ANYOF+NL\";\n    break;\n  case ANYBUT:\n    p = \"ANYBUT\";\n    break;\n  case ANYBUT + ADD_NL:\n    p = \"ANYBUT+NL\";\n    break;\n  case IDENT:\n    p = \"IDENT\";\n    break;\n  case IDENT + ADD_NL:\n    p = \"IDENT+NL\";\n    break;\n  case SIDENT:\n    p = \"SIDENT\";\n    break;\n  case SIDENT + ADD_NL:\n    p = \"SIDENT+NL\";\n    break;\n  case KWORD:\n    p = \"KWORD\";\n    break;\n  case KWORD + ADD_NL:\n    p = \"KWORD+NL\";\n    break;\n  case SKWORD:\n    p = \"SKWORD\";\n    break;\n  case SKWORD + ADD_NL:\n    p = \"SKWORD+NL\";\n    break;\n  case FNAME:\n    p = \"FNAME\";\n    break;\n  case FNAME + ADD_NL:\n    p = \"FNAME+NL\";\n    break;\n  case SFNAME:\n    p = \"SFNAME\";\n    break;\n  case SFNAME + ADD_NL:\n    p = \"SFNAME+NL\";\n    break;\n  case PRINT:\n    p = \"PRINT\";\n    break;\n  case PRINT + ADD_NL:\n    p = \"PRINT+NL\";\n    break;\n  case SPRINT:\n    p = \"SPRINT\";\n    break;\n  case SPRINT + ADD_NL:\n    p = \"SPRINT+NL\";\n    break;\n  case WHITE:\n    p = \"WHITE\";\n    break;\n  case WHITE + ADD_NL:\n    p = \"WHITE+NL\";\n    break;\n  case NWHITE:\n    p = \"NWHITE\";\n    break;\n  case NWHITE + ADD_NL:\n    p = \"NWHITE+NL\";\n    break;\n  case DIGIT:\n    p = \"DIGIT\";\n    break;\n  case DIGIT + ADD_NL:\n    p = \"DIGIT+NL\";\n    break;\n  case NDIGIT:\n    p = \"NDIGIT\";\n    break;\n  case NDIGIT + ADD_NL:\n    p = \"NDIGIT+NL\";\n    break;\n  case HEX:\n    p = \"HEX\";\n    break;\n  case HEX + ADD_NL:\n    p = \"HEX+NL\";\n    break;\n  case NHEX:\n    p = \"NHEX\";\n    break;\n  case NHEX + ADD_NL:\n    p = \"NHEX+NL\";\n    break;\n  case OCTAL:\n    p = \"OCTAL\";\n    break;\n  case OCTAL + ADD_NL:\n    p = \"OCTAL+NL\";\n    break;\n  case NOCTAL:\n    p = \"NOCTAL\";\n    break;\n  case NOCTAL + ADD_NL:\n    p = \"NOCTAL+NL\";\n    break;\n  case WORD:\n    p = \"WORD\";\n    break;\n  case WORD + ADD_NL:\n    p = \"WORD+NL\";\n    break;\n  case NWORD:\n    p = \"NWORD\";\n    break;\n  case NWORD + ADD_NL:\n    p = \"NWORD+NL\";\n    break;\n  case HEAD:\n    p = \"HEAD\";\n    break;\n  case HEAD + ADD_NL:\n    p = \"HEAD+NL\";\n    break;\n  case NHEAD:\n    p = \"NHEAD\";\n    break;\n  case NHEAD + ADD_NL:\n    p = \"NHEAD+NL\";\n    break;\n  case ALPHA:\n    p = \"ALPHA\";\n    break;\n  case ALPHA + ADD_NL:\n    p = \"ALPHA+NL\";\n    break;\n  case NALPHA:\n    p = \"NALPHA\";\n    break;\n  case NALPHA + ADD_NL:\n    p = \"NALPHA+NL\";\n    break;\n  case LOWER:\n    p = \"LOWER\";\n    break;\n  case LOWER + ADD_NL:\n    p = \"LOWER+NL\";\n    break;\n  case NLOWER:\n    p = \"NLOWER\";\n    break;\n  case NLOWER + ADD_NL:\n    p = \"NLOWER+NL\";\n    break;\n  case UPPER:\n    p = \"UPPER\";\n    break;\n  case UPPER + ADD_NL:\n    p = \"UPPER+NL\";\n    break;\n  case NUPPER:\n    p = \"NUPPER\";\n    break;\n  case NUPPER + ADD_NL:\n    p = \"NUPPER+NL\";\n    break;\n  case BRANCH:\n    p = \"BRANCH\";\n    break;\n  case EXACTLY:\n    p = \"EXACTLY\";\n    break;\n  case NOTHING:\n    p = \"NOTHING\";\n    break;\n  case BACK:\n    p = \"BACK\";\n    break;\n  case END:\n    p = \"END\";\n    break;\n  case MOPEN + 0:\n    p = \"MATCH START\";\n    break;\n  case MOPEN + 1:\n  case MOPEN + 2:\n  case MOPEN + 3:\n  case MOPEN + 4:\n  case MOPEN + 5:\n  case MOPEN + 6:\n  case MOPEN + 7:\n  case MOPEN + 8:\n  case MOPEN + 9:\n    sprintf(buf + STRLEN(buf), \"MOPEN%d\", OP(op) - MOPEN);\n    p = NULL;\n    break;\n  case MCLOSE + 0:\n    p = \"MATCH END\";\n    break;\n  case MCLOSE + 1:\n  case MCLOSE + 2:\n  case MCLOSE + 3:\n  case MCLOSE + 4:\n  case MCLOSE + 5:\n  case MCLOSE + 6:\n  case MCLOSE + 7:\n  case MCLOSE + 8:\n  case MCLOSE + 9:\n    sprintf(buf + STRLEN(buf), \"MCLOSE%d\", OP(op) - MCLOSE);\n    p = NULL;\n    break;\n  case BACKREF + 1:\n  case BACKREF + 2:\n  case BACKREF + 3:\n  case BACKREF + 4:\n  case BACKREF + 5:\n  case BACKREF + 6:\n  case BACKREF + 7:\n  case BACKREF + 8:\n  case BACKREF + 9:\n    sprintf(buf + STRLEN(buf), \"BACKREF%d\", OP(op) - BACKREF);\n    p = NULL;\n    break;\n  case NOPEN:\n    p = \"NOPEN\";\n    break;\n  case NCLOSE:\n    p = \"NCLOSE\";\n    break;\n  case ZOPEN + 1:\n  case ZOPEN + 2:\n  case ZOPEN + 3:\n  case ZOPEN + 4:\n  case ZOPEN + 5:\n  case ZOPEN + 6:\n  case ZOPEN + 7:\n  case ZOPEN + 8:\n  case ZOPEN + 9:\n    sprintf(buf + STRLEN(buf), \"ZOPEN%d\", OP(op) - ZOPEN);\n    p = NULL;\n    break;\n  case ZCLOSE + 1:\n  case ZCLOSE + 2:\n  case ZCLOSE + 3:\n  case ZCLOSE + 4:\n  case ZCLOSE + 5:\n  case ZCLOSE + 6:\n  case ZCLOSE + 7:\n  case ZCLOSE + 8:\n  case ZCLOSE + 9:\n    sprintf(buf + STRLEN(buf), \"ZCLOSE%d\", OP(op) - ZCLOSE);\n    p = NULL;\n    break;\n  case ZREF + 1:\n  case ZREF + 2:\n  case ZREF + 3:\n  case ZREF + 4:\n  case ZREF + 5:\n  case ZREF + 6:\n  case ZREF + 7:\n  case ZREF + 8:\n  case ZREF + 9:\n    sprintf(buf + STRLEN(buf), \"ZREF%d\", OP(op) - ZREF);\n    p = NULL;\n    break;\n  case STAR:\n    p = \"STAR\";\n    break;\n  case PLUS:\n    p = \"PLUS\";\n    break;\n  case NOMATCH:\n    p = \"NOMATCH\";\n    break;\n  case MATCH:\n    p = \"MATCH\";\n    break;\n  case BEHIND:\n    p = \"BEHIND\";\n    break;\n  case NOBEHIND:\n    p = \"NOBEHIND\";\n    break;\n  case SUBPAT:\n    p = \"SUBPAT\";\n    break;\n  case BRACE_LIMITS:\n    p = \"BRACE_LIMITS\";\n    break;\n  case BRACE_SIMPLE:\n    p = \"BRACE_SIMPLE\";\n    break;\n  case BRACE_COMPLEX + 0:\n  case BRACE_COMPLEX + 1:\n  case BRACE_COMPLEX + 2:\n  case BRACE_COMPLEX + 3:\n  case BRACE_COMPLEX + 4:\n  case BRACE_COMPLEX + 5:\n  case BRACE_COMPLEX + 6:\n  case BRACE_COMPLEX + 7:\n  case BRACE_COMPLEX + 8:\n  case BRACE_COMPLEX + 9:\n    sprintf(buf + STRLEN(buf), \"BRACE_COMPLEX%d\", OP(op) - BRACE_COMPLEX);\n    p = NULL;\n    break;\n  case MULTIBYTECODE:\n    p = \"MULTIBYTECODE\";\n    break;\n  case NEWL:\n    p = \"NEWL\";\n    break;\n  default:\n    sprintf(buf + STRLEN(buf), \"corrupt %d\", OP(op));\n    p = NULL;\n    break;\n  }\n  if (p != NULL)\n    STRCAT(buf, p);\n  return (char_u *)buf;\n}\n#endif      /* REGEXP_DEBUG */\n\n\n\n/* 0xfb20 - 0xfb4f */\nstatic decomp_T decomp_table[0xfb4f-0xfb20+1] =\n{\n  {0x5e2,0,0},                  /* 0xfb20\talt ayin */\n  {0x5d0,0,0},                  /* 0xfb21\talt alef */\n  {0x5d3,0,0},                  /* 0xfb22\talt dalet */\n  {0x5d4,0,0},                  /* 0xfb23\talt he */\n  {0x5db,0,0},                  /* 0xfb24\talt kaf */\n  {0x5dc,0,0},                  /* 0xfb25\talt lamed */\n  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */\n  {0x5e8,0,0},                  /* 0xfb27\talt resh */\n  {0x5ea,0,0},                  /* 0xfb28\talt tav */\n  {'+', 0, 0},                  /* 0xfb29\talt plus */\n  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */\n  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */\n  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */\n  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */\n  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */\n  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */\n  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */\n  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */\n  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */\n  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */\n  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */\n  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */\n  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */\n  {0xfb37, 0, 0},               /* 0xfb37 -- */\n  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */\n  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */\n  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */\n  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */\n  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */\n  {0xfb3d, 0, 0},               /* 0xfb3d -- */\n  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */\n  {0xfb3f, 0, 0},               /* 0xfb3f -- */\n  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */\n  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */\n  {0xfb42, 0, 0},               /* 0xfb42 -- */\n  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */\n  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */\n  {0xfb45, 0, 0},               /* 0xfb45 -- */\n  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */\n  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */\n  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */\n  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */\n  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */\n  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */\n  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */\n  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */\n  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */\n  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */\n};\n\nstatic void mb_decompose(int c, int *c1, int *c2, int *c3)\n{\n  decomp_T d;\n\n  if (c >= 0xfb20 && c <= 0xfb4f) {\n    d = decomp_table[c - 0xfb20];\n    *c1 = d.a;\n    *c2 = d.b;\n    *c3 = d.c;\n  } else {\n    *c1 = c;\n    *c2 = *c3 = 0;\n  }\n}\n\n// Compare two strings, ignore case if rex.reg_ic set.\n// Return 0 if strings match, non-zero otherwise.\n// Correct the length \"*n\" when composing characters are ignored.\nstatic int cstrncmp(char_u *s1, char_u *s2, int *n)\n{\n  int result;\n\n  if (!rex.reg_ic) {\n    result = STRNCMP(s1, s2, *n);\n  } else {\n    assert(*n >= 0);\n    result = mb_strnicmp(s1, s2, (size_t)*n);\n  }\n\n  // if it failed and it's utf8 and we want to combineignore:\n  if (result != 0 && rex.reg_icombine) {\n    char_u  *str1, *str2;\n    int c1, c2, c11, c12;\n    int junk;\n\n    /* we have to handle the strcmp ourselves, since it is necessary to\n     * deal with the composing characters by ignoring them: */\n    str1 = s1;\n    str2 = s2;\n    c1 = c2 = 0;\n    while ((int)(str1 - s1) < *n) {\n      c1 = mb_ptr2char_adv((const char_u **)&str1);\n      c2 = mb_ptr2char_adv((const char_u **)&str2);\n\n      /* decompose the character if necessary, into 'base' characters\n       * because I don't care about Arabic, I will hard-code the Hebrew\n       * which I *do* care about!  So sue me... */\n      if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2))) {\n        // decomposition necessary?\n        mb_decompose(c1, &c11, &junk, &junk);\n        mb_decompose(c2, &c12, &junk, &junk);\n        c1 = c11;\n        c2 = c12;\n        if (c11 != c12 && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12))) {\n          break;\n        }\n      }\n    }\n    result = c2 - c1;\n    if (result == 0)\n      *n = (int)(str2 - s2);\n  }\n\n  return result;\n}\n\n/***************************************************************\n*\t\t      regsub stuff\t\t\t       *\n***************************************************************/\n\n/* This stuff below really confuses cc on an SGI -- webb */\n\n\n\nstatic fptr_T do_upper(int *d, int c)\n{\n  *d = mb_toupper(c);\n\n  return (fptr_T)NULL;\n}\n\nstatic fptr_T do_Upper(int *d, int c)\n{\n  *d = mb_toupper(c);\n\n  return (fptr_T)do_Upper;\n}\n\nstatic fptr_T do_lower(int *d, int c)\n{\n  *d = mb_tolower(c);\n\n  return (fptr_T)NULL;\n}\n\nstatic fptr_T do_Lower(int *d, int c)\n{\n  *d = mb_tolower(c);\n\n  return (fptr_T)do_Lower;\n}\n\n/*\n * regtilde(): Replace tildes in the pattern by the old pattern.\n *\n * Short explanation of the tilde: It stands for the previous replacement\n * pattern.  If that previous pattern also contains a ~ we should go back a\n * step further...  But we insert the previous pattern into the current one\n * and remember that.\n * This still does not handle the case where \"magic\" changes.  So require the\n * user to keep his hands off of \"magic\".\n *\n * The tildes are parsed once before the first call to vim_regsub().\n */\nchar_u *regtilde(char_u *source, int magic)\n{\n  char_u      *newsub = source;\n  char_u      *tmpsub;\n  char_u      *p;\n  int len;\n  int prevlen;\n\n  for (p = newsub; *p; ++p) {\n    if ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic)) {\n      if (reg_prev_sub != NULL) {\n        /* length = len(newsub) - 1 + len(prev_sub) + 1 */\n        prevlen = (int)STRLEN(reg_prev_sub);\n        tmpsub = xmalloc(STRLEN(newsub) + prevlen);\n        /* copy prefix */\n        len = (int)(p - newsub);              /* not including ~ */\n        memmove(tmpsub, newsub, (size_t)len);\n        /* interpret tilde */\n        memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);\n        /* copy postfix */\n        if (!magic)\n          ++p;                                /* back off \\ */\n        STRCPY(tmpsub + len + prevlen, p + 1);\n\n        if (newsub != source)                 /* already allocated newsub */\n          xfree(newsub);\n        newsub = tmpsub;\n        p = newsub + len + prevlen;\n      } else if (magic)\n        STRMOVE(p, p + 1);              /* remove '~' */\n      else\n        STRMOVE(p, p + 2);              /* remove '\\~' */\n      --p;\n    } else {\n      if (*p == '\\\\' && p[1]) {         // skip escaped characters\n        p++;\n      }\n      p += (*mb_ptr2len)(p) - 1;\n    }\n  }\n\n  xfree(reg_prev_sub);\n  if (newsub != source)         /* newsub was allocated, just keep it */\n    reg_prev_sub = newsub;\n  else                          /* no ~ found, need to save newsub  */\n    reg_prev_sub = vim_strsave(newsub);\n  return newsub;\n}\n\nstatic bool can_f_submatch = false;  // true when submatch() can be used\n\n// These pointers are used for reg_submatch().  Needed for when the\n// substitution string is an expression that contains a call to substitute()\n// and submatch().\ntypedef struct {\n  regmatch_T *sm_match;\n  regmmatch_T *sm_mmatch;\n  linenr_T sm_firstlnum;\n  linenr_T sm_maxline;\n  int sm_line_lbr;\n} regsubmatch_T;\n\nstatic regsubmatch_T rsm;  // can only be used when can_f_submatch is true\n\n/// Put the submatches in \"argv[argskip]\" which is a list passed into\n/// call_func() by vim_regsub_both().\nstatic int fill_submatch_list(int argc FUNC_ATTR_UNUSED, typval_T *argv,\n                              int argskip, int argcount)\n  FUNC_ATTR_NONNULL_ALL\n{\n  typval_T *listarg = argv + argskip;\n\n  if (argcount == argskip) {\n    // called function doesn't take a submatches argument\n    return argskip;\n  }\n\n  // Relies on sl_list to be the first item in staticList10_T.\n  tv_list_init_static10((staticList10_T *)listarg->vval.v_list);\n\n  // There are always 10 list items in staticList10_T.\n  listitem_T *li = tv_list_first(listarg->vval.v_list);\n  for (int i = 0; i < 10; i++) {\n    char_u *s = rsm.sm_match->startp[i];\n    if (s == NULL || rsm.sm_match->endp[i] == NULL) {\n      s = NULL;\n    } else {\n      s = vim_strnsave(s, rsm.sm_match->endp[i] - s);\n    }\n    TV_LIST_ITEM_TV(li)->v_type = VAR_STRING;\n    TV_LIST_ITEM_TV(li)->vval.v_string = s;\n    li = TV_LIST_ITEM_NEXT(argv->vval.v_list, li);\n  }\n  return argskip + 1;\n}\n\nstatic void clear_submatch_list(staticList10_T *sl)\n{\n  TV_LIST_ITER(&sl->sl_list, li, {\n    xfree(TV_LIST_ITEM_TV(li)->vval.v_string);\n  });\n}\n\n/// vim_regsub() - perform substitutions after a vim_regexec() or\n/// vim_regexec_multi() match.\n///\n/// If \"copy\" is true really copy into \"dest\".\n/// If \"copy\" is false nothing is copied, this is just to find out the length\n/// of the result.\n///\n/// If \"backslash\" is true, a backslash will be removed later, need to double\n/// them to keep them, and insert a backslash before a CR to avoid it being\n/// replaced with a line break later.\n///\n/// Note: The matched text must not change between the call of\n/// vim_regexec()/vim_regexec_multi() and vim_regsub()!  It would make the back\n/// references invalid!\n///\n/// Returns the size of the replacement, including terminating NUL.\nint vim_regsub(regmatch_T *rmp, char_u *source, typval_T *expr, char_u *dest,\n               int copy, int magic, int backslash)\n{\n  regexec_T rex_save;\n  bool rex_in_use_save = rex_in_use;\n\n  if (rex_in_use) {\n    // Being called recursively, save the state.\n    rex_save = rex;\n  }\n  rex_in_use = true;\n\n  rex.reg_match = rmp;\n  rex.reg_mmatch = NULL;\n  rex.reg_maxline = 0;\n  rex.reg_buf = curbuf;\n  rex.reg_line_lbr = true;\n  int result = vim_regsub_both(source, expr, dest, copy, magic, backslash);\n\n  rex_in_use = rex_in_use_save;\n  if (rex_in_use) {\n    rex = rex_save;\n  }\n\n  return result;\n}\n\nint vim_regsub_multi(regmmatch_T *rmp, linenr_T lnum, char_u *source, char_u *dest, int copy, int magic, int backslash)\n{\n  regexec_T rex_save;\n  bool rex_in_use_save = rex_in_use;\n\n  if (rex_in_use) {\n    // Being called recursively, save the state.\n    rex_save = rex;\n  }\n  rex_in_use = true;\n\n  rex.reg_match = NULL;\n  rex.reg_mmatch = rmp;\n  rex.reg_buf = curbuf;  // always works on the current buffer!\n  rex.reg_firstlnum = lnum;\n  rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;\n  rex.reg_line_lbr = false;\n  int result = vim_regsub_both(source, NULL, dest, copy, magic, backslash);\n\n  rex_in_use = rex_in_use_save;\n  if (rex_in_use) {\n    rex = rex_save;\n  }\n\n  return result;\n}\n\nstatic int vim_regsub_both(char_u *source, typval_T *expr, char_u *dest,\n                           int copy, int magic, int backslash)\n{\n  char_u      *src;\n  char_u      *dst;\n  char_u      *s;\n  int c;\n  int cc;\n  int no = -1;\n  fptr_T func_all = (fptr_T)NULL;\n  fptr_T func_one = (fptr_T)NULL;\n  linenr_T clnum = 0;           /* init for GCC */\n  int len = 0;                  /* init for GCC */\n  static char_u *eval_result = NULL;\n\n  // We need to keep track of how many backslashes we escape, so that the byte\n  // counts for `extmark_splice` are correct.\n  int num_escaped = 0;\n\n  // Be paranoid...\n  if ((source == NULL && expr == NULL) || dest == NULL) {\n    EMSG(_(e_null));\n    return 0;\n  }\n  if (prog_magic_wrong())\n    return 0;\n  src = source;\n  dst = dest;\n\n  // When the substitute part starts with \"\\=\" evaluate it as an expression.\n  if (expr != NULL || (source[0] == '\\\\' && source[1] == '=')) {\n    // To make sure that the length doesn't change between checking the\n    // length and copying the string, and to speed up things, the\n    // resulting string is saved from the call with \"copy\" == false to the\n    // call with \"copy\" == true.\n    if (copy) {\n      if (eval_result != NULL) {\n        STRCPY(dest, eval_result);\n        dst += STRLEN(eval_result);\n        XFREE_CLEAR(eval_result);\n      }\n    } else {\n      const bool prev_can_f_submatch = can_f_submatch;\n      regsubmatch_T rsm_save;\n\n      xfree(eval_result);\n\n      // The expression may contain substitute(), which calls us\n      // recursively.  Make sure submatch() gets the text from the first\n      // level.\n      if (can_f_submatch) {\n        rsm_save = rsm;\n      }\n      can_f_submatch = true;\n      rsm.sm_match = rex.reg_match;\n      rsm.sm_mmatch = rex.reg_mmatch;\n      rsm.sm_firstlnum = rex.reg_firstlnum;\n      rsm.sm_maxline = rex.reg_maxline;\n      rsm.sm_line_lbr = rex.reg_line_lbr;\n\n      if (expr != NULL) {\n        typval_T argv[2];\n        typval_T rettv;\n        staticList10_T matchList = TV_LIST_STATIC10_INIT;\n        rettv.v_type = VAR_STRING;\n        rettv.vval.v_string = NULL;\n        argv[0].v_type = VAR_LIST;\n        argv[0].vval.v_list = &matchList.sl_list;\n        funcexe_T funcexe = FUNCEXE_INIT;\n        funcexe.argv_func = fill_submatch_list;\n        funcexe.evaluate = true;\n        if (expr->v_type == VAR_FUNC) {\n          s = expr->vval.v_string;\n          call_func(s, -1, &rettv, 1, argv, &funcexe);\n        } else if (expr->v_type == VAR_PARTIAL) {\n          partial_T *partial = expr->vval.v_partial;\n\n          s = partial_name(partial);\n          funcexe.partial = partial;\n          call_func(s, -1, &rettv, 1, argv, &funcexe);\n        }\n        if (tv_list_len(&matchList.sl_list) > 0) {\n          // fill_submatch_list() was called.\n          clear_submatch_list(&matchList);\n        }\n        if (rettv.v_type == VAR_UNKNOWN) {\n          // something failed, no need to report another error\n          eval_result = NULL;\n        } else {\n          char buf[NUMBUFLEN];\n          eval_result = (char_u *)tv_get_string_buf_chk(&rettv, buf);\n          if (eval_result != NULL) {\n            eval_result = vim_strsave(eval_result);\n          }\n        }\n        tv_clear(&rettv);\n      } else {\n        eval_result = eval_to_string(source + 2, NULL, true);\n      }\n\n      if (eval_result != NULL) {\n        int had_backslash = false;\n\n        for (s = eval_result; *s != NUL; MB_PTR_ADV(s)) {\n          // Change NL to CR, so that it becomes a line break,\n          // unless called from vim_regexec_nl().\n          // Skip over a backslashed character.\n          if (*s == NL && !rsm.sm_line_lbr) {\n            *s = CAR;\n          } else if (*s == '\\\\' && s[1] != NUL) {\n            s++;\n            /* Change NL to CR here too, so that this works:\n             * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:\n             *   abc\\\n             *   def\n             * Not when called from vim_regexec_nl().\n             */\n            if (*s == NL && !rsm.sm_line_lbr) {\n              *s = CAR;\n            }\n            had_backslash = true;\n          }\n        }\n        if (had_backslash && backslash) {\n          /* Backslashes will be consumed, need to double them. */\n          s = vim_strsave_escaped(eval_result, (char_u *)\"\\\\\");\n          xfree(eval_result);\n          eval_result = s;\n        }\n\n        dst += STRLEN(eval_result);\n      }\n\n      can_f_submatch = prev_can_f_submatch;\n      if (can_f_submatch) {\n        rsm = rsm_save;\n      }\n    }\n  } else\n    while ((c = *src++) != NUL) {\n      if (c == '&' && magic)\n        no = 0;\n      else if (c == '\\\\' && *src != NUL) {\n        if (*src == '&' && !magic) {\n          ++src;\n          no = 0;\n        } else if ('0' <= *src && *src <= '9') {\n          no = *src++ - '0';\n        } else if (vim_strchr((char_u *)\"uUlLeE\", *src)) {\n          switch (*src++) {\n          case 'u':   func_one = (fptr_T)do_upper;\n            continue;\n          case 'U':   func_all = (fptr_T)do_Upper;\n            continue;\n          case 'l':   func_one = (fptr_T)do_lower;\n            continue;\n          case 'L':   func_all = (fptr_T)do_Lower;\n            continue;\n          case 'e':\n          case 'E':   func_one = func_all = (fptr_T)NULL;\n            continue;\n          }\n        }\n      }\n      if (no < 0) {           /* Ordinary character. */\n        if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL) {\n          /* Copy a special key as-is. */\n          if (copy) {\n            *dst++ = c;\n            *dst++ = *src++;\n            *dst++ = *src++;\n          } else {\n            dst += 3;\n            src += 2;\n          }\n          continue;\n        }\n\n        if (c == '\\\\' && *src != NUL) {\n          // Check for abbreviations -- webb\n          switch (*src) {\n          case 'r':   c = CAR;        ++src;  break;\n          case 'n':   c = NL;         ++src;  break;\n          case 't':   c = TAB;        ++src;  break;\n          // Oh no!  \\e already has meaning in subst pat :-(\n          // case 'e':   c = ESC;        ++src;  break;\n          case 'b':   c = Ctrl_H;     ++src;  break;\n\n          // If \"backslash\" is true the backslash will be removed\n          // later.  Used to insert a literal CR.\n          default:\n            if (backslash) {\n              num_escaped += 1;\n              if (copy) {\n                *dst = '\\\\';\n              }\n              dst++;\n            }\n            c = *src++;\n          }\n        } else {\n          c = utf_ptr2char(src - 1);\n        }\n        // Write to buffer, if copy is set.\n        if (func_one != NULL) {\n          func_one = (fptr_T)(func_one(&cc, c));\n        } else if (func_all != NULL) {\n          func_all = (fptr_T)(func_all(&cc, c));\n        } else {\n          // just copy\n          cc = c;\n        }\n\n        int totlen = utfc_ptr2len(src - 1);\n\n        if (copy) {\n          utf_char2bytes(cc, dst);\n        }\n        dst += utf_char2len(cc) - 1;\n        int clen = utf_ptr2len(src - 1);\n\n        // If the character length is shorter than \"totlen\", there\n        // are composing characters; copy them as-is.\n        if (clen < totlen) {\n          if (copy) {\n            memmove(dst + 1, src - 1 + clen, (size_t)(totlen - clen));\n          }\n          dst += totlen - clen;\n        }\n        src += totlen - 1;\n        dst++;\n      } else {\n        if (REG_MULTI) {\n          clnum = rex.reg_mmatch->startpos[no].lnum;\n          if (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0) {\n            s = NULL;\n          } else {\n            s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;\n            if (rex.reg_mmatch->endpos[no].lnum == clnum) {\n              len = rex.reg_mmatch->endpos[no].col\n                    - rex.reg_mmatch->startpos[no].col;\n            } else {\n              len = (int)STRLEN(s);\n            }\n          }\n        } else {\n          s = rex.reg_match->startp[no];\n          if (rex.reg_match->endp[no] == NULL) {\n            s = NULL;\n          } else {\n            len = (int)(rex.reg_match->endp[no] - s);\n          }\n        }\n        if (s != NULL) {\n          for (;; ) {\n            if (len == 0) {\n              if (REG_MULTI) {\n                if (rex.reg_mmatch->endpos[no].lnum == clnum) {\n                  break;\n                }\n                if (copy) {\n                  *dst = CAR;\n                }\n                dst++;\n                s = reg_getline(++clnum);\n                if (rex.reg_mmatch->endpos[no].lnum == clnum) {\n                  len = rex.reg_mmatch->endpos[no].col;\n                } else {\n                  len = (int)STRLEN(s);\n                }\n              } else {\n                break;\n              }\n            } else if (*s == NUL) {  // we hit NUL.\n              if (copy) {\n                IEMSG(_(e_re_damg));\n              }\n              goto exit;\n            } else {\n              if (backslash && (*s == CAR || *s == '\\\\')) {\n                /*\n                 * Insert a backslash in front of a CR, otherwise\n                 * it will be replaced by a line break.\n                 * Number of backslashes will be halved later,\n                 * double them here.\n                 */\n                if (copy) {\n                  dst[0] = '\\\\';\n                  dst[1] = *s;\n                }\n                dst += 2;\n              } else {\n                c = utf_ptr2char(s);\n\n                if (func_one != (fptr_T)NULL)\n                  /* Turbo C complains without the typecast */\n                  func_one = (fptr_T)(func_one(&cc, c));\n                else if (func_all != (fptr_T)NULL)\n                  /* Turbo C complains without the typecast */\n                  func_all = (fptr_T)(func_all(&cc, c));\n                else             /* just copy */\n                  cc = c;\n\n                {\n                  int l;\n\n                  // Copy composing characters separately, one\n                  // at a time.\n                  l = utf_ptr2len(s) - 1;\n\n                  s += l;\n                  len -= l;\n                  if (copy) {\n                    utf_char2bytes(cc, dst);\n                  }\n                  dst += utf_char2len(cc) - 1;\n                }\n                dst++;\n              }\n\n              ++s;\n              --len;\n            }\n          }\n        }\n        no = -1;\n      }\n    }\n  if (copy)\n    *dst = NUL;\n\nexit:\n  return (int)((dst - dest) + 1 - num_escaped);\n}\n\n\n/*\n * Call reg_getline() with the line numbers from the submatch.  If a\n * substitute() was used the reg_maxline and other values have been\n * overwritten.\n */\nstatic char_u *reg_getline_submatch(linenr_T lnum)\n{\n  char_u *s;\n  linenr_T save_first = rex.reg_firstlnum;\n  linenr_T save_max = rex.reg_maxline;\n\n  rex.reg_firstlnum = rsm.sm_firstlnum;\n  rex.reg_maxline = rsm.sm_maxline;\n\n  s = reg_getline(lnum);\n\n  rex.reg_firstlnum = save_first;\n  rex.reg_maxline = save_max;\n  return s;\n}\n\n/*\n * Used for the submatch() function: get the string from the n'th submatch in\n * allocated memory.\n * Returns NULL when not in a \":s\" command and for a non-existing submatch.\n */\nchar_u *reg_submatch(int no)\n{\n  char_u      *retval = NULL;\n  char_u      *s;\n  int round;\n  linenr_T lnum;\n\n  if (!can_f_submatch || no < 0)\n    return NULL;\n\n  if (rsm.sm_match == NULL) {\n    ssize_t len;\n\n    /*\n     * First round: compute the length and allocate memory.\n     * Second round: copy the text.\n     */\n    for (round = 1; round <= 2; round++) {\n      lnum = rsm.sm_mmatch->startpos[no].lnum;\n      if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0) {\n        return NULL;\n      }\n\n      s = reg_getline_submatch(lnum);\n      if (s == NULL) {  // anti-crash check, cannot happen?\n        break;\n      }\n      s += rsm.sm_mmatch->startpos[no].col;\n      if (rsm.sm_mmatch->endpos[no].lnum == lnum) {\n        // Within one line: take form start to end col.\n        len = rsm.sm_mmatch->endpos[no].col - rsm.sm_mmatch->startpos[no].col;\n        if (round == 2) {\n          STRLCPY(retval, s, len + 1);\n        }\n        len++;\n      } else {\n        // Multiple lines: take start line from start col, middle\n        // lines completely and end line up to end col.\n        len = (ssize_t)STRLEN(s);\n        if (round == 2) {\n          STRCPY(retval, s);\n          retval[len] = '\\n';\n        }\n        len++;\n        lnum++;\n        while (lnum < rsm.sm_mmatch->endpos[no].lnum) {\n          s = reg_getline_submatch(lnum++);\n          if (round == 2)\n            STRCPY(retval + len, s);\n          len += STRLEN(s);\n          if (round == 2)\n            retval[len] = '\\n';\n          ++len;\n        }\n        if (round == 2) {\n          STRNCPY(retval + len, reg_getline_submatch(lnum),\n                  rsm.sm_mmatch->endpos[no].col);\n        }\n        len += rsm.sm_mmatch->endpos[no].col;\n        if (round == 2) {\n          retval[len] = NUL;  // -V595\n        }\n        len++;\n      }\n\n      if (retval == NULL) {\n        retval = xmalloc(len);\n      }\n    }\n  } else {\n    s = rsm.sm_match->startp[no];\n    if (s == NULL || rsm.sm_match->endp[no] == NULL) {\n      retval = NULL;\n    } else {\n      retval = vim_strnsave(s, rsm.sm_match->endp[no] - s);\n    }\n  }\n\n  return retval;\n}\n\n// Used for the submatch() function with the optional non-zero argument: get\n// the list of strings from the n'th submatch in allocated memory with NULs\n// represented in NLs.\n// Returns a list of allocated strings.  Returns NULL when not in a \":s\"\n// command, for a non-existing submatch and for any error.\nlist_T *reg_submatch_list(int no)\n{\n  if (!can_f_submatch || no < 0) {\n    return NULL;\n  }\n\n  linenr_T slnum;\n  linenr_T elnum;\n  list_T *list;\n  const char *s;\n\n  if (rsm.sm_match == NULL) {\n    slnum = rsm.sm_mmatch->startpos[no].lnum;\n    elnum = rsm.sm_mmatch->endpos[no].lnum;\n    if (slnum < 0 || elnum < 0) {\n      return NULL;\n    }\n\n    colnr_T scol = rsm.sm_mmatch->startpos[no].col;\n    colnr_T ecol = rsm.sm_mmatch->endpos[no].col;\n\n    list = tv_list_alloc(elnum - slnum + 1);\n\n    s = (const char *)reg_getline_submatch(slnum) + scol;\n    if (slnum == elnum) {\n      tv_list_append_string(list, s, ecol - scol);\n    } else {\n      tv_list_append_string(list, s, -1);\n      for (int i = 1; i < elnum - slnum; i++) {\n        s = (const char *)reg_getline_submatch(slnum + i);\n        tv_list_append_string(list, s, -1);\n      }\n      s = (const char *)reg_getline_submatch(elnum);\n      tv_list_append_string(list, s, ecol);\n    }\n  } else {\n    s = (const char *)rsm.sm_match->startp[no];\n    if (s == NULL || rsm.sm_match->endp[no] == NULL) {\n      return NULL;\n    }\n    list = tv_list_alloc(1);\n    tv_list_append_string(list, s, (const char *)rsm.sm_match->endp[no] - s);\n  }\n\n  tv_list_ref(list);\n  return list;\n}\n\nstatic regengine_T bt_regengine =\n{\n  bt_regcomp,\n  bt_regfree,\n  bt_regexec_nl,\n  bt_regexec_multi,\n  (char_u *)\"\"\n};\n\n\n// XXX Do not allow headers generator to catch definitions from regexp_nfa.c\n#ifndef DO_NOT_DEFINE_EMPTY_ATTRIBUTES\n# include \"nvim/regexp_nfa.c\"\n#endif\n\nstatic regengine_T nfa_regengine =\n{\n  nfa_regcomp,\n  nfa_regfree,\n  nfa_regexec_nl,\n  nfa_regexec_multi,\n  (char_u *)\"\"\n};\n\n/* Which regexp engine to use? Needed for vim_regcomp().\n * Must match with 'regexpengine'. */\nstatic int regexp_engine = 0;\n\n#ifdef REGEXP_DEBUG\nstatic char_u regname[][30] = {\n  \"AUTOMATIC Regexp Engine\",\n  \"BACKTRACKING Regexp Engine\",\n  \"NFA Regexp Engine\"\n};\n#endif\n\n/*\n * Compile a regular expression into internal code.\n * Returns the program in allocated memory.\n * Use vim_regfree() to free the memory.\n * Returns NULL for an error.\n */\nregprog_T *vim_regcomp(char_u *expr_arg, int re_flags)\n{\n  regprog_T   *prog = NULL;\n  char_u      *expr = expr_arg;\n  int          save_called_emsg;\n\n  regexp_engine = p_re;\n\n  /* Check for prefix \"\\%#=\", that sets the regexp engine */\n  if (STRNCMP(expr, \"\\\\%#=\", 4) == 0) {\n    int newengine = expr[4] - '0';\n\n    if (newengine == AUTOMATIC_ENGINE\n        || newengine == BACKTRACKING_ENGINE\n        || newengine == NFA_ENGINE) {\n      regexp_engine = expr[4] - '0';\n      expr += 5;\n#ifdef REGEXP_DEBUG\n      smsg(\"New regexp mode selected (%d): %s\",\n           regexp_engine,\n           regname[newengine]);\n#endif\n    } else {\n      EMSG(_(\n              \"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used \"));\n      regexp_engine = AUTOMATIC_ENGINE;\n    }\n  }\n#ifdef REGEXP_DEBUG\n  bt_regengine.expr = expr;\n  nfa_regengine.expr = expr;\n#endif\n  // reg_iswordc() uses rex.reg_buf\n  rex.reg_buf = curbuf;\n\n  //\n  // First try the NFA engine, unless backtracking was requested.\n  //\n  save_called_emsg = called_emsg;\n  called_emsg = false;\n  if (regexp_engine != BACKTRACKING_ENGINE) {\n    prog = nfa_regengine.regcomp(expr,\n        re_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n  } else {\n    prog = bt_regengine.regcomp(expr, re_flags);\n  }\n\n  // Check for error compiling regexp with initial engine.\n  if (prog == NULL) {\n#ifdef BT_REGEXP_DEBUG_LOG\n    // Debugging log for BT engine.\n    if (regexp_engine != BACKTRACKING_ENGINE) {\n      FILE *f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \"a\");\n      if (f) {\n        fprintf(f, \"Syntax error in \\\"%s\\\"\\n\", expr);\n        fclose(f);\n      } else\n        EMSG2(\"(NFA) Could not open \\\"%s\\\" to write !!!\",\n            BT_REGEXP_DEBUG_LOG_NAME);\n    }\n#endif\n    // If the NFA engine failed, try the backtracking engine. The NFA engine\n    // also fails for patterns that it can't handle well but are still valid\n    // patterns, thus a retry should work.\n    // But don't try if an error message was given.\n    if (regexp_engine == AUTOMATIC_ENGINE && !called_emsg) {\n      regexp_engine = BACKTRACKING_ENGINE;\n      report_re_switch(expr);\n      prog = bt_regengine.regcomp(expr, re_flags);\n    }\n  }\n  called_emsg |= save_called_emsg;\n\n  if (prog != NULL) {\n    // Store the info needed to call regcomp() again when the engine turns out\n    // to be very slow when executing it.\n    prog->re_engine = regexp_engine;\n    prog->re_flags = re_flags;\n  }\n\n  return prog;\n}\n\n/*\n * Free a compiled regexp program, returned by vim_regcomp().\n */\nvoid vim_regfree(regprog_T *prog)\n{\n  if (prog != NULL)\n    prog->engine->regfree(prog);\n}\n\nstatic void report_re_switch(char_u *pat)\n{\n  if (p_verbose > 0) {\n    verbose_enter();\n    MSG_PUTS(_(\"Switching to backtracking RE engine for pattern: \"));\n    MSG_PUTS(pat);\n    verbose_leave();\n  }\n}\n\n/// Matches a regexp against a string.\n/// \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n/// Note: \"rmp->regprog\" may be freed and changed.\n/// Uses curbuf for line count and 'iskeyword'.\n/// When \"nl\" is true consider a \"\\n\" in \"line\" to be a line break.\n///\n/// @param rmp\n/// @param line the string to match against\n/// @param col  the column to start looking for match\n/// @param nl\n///\n/// @return true if there is a match, false if not.\nstatic bool vim_regexec_string(regmatch_T *rmp, char_u *line, colnr_T col,\n                               bool nl)\n{\n  regexec_T rex_save;\n  bool rex_in_use_save = rex_in_use;\n\n  // Cannot use the same prog recursively, it contains state.\n  if (rmp->regprog->re_in_use) {\n    EMSG(_(e_recursive));\n    return false;\n  }\n  rmp->regprog->re_in_use = true;\n\n  if (rex_in_use) {\n    // Being called recursively, save the state.\n    rex_save = rex;\n  }\n  rex_in_use = true;\n\n  rex.reg_startp = NULL;\n  rex.reg_endp = NULL;\n  rex.reg_startpos = NULL;\n  rex.reg_endpos = NULL;\n\n  int result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n  rmp->regprog->re_in_use = false;\n\n  // NFA engine aborted because it's very slow, use backtracking engine instead.\n  if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n      && result == NFA_TOO_EXPENSIVE) {\n    int save_p_re = p_re;\n    int re_flags = rmp->regprog->re_flags;\n    char_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n    p_re = BACKTRACKING_ENGINE;\n    vim_regfree(rmp->regprog);\n    report_re_switch(pat);\n    rmp->regprog = vim_regcomp(pat, re_flags);\n    if (rmp->regprog != NULL) {\n      rmp->regprog->re_in_use = true;\n      result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n      rmp->regprog->re_in_use = false;\n    }\n\n    xfree(pat);\n    p_re = save_p_re;\n  }\n\n  rex_in_use = rex_in_use_save;\n  if (rex_in_use) {\n    rex = rex_save;\n  }\n\n  return result > 0;\n}\n\n// Note: \"*prog\" may be freed and changed.\n// Return true if there is a match, false if not.\nbool vim_regexec_prog(regprog_T **prog, bool ignore_case, char_u *line,\n                      colnr_T col)\n{\n  regmatch_T regmatch = { .regprog = *prog, .rm_ic = ignore_case };\n  bool r = vim_regexec_string(&regmatch, line, col, false);\n  *prog = regmatch.regprog;\n  return r;\n}\n\n// Note: \"rmp->regprog\" may be freed and changed.\n// Return true if there is a match, false if not.\nbool vim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n  return vim_regexec_string(rmp, line, col, false);\n}\n\n// Like vim_regexec(), but consider a \"\\n\" in \"line\" to be a line break.\n// Note: \"rmp->regprog\" may be freed and changed.\n// Return true if there is a match, false if not.\nbool vim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n  return vim_regexec_string(rmp, line, col, true);\n}\n\n/// Match a regexp against multiple lines.\n/// \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n/// Note: \"rmp->regprog\" may be freed and changed, even set to NULL.\n/// Uses curbuf for line count and 'iskeyword'.\n///\n/// Return zero if there is no match.  Return number of lines contained in the\n/// match otherwise.\nlong vim_regexec_multi(\n    regmmatch_T *rmp,\n    win_T       *win,               // window in which to search or NULL\n    buf_T       *buf,               // buffer in which to search\n    linenr_T lnum,                  // nr of line to start looking for match\n    colnr_T col,                    // column to start looking for match\n    proftime_T  *tm,                // timeout limit or NULL\n    int         *timed_out          // flag is set when timeout limit reached\n)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  regexec_T rex_save;\n  bool rex_in_use_save = rex_in_use;\n\n  // Cannot use the same prog recursively, it contains state.\n  if (rmp->regprog->re_in_use) {\n    EMSG(_(e_recursive));\n    return false;\n  }\n  rmp->regprog->re_in_use = true;\n\n  if (rex_in_use) {\n    // Being called recursively, save the state.\n    rex_save = rex;\n  }\n  rex_in_use = true;\n\n  int result = rmp->regprog->engine->regexec_multi(rmp, win, buf, lnum, col,\n                                                   tm, timed_out);\n  rmp->regprog->re_in_use = false;\n\n  // NFA engine aborted because it's very slow, use backtracking engine instead.\n  if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n      && result == NFA_TOO_EXPENSIVE) {\n    int save_p_re = p_re;\n    int re_flags = rmp->regprog->re_flags;\n    char_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n    p_re = BACKTRACKING_ENGINE;\n    vim_regfree(rmp->regprog);\n    report_re_switch(pat);\n    // checking for \\z misuse was already done when compiling for NFA,\n    // allow all here\n    reg_do_extmatch = REX_ALL;\n    rmp->regprog = vim_regcomp(pat, re_flags);\n    reg_do_extmatch = 0;\n\n    if (rmp->regprog != NULL) {\n      rmp->regprog->re_in_use = true;\n      result = rmp->regprog->engine->regexec_multi(rmp, win, buf, lnum, col,\n                                                   tm, timed_out);\n      rmp->regprog->re_in_use = false;\n    }\n\n    xfree(pat);\n    p_re = save_p_re;\n  }\n\n  rex_in_use = rex_in_use_save;\n  if (rex_in_use) {\n    rex = rex_save;\n  }\n\n  return result <= 0 ? 0 : result;\n}\n"}, "1": {"id": 1, "path": "src/nvim/vim.h", "content": "#ifndef NVIM_VIM_H\n#define NVIM_VIM_H\n\n#include \"nvim/types.h\"\n#include \"nvim/pos.h\"  // for linenr_T, MAXCOL, etc...\n\n// Some defines from the old feature.h\n#define SESSION_FILE \"Session.vim\"\n#define MAX_MSG_HIST_LEN 200\n#define SYS_OPTWIN_FILE \"$VIMRUNTIME/optwin.vim\"\n#define RUNTIME_DIRNAME \"runtime\"\n\n\n#include \"auto/config.h\"\n#define HAVE_PATHDEF\n\n// Check if configure correctly managed to find sizeof(int).  If this failed,\n// it becomes zero.  This is likely a problem of not being able to run the\n// test program.  Other items from configure may also be wrong then!\n#if (SIZEOF_INT == 0)\n# error Configure did not run properly.\n#endif\n\n#include \"nvim/os/os_defs.h\"       // bring lots of system header files\n\n/// length of a buffer to store a number in ASCII (64 bits binary + NUL)\nenum { NUMBUFLEN = 65 };\n\n#define MAX_TYPENR 65535\n\n#define ROOT_UID 0\n\n#include \"nvim/keymap.h\"\n#include \"nvim/macros.h\"\n\n#include \"nvim/gettext.h\"\n\n// special attribute addition: Put message in history\n#define MSG_HIST                0x1000\n\n\n// values for State\n//\n// The lower bits up to 0x20 are used to distinguish normal/visual/op_pending\n// and cmdline/insert+replace mode.  This is used for mapping.  If none of\n// these bits are set, no mapping is done.\n// The upper bits are used to distinguish between other states.\n\n#define NORMAL          0x01    // Normal mode, command expected\n#define VISUAL          0x02    // Visual mode - use get_real_state()\n#define OP_PENDING      0x04    // Normal mode, operator is pending - use\n                                // get_real_state()\n#define CMDLINE         0x08    // Editing command line\n#define INSERT          0x10    // Insert mode\n#define LANGMAP         0x20    // Language mapping, can be combined with\n                                // INSERT and CMDLINE\n\n#define REPLACE_FLAG    0x40    // Replace mode flag\n#define REPLACE         (REPLACE_FLAG + INSERT)\n# define VREPLACE_FLAG  0x80    // Virtual-replace mode flag\n# define VREPLACE       (REPLACE_FLAG + VREPLACE_FLAG + INSERT)\n#define LREPLACE        (REPLACE_FLAG + LANGMAP)\n\n#define NORMAL_BUSY     (0x100 + NORMAL)  // Normal mode, busy with a command\n#define HITRETURN       (0x200 + NORMAL)  // waiting for return or command\n#define ASKMORE         0x300   // Asking if you want --more--\n#define SETWSIZE        0x400   // window size has changed\n#define ABBREV          0x500   // abbreviation instead of mapping\n#define EXTERNCMD       0x600   // executing an external command\n#define SHOWMATCH       (0x700 + INSERT)  // show matching paren\n#define CONFIRM         0x800   // \":confirm\" prompt\n#define SELECTMODE      0x1000  // Select mode, only for mappings\n#define TERM_FOCUS      0x2000  // Terminal focus mode\n#define CMDPREVIEW      0x4000  // Showing 'inccommand' command \"live\" preview.\n\n// all mode bits used for mapping\n#define MAP_ALL_MODES   (0x3f | SELECTMODE | TERM_FOCUS)\n\n/// Directions.\ntypedef enum {\n  kDirectionNotSet = 0,\n  FORWARD = 1,\n  BACKWARD = (-1),\n  FORWARD_FILE = 3,\n  BACKWARD_FILE = (-3),\n} Direction;\n\n// return values for functions\n#if !(defined(OK) && (OK == 1))\n// OK already defined to 1 in MacOS X curses, skip this\n# define OK                     1\n#endif\n#define FAIL                    0\n#define NOTDONE                 2   // not OK or FAIL but skipped\n\n// Type values for type().\n#define VAR_TYPE_NUMBER     0\n#define VAR_TYPE_STRING     1\n#define VAR_TYPE_FUNC       2\n#define VAR_TYPE_LIST       3\n#define VAR_TYPE_DICT       4\n#define VAR_TYPE_FLOAT      5\n#define VAR_TYPE_BOOL       6\n#define VAR_TYPE_SPECIAL    7\n#define VAR_TYPE_BLOB      10\n\n\n// values for xp_context when doing command line completion\n\nenum {\n  EXPAND_UNSUCCESSFUL = -2,\n  EXPAND_OK = -1,\n  EXPAND_NOTHING = 0,\n  EXPAND_COMMANDS,\n  EXPAND_FILES,\n  EXPAND_DIRECTORIES,\n  EXPAND_SETTINGS,\n  EXPAND_BOOL_SETTINGS,\n  EXPAND_TAGS,\n  EXPAND_OLD_SETTING,\n  EXPAND_HELP,\n  EXPAND_BUFFERS,\n  EXPAND_EVENTS,\n  EXPAND_MENUS,\n  EXPAND_SYNTAX,\n  EXPAND_HIGHLIGHT,\n  EXPAND_AUGROUP,\n  EXPAND_USER_VARS,\n  EXPAND_MAPPINGS,\n  EXPAND_TAGS_LISTFILES,\n  EXPAND_FUNCTIONS,\n  EXPAND_USER_FUNC,\n  EXPAND_EXPRESSION,\n  EXPAND_MENUNAMES,\n  EXPAND_USER_COMMANDS,\n  EXPAND_USER_CMD_FLAGS,\n  EXPAND_USER_NARGS,\n  EXPAND_USER_COMPLETE,\n  EXPAND_ENV_VARS,\n  EXPAND_LANGUAGE,\n  EXPAND_COLORS,\n  EXPAND_COMPILER,\n  EXPAND_USER_DEFINED,\n  EXPAND_USER_LIST,\n  EXPAND_SHELLCMD,\n  EXPAND_CSCOPE,\n  EXPAND_SIGN,\n  EXPAND_PROFILE,\n  EXPAND_BEHAVE,\n  EXPAND_FILETYPE,\n  EXPAND_FILES_IN_PATH,\n  EXPAND_OWNSYNTAX,\n  EXPAND_LOCALES,\n  EXPAND_HISTORY,\n  EXPAND_USER,\n  EXPAND_SYNTIME,\n  EXPAND_USER_ADDR_TYPE,\n  EXPAND_PACKADD,\n  EXPAND_MESSAGES,\n  EXPAND_MAPCLEAR,\n  EXPAND_ARGLIST,\n  EXPAND_DIFF_BUFFERS,\n  EXPAND_CHECKHEALTH,\n  EXPAND_LUA,\n};\n\n\n\n\n// Minimal size for block 0 of a swap file.\n// NOTE: This depends on size of struct block0! It's not done with a sizeof(),\n// because struct block0 is defined in memline.c (Sorry).\n// The maximal block size is arbitrary.\n\n#define MIN_SWAP_PAGE_SIZE 1048\n#define MAX_SWAP_PAGE_SIZE 50000\n\n\n\n// Boolean constants\n\n#ifndef TRUE\n# define FALSE  0           // note: this is an int, not a long!\n# define TRUE   1\n#endif\n\n#define MAYBE   2           // sometimes used for a variant on TRUE\n\n#define STATUS_HEIGHT   1       // height of a status line under a window\n#define QF_WINHEIGHT    10      // default height for quickfix window\n\n\n// Buffer sizes\n\n#ifndef CMDBUFFSIZE\n# define CMDBUFFSIZE    256     // size of the command processing buffer\n#endif\n\n#define LSIZE       512         // max. size of a line in the tags file\n\n#define DIALOG_MSG_SIZE 1000    // buffer size for dialog_msg()\n\nenum { FOLD_TEXT_LEN = 51 };  //!< buffer size for get_foldtext()\n\n\n// Maximum length of key sequence to be mapped.\n// Must be able to hold an Amiga resize report.\n\n#define MAXMAPLEN   50\n\n// Size in bytes of the hash used in the undo file.\n#define UNDO_HASH_SIZE 32\n\n#define CLEAR_POINTER(ptr)  memset((ptr), 0, sizeof(*(ptr)))\n\n// defines to avoid typecasts from (char_u *) to (char *) and back\n// (vim_strchr() is now in strings.c)\n\n#define STRLEN(s)           strlen((char *)(s))\n#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))\n#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))\n#define STRCMP(d, s)        strcmp((char *)(d), (char *)(s))\n#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))\n#ifdef HAVE_STRCASECMP\n# define STRICMP(d, s)      strcasecmp((char *)(d), (char *)(s))\n#else\n# ifdef HAVE_STRICMP\n#  define STRICMP(d, s)     stricmp((char *)(d), (char *)(s))\n# else\n#  define STRICMP(d, s)     vim_stricmp((char *)(d), (char *)(s))\n# endif\n#endif\n\n// Like strcpy() but allows overlapped source and destination.\n#define STRMOVE(d, s)       memmove((d), (s), STRLEN(s) + 1)\n\n#ifdef HAVE_STRNCASECMP\n# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))\n#else\n# ifdef HAVE_STRNICMP\n#  define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# else\n#  define STRNICMP(d, s, n) vim_strnicmp((char *)(d), (char *)(s), (size_t)(n))\n# endif\n#endif\n\n#define STRRCHR(s, c)       (char_u *)strrchr((const char *)(s), (c))\n\n#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))\n#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))\n#define STRLCAT(d, s, n)    xstrlcat((char *)(d), (char *)(s), (size_t)(n))\n\n# define vim_strpbrk(s, cs) (char_u *)strpbrk((char *)(s), (char *)(cs))\n\n// Character used as separated in autoload function/variable names.\n#define AUTOLOAD_CHAR '#'\n\n#include \"nvim/message.h\"\n\n// Prefer using emsgf(), because perror() may send the output to the wrong\n// destination and mess up the screen.\n#define PERROR(msg) (void) emsgf(\"%s: %s\", msg, strerror(errno))\n\n#define SHOWCMD_COLS 10                 // columns needed by shown command\n\n#include \"nvim/path.h\"\n\n/// Compare file names\n///\n/// On some systems case in a file name does not matter, on others it does.\n///\n/// @note Does not account for maximum name lengths and things like \"../dir\",\n///       thus it is not 100% accurate. OS may also use different algorithm for\n///       case-insensitive comparison.\n///\n/// @param[in]  x  First file name to compare.\n/// @param[in]  y  Second file name to compare.\n///\n/// @return 0 for equal file names, non-zero otherwise.\n#define fnamecmp(x, y) path_fnamecmp((const char *)(x), (const char *)(y))\n#define fnamencmp(x, y, n) path_fnamencmp((const char *)(x), \\\n                                          (const char *)(y), \\\n                                          (size_t)(n))\n\n\n// Enums need a typecast to be used as array index (for Ultrix).\n#define HL_ATTR(n)      highlight_attr[(int)(n)]\n\n/// Maximum number of bytes in a multi-byte character.  It can be one 32-bit\n/// character of up to 6 bytes, or one 16-bit character of up to three bytes\n/// plus six following composing characters of three bytes each.\n#define MB_MAXBYTES    21\n\n// This has to go after the include of proto.h, as proto/gui.pro declares\n// functions of these names. The declarations would break if the defines had\n// been seen at that stage.  But it must be before globals.h, where error_ga\n// is declared.\n#ifndef WIN32\n# define mch_errmsg(str)        fprintf(stderr, \"%s\", (str))\n# define mch_msg(str)           printf(\"%s\", (str))\n#endif\n\n#include \"nvim/globals.h\"        // global variables and messages\n#include \"nvim/buffer_defs.h\"    // buffer and windows\n#include \"nvim/ex_cmds_defs.h\"   // Ex command defines\n\n// Used for flags in do_in_path()\n#define DIP_ALL 0x01    // all matches, not just the first one\n#define DIP_DIR 0x02    // find directories instead of files\n#define DIP_ERR 0x04    // give an error message when none found\n#define DIP_START 0x08  // also use \"start\" directory in 'packpath'\n#define DIP_OPT 0x10    // also use \"opt\" directory in 'packpath'\n#define DIP_NORTP 0x20  // do not use 'runtimepath'\n#define DIP_NOAFTER 0x40  // skip \"after\" directories\n#define DIP_AFTER   0x80  // only use \"after\" directories\n#define DIP_LUA  0x100    // also use \".lua\" files\n#define DIP_DIRFILE 0x200  // find both files and directories\n\n// Lowest number used for window ID. Cannot have this many windows per tab.\n#define LOWEST_WIN_ID 1000\n\n// BSD is supposed to cover FreeBSD and similar systems.\n#if (defined(BSD) || defined(__FreeBSD_kernel__)) \\\n    && (defined(S_ISCHR) || defined(S_IFCHR))\n# define OPEN_CHR_FILES\n#endif\n\n// Replacement for nchar used by nv_replace().\n#define REPLACE_CR_NCHAR    -1\n#define REPLACE_NL_NCHAR    -2\n\n#endif  // NVIM_VIM_H\n"}}, "reports": [{"events": [{"location": {"col": 25, "file": 0, "line": 203}, "message": "(           ) (fixit)"}, {"location": {"col": 29, "file": 0, "line": 203}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d870ef9aea31460b1f698b2aa1fd63d9", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 25, "file": 0, "line": 234}, "message": "(              ) (fixit)"}, {"location": {"col": 32, "file": 0, "line": 234}, "message": "macro replacement list should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7ced7330393f9754619559d69dac240c", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 3, "file": 0, "line": 330}, "message": "kRsNopen (fixit)"}, {"location": {"col": 3, "file": 0, "line": 330}, "message": "invalid case style for enum constant 'RS_NOPEN'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bff461092c3a13802ae4c6a40c0e961d", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 331}, "message": "kRsMopen (fixit)"}, {"location": {"col": 5, "file": 0, "line": 331}, "message": "invalid case style for enum constant 'RS_MOPEN'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "73a353af0251326a6a3c71a153a68b10", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 332}, "message": "kRsMclose (fixit)"}, {"location": {"col": 5, "file": 0, "line": 332}, "message": "invalid case style for enum constant 'RS_MCLOSE'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0f22a0e73f59db01ef922936edb543e2", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 333}, "message": "kRsZopen (fixit)"}, {"location": {"col": 5, "file": 0, "line": 333}, "message": "invalid case style for enum constant 'RS_ZOPEN'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f80949a5e5a296df2ccb2007ecf50dcf", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 334}, "message": "kRsZclose (fixit)"}, {"location": {"col": 5, "file": 0, "line": 334}, "message": "invalid case style for enum constant 'RS_ZCLOSE'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6966cf532919c82bb9bf8f2e49f72b9f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 335}, "message": "kRsBranch (fixit)"}, {"location": {"col": 5, "file": 0, "line": 335}, "message": "invalid case style for enum constant 'RS_BRANCH'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "cc3a967837a39478a56bdec1020447c8", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 336}, "message": "kRsBrcplxMore (fixit)"}, {"location": {"col": 5, "file": 0, "line": 336}, "message": "invalid case style for enum constant 'RS_BRCPLX_MORE'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2406b0ae032d69571f9de7caf48cc3d9", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 337}, "message": "kRsBrcplxLong (fixit)"}, {"location": {"col": 5, "file": 0, "line": 337}, "message": "invalid case style for enum constant 'RS_BRCPLX_LONG'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0aaa56136e94d02fa8ade2d9391f2fc9", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 338}, "message": "kRsBrcplxShort (fixit)"}, {"location": {"col": 5, "file": 0, "line": 338}, "message": "invalid case style for enum constant 'RS_BRCPLX_SHORT'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f684d404eab7363c5e6bb41a0d3bcc14", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 339}, "message": "kRsNomatch (fixit)"}, {"location": {"col": 5, "file": 0, "line": 339}, "message": "invalid case style for enum constant 'RS_NOMATCH'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4fd301e2625ebc5092be334fb8bcd253", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 340}, "message": "kRsBehinD1 (fixit)"}, {"location": {"col": 5, "file": 0, "line": 340}, "message": "invalid case style for enum constant 'RS_BEHIND1'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a03c7363095795846a5b7148cce0ca34", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 341}, "message": "kRsBehinD2 (fixit)"}, {"location": {"col": 5, "file": 0, "line": 341}, "message": "invalid case style for enum constant 'RS_BEHIND2'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bcbdaf7162f29db886b49c9a5e0aa248", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 342}, "message": "kRsStarLong (fixit)"}, {"location": {"col": 5, "file": 0, "line": 342}, "message": "invalid case style for enum constant 'RS_STAR_LONG'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "81b183175602eaaa834aaf935317a82f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 343}, "message": "kRsStarShort (fixit)"}, {"location": {"col": 5, "file": 0, "line": 343}, "message": "invalid case style for enum constant 'RS_STAR_SHORT'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1e7c873fc838e19e1da11f892cf2c3fa", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 389}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 389}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e0b47f25abbdcb598a3cf36e3e2348bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 389}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 389}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f96bfb358823b0f2531934435339fa77", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 396}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 396}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e0b47f25abbdcb598a3cf36e3e2348bd", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 396}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 396}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f96bfb358823b0f2531934435339fa77", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 0, "line": 506}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 0, "line": 506}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5cef3c188bf28e1413f2e50294546d40", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 0, "line": 506}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 0, "line": 506}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a80a2f2be1718e777338918816f8d36e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 0, "line": 508}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 0, "line": 508}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b8d578372305432116a82f996c8323bf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 62, "file": 0, "line": 508}, "message": "{ (fixit)"}, {"location": {"col": 61, "file": 0, "line": 508}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "eb6be611bdb47e73bf09e5cb4ef123b1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 547}, "message": "regexp_inrange (fixit)"}, {"location": {"col": 15, "file": 0, "line": 547}, "message": "invalid case style for variable 'REGEXP_INRANGE'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "640c0f8e163022336cc21fdd9eb11d7f", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 548}, "message": "regexp_abbr (fixit)"}, {"location": {"col": 15, "file": 0, "line": 548}, "message": "invalid case style for variable 'REGEXP_ABBR'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8501b6636a101c6421426d32eb43a35c", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 0, "line": 617}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 0, "line": 617}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9918c3ef966ef090a35185dd5df81eff", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 0, "line": 617}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 0, "line": 617}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "feffe09282d6fd0699cfcd0f1fd742db", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 647}, "message": "{ (fixit)"}, {"location": {"col": 12, "file": 0, "line": 647}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b9a30983aaa575fbd1acb5d45c7682c1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 647}, "message": "{ (fixit)"}, {"location": {"col": 12, "file": 0, "line": 647}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c311503b77496459a669869e58e2c75e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 651}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 651}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "030f4ad8826165dce92e40af8f294bd1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 651}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 651}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "581aca186b61ff78f64d4192621e1d67", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 653}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 653}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bbd8cec00f46b69a11987b2ddc63aa47", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 653}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 653}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "292ba49113044339804f7a6bd2fa1dab", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 655}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 655}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5d27562b4f45dbe36ed04adc21a9fdd2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 655}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 655}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ed7224357983277fd379998b9c9bccfa", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 657}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 657}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1422b6ddb62829f6cc7f3204fd1bdf23", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 657}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 657}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1912899f2f6cc9a0999ed3ab280ef014", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 659}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 659}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e50416e41e5320d730a039d180ba36a8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 659}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 659}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "700341983649aa49082c9d19bdb2d8cc", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 661}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 661}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "dcc95a292e9378d4cc8ccda6d493c45e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 661}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 661}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4362cce341103d4fdc25d251b5ad532e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 663}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 663}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "dd354aede7ecf0c3b9e8c16a5aff1b6c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 663}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 663}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "10827ef01926f2a9596c51eb57ee3689", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 665}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 665}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "670c746bf88579161e81bb3a9403d66b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 665}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 665}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1afd0b96cfff798cb35819b73cad1e1a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 673}, "message": "() (fixit)"}, {"location": {"col": 26, "file": 0, "line": 673}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3eb9c77df6c5fd101a606dd109c31500", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 0, "line": 674}, "message": "() (fixit)"}, {"location": {"col": 26, "file": 0, "line": 674}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d6776e2e14af0847b1e7f7ed7c9dff88", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 0, "line": 675}, "message": "() (fixit)"}, {"location": {"col": 26, "file": 0, "line": 675}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6236b387f54e04c5f133d7cf11e35cab", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 0, "line": 676}, "message": "() (fixit)"}, {"location": {"col": 26, "file": 0, "line": 676}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bb4cc142a6078ad82e19ccc484d02a67", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 0, "line": 677}, "message": "() (fixit)"}, {"location": {"col": 26, "file": 0, "line": 677}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f76a10d9e5922d1bffa9284bd98b9c17", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 0, "line": 678}, "message": "() (fixit)"}, {"location": {"col": 26, "file": 0, "line": 678}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f8528a8a1d4fca7a13eee7e8c6def774", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 0, "line": 679}, "message": "() (fixit)"}, {"location": {"col": 26, "file": 0, "line": 679}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "80e9bf5642031a0f8c802b259c5bf150", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 0, "line": 680}, "message": "() (fixit)"}, {"location": {"col": 26, "file": 0, "line": 680}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c14796468e744eb03cb5d226e8455bec", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 0, "line": 681}, "message": "() (fixit)"}, {"location": {"col": 26, "file": 0, "line": 681}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "98f6607f9fca7e217b80dfc2dccfa6a9", "checkerName": "bugprone-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 0, "line": 725}, "message": "meta_flags (fixit)"}, {"location": {"col": 15, "file": 0, "line": 725}, "message": "invalid case style for variable 'META_flags'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9f8c60f4bae4a7e345197f6161a77cdc", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1140}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1140}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9941c4ff3f41e8598c273023974a03f3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 1140}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 1140}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f1af9acd702dffd6f80f4c1c418a3930", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 1142}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 1142}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7f71a97ed1a80c07bf813b6bf1bd18b5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 1142}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 1142}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bce67035594890395237c25d97fa62b2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1186}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1186}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "833b8132ea1fa562ceb19d0e637a4889", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1186}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1186}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "40f43bdcfdb27fe7afa3b733653c1942", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1188}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 1188}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3c263dac9ef520a7c07081646f269a8b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1188}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 1188}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "df6f827975a5bc4fbc845504e3b21efb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 1199}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 1199}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1a23cfe7f8043a3bdabdea869707dc33", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 1199}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 1199}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3cf8c01d19638d3829cd0b1d599f7641", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1209}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1209}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a3ede070526794ad0544b7621627c852", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 1209}, "message": "{ (fixit)"}, {"location": {"col": 13, "file": 0, "line": 1209}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "613bf4c077a9b673ace794cb50dfb9a7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1211}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1211}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8080f710f478b76d92ae5f8b293abe72", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1211}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1211}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1eafe1f02e6eb2c59ab997255f77075b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1213}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1213}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0b904075cfda68d3cc23ff1f72424113", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 1213}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 1213}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0735ecab9c9681d7ca080c418167ed60", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 13, "file": 0, "line": 1284}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5f02eaadf035b50348691822e3d7b992", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 41, "file": 0, "line": 1286}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 1286}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e7028f1310727d9379a8d755918cd78d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 1286}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 1286}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "dd1b0f99ead3ee6afb961984ab0783f3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1301}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1301}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8c40fe0c22dbfbf498c4cca154106c7e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1301}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1301}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "aae385292a1a5d0a447d9952096dc973", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1312}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1312}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "075b484db64a62c5dbaa489e378de71e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1312}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1312}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "fd9dace7a68ed63a8336a9b266912d5b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 1314}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 1314}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8efffbf91fac66005c258ccffa95cb68", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 1314}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 1314}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ad4cdd8558f64bc45c60cbf9583f69d3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 446}, "message": "expanded from macro 'OP'"}, {"location": {"col": 7, "file": 0, "line": 1274}, "message": "Assuming 'expr' is not equal to NULL"}, {"location": {"col": 3, "file": 0, "line": 1274}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1286}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 1286}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1299}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 0, "line": 1299}, "message": "Left side of '||' is false"}, {"location": {"col": 43, "file": 0, "line": 1299}, "message": "Assuming 'reg_toolong' is 0"}, {"location": {"col": 3, "file": 0, "line": 1299}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1312}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 1312}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1314}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 1314}, "message": "Taking false branch"}, {"location": {"col": 3, "file": 0, "line": 1318}, "message": "Null pointer value stored to 'scan'"}, {"location": {"col": 10, "file": 0, "line": 1319}, "message": "Null pointer passed to 1st parameter expecting 'nonnull'"}, {"location": {"col": 33, "file": 0, "line": 446}, "message": "expanded from macro 'OP'"}, {"location": {"col": 10, "file": 0, "line": 1319}, "message": "Null pointer passed to 1st parameter expecting 'nonnull'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "851a59478359fc384f9e74d760a8ab12", "checkerName": "clang-analyzer-core.NonNullParamChecker", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1357}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1357}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4cf4cfd9c69aeb19a0e911388d241c86", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 50, "file": 0, "line": 1357}, "message": "{ (fixit)"}, {"location": {"col": 49, "file": 0, "line": 1357}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "10f4acb41c5d46c06a5556422caaf2e7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 1391}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 1391}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2335dcbfad61e0f11956e627fbdeaa05", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 1391}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 1391}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8d02b89994ae7272560dbbaf107066b0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1393}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 1393}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3c263dac9ef520a7c07081646f269a8b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1393}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 1393}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "df6f827975a5bc4fbc845504e3b21efb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1793}, "message": "example recursive call chain, starting from function 'regatom'"}, {"location": {"col": 11, "file": 0, "line": 1905}, "message": "Frame #1: function 'regatom' calls function 'reg' here:"}, {"location": {"col": 8, "file": 0, "line": 1467}, "message": "Frame #2: function 'reg' calls function 'regbranch' here:"}, {"location": {"col": 14, "file": 0, "line": 1540}, "message": "Frame #3: function 'regbranch' calls function 'regconcat' here:"}, {"location": {"col": 16, "file": 0, "line": 1620}, "message": "Frame #4: function 'regconcat' calls function 'regpiece' here:"}, {"location": {"col": 9, "file": 0, "line": 1657}, "message": "Frame #5: function 'regpiece' calls function 'regatom' here:"}, {"location": {"col": 9, "file": 0, "line": 1657}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 1, "file": 0, "line": 1433}, "message": "function 'reg' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "be9bfae8e1e1ff361ac3cee414031de8", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1448}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1448}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "84df32f475b3a764749b0cb94a152449", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1448}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1448}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "728810b86b3b6b5e24aaf127b589396e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 1455}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 1455}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "104bd4e32f3a1af1f1a88cfc39b705af", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 1455}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 1455}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "aa250da48c6cbc4fdcaeb2ec98f04123", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 1463}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1463}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "20a6df6820b6f3fedf248129bd99f2f5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 1463}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1463}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b23d8ae4c3e31e34e00e5c2583b5291a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 1468}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 1468}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f7090320a51d753e04938b3855f296c3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 1468}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 1468}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "afcd080828a6588018e0fac99d7013e2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1470}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1470}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9a44d17f251a6936003a7e64b7e1b1be", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1470}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1470}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "90803fa5c8af87942a1b24dc7436ff03", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1472}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 1472}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3c263dac9ef520a7c07081646f269a8b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1472}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 1472}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "df6f827975a5bc4fbc845504e3b21efb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 1477}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 1477}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "53554f5651af5b4311bd4f7889ad42f4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 1477}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 1477}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d7a84e11977346fac32eb962cee5a053", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 1483}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 1483}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6bfabcdf12a7ac5f2f12175e06287787", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 1483}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 1483}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de01be4c5d15da986fbd7806ac3fe50c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1486}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1486}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "33a165f9deb38dcbc855239dd7c979c2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1486}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1486}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "91b448eab1eb937dcc33183ac5fc7353", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 1499}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 1499}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e69cee09a289ea5ca1a9186ab2020841", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 1499}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 1499}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "58d9d62f426c1fedb917b679eeb502f2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1504}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1504}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "22a809519c6b6656a1fbab2bf0fefe78", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 1504}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 1504}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d0e11aecc501b95f79e26f0fab0b08f0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 1506}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c81731330292f8d21e62537fc4756751", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1506}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1506}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "faec3005f1312ec3bad35c0b77b4209d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1506}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1506}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c9a7dadba81f1d8a6d54bed6bbb15854", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1508}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1508}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "670c746bf88579161e81bb3a9403d66b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1508}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1508}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1afd0b96cfff798cb35819b73cad1e1a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 1511}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 1511}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2edace574942a26eca793a7e2e3d4fff", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 1511}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 1511}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "925b01fb6d2dcc6e654ac5e0ac4db391", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 0, "line": 1513}, "message": "EMSG_RET_NULL (fixit)"}, {"location": {"col": 5, "file": 0, "line": 1513}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "46a05dd5928ddd55efbb85d498f02cee", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1513}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1513}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "670c746bf88579161e81bb3a9403d66b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 1513}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1513}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1afd0b96cfff798cb35819b73cad1e1a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1529}, "message": "function 'regbranch' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "777721d802797ac6867c47eac411f1f7", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1541}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1541}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c1696c041c008c336b1b91e5628f1d9b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1541}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1541}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "615c26ba6a6fb98f791c64fa82b9b061", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 1550}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 1550}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "962ea54d8cdebfe043f8babd9bc6bef9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 1550}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 1550}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ab8349111c04fbcf345d11e26210775b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 1552}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 1552}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d6ccaed593343c98da5e7af210517810", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 1552}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 1552}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7d5c912725e70a4d48464ae077c61f6c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1556}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1556}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8c40fe0c22dbfbf498c4cca154106c7e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1556}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1556}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "aae385292a1a5d0a447d9952096dc973", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1569}, "message": "function 'regconcat' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "57c949e24dd77b78e569ef29a3a228ce", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 42, "file": 0, "line": 1621}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 1621}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7e93481856953d193c80fcce85d044e8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 1621}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 1621}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "89ec23aaa07a2095c503ef378e3c8604", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 1624}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 1624}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9412266ab2b201da5f8e94f80419b95e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 1624}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 1624}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1ee6c47e35b9654f0f22f8942207dc3b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 1626}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 1626}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "da4fef60c5022df7e0a97592939344b7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 1626}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 1626}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "138a5862362c4ee6740639cd711a4bae", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 1629}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 1629}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b3efff3d3788bab123a1107e553b2f01", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 1629}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 1629}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "847458ef29d08ec23b96166b488f70c4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1634}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1634}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "79ccb3ce5612928dc61c9777f602f3e2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1634}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1634}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a847cbe21287a66abdeaa023b8121104", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1648}, "message": "function 'regpiece' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "71b383bc7fb8173f707b9c792090f4aa", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1658}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1658}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "67e39acf73d9f9629ceb0e0838c6bf06", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1658}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1658}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5b56d2a9352971490b8d4e61a9abe02e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1672}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1672}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9a125704dd173269495526dea4eeddc0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1672}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1672}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "dd3734ee7a4c1675cb371c04d20e71be", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1685}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1685}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9a125704dd173269495526dea4eeddc0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 1685}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 1685}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "dd3734ee7a4c1675cb371c04d20e71be", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 1712}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 1712}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3975b79ea6210057ad86dd8a42746c5f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 1712}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 1712}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "dcad1ba1f7004354456cc896ea0173d5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 1722}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 1722}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "63991cd808ac8c54753b8ad6ba2b72b8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 1722}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 1722}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9ff91587709637621175b0eb2286a7c5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 1725}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 1725}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7188135da1c35aaceca40ca136d28928", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 1725}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 1725}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1b5cadafff354a4d5b0dd7dad4ca2a44", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 1741}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 1741}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "735523878bbd0c7938ee44f48eddd5d3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 41, "file": 0, "line": 1741}, "message": "{ (fixit)"}, {"location": {"col": 40, "file": 0, "line": 1741}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ae17e83147daba2aac98d973d96576d9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 1747}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 1747}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "eac280ebda991defed31d0088d989ab0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 1747}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 1747}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7ba7d3d194661714f7e40c8c572fc465", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1756}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1756}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "59db37167f1eb305e95c52d9d97fd628", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 1756}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 1756}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bfc7e4be4accb09c2ef5d2ba7371310f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 1762}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 1762}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ee1bc7d3d9576ee60c244bba62ee39bb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 1762}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 1762}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5a06c414e9adc8cbaea8edb71438b168", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 1765}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1765}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "670c746bf88579161e81bb3a9403d66b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 1765}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 1765}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1afd0b96cfff798cb35819b73cad1e1a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 1793}, "message": "function 'regatom' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "fd6f70a2f31941ce7202293f67d359de", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 19, "file": 0, "line": 1839}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 1839}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "61c9e58df85c8dbb13f621ba1b751346", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 1839}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 1839}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6aaa55d34832442f8da93921d9a9e507", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1876}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1876}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "28c2e057d224b62ca57f01babc2fdf0a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 1876}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 1876}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c8f00afe1fd78be19ea9256bd4aac9bd", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1903}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1903}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b75228046c6b94aba82502fc76408a78", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1903}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1903}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1405d53d86145e3a3d3d4cc63c0ab3f2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1906}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1906}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "691207f146d64a290ade533625187f60", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1906}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1906}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4cc24d03876a48d4ca20ad073274a95e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1915}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1915}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b75228046c6b94aba82502fc76408a78", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 1915}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 1915}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1405d53d86145e3a3d3d4cc63c0ab3f2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 1939}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 1939}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "22cfec2afcfb11c234627df42de059b1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 1939}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 1939}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a772f7c4f1ae3112331619b99c7f8c10", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 1944}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 1944}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1d459da30418a985b7acfa7280fa67bf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 1944}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 1944}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8a00cb3c18739f76e19dbc8efb1bb895", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 1947}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 1947}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7188135da1c35aaceca40ca136d28928", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 1947}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 1947}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1b5cadafff354a4d5b0dd7dad4ca2a44", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 1975}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 1975}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "09729f8418eaf3303415011eebc0781c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 1975}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 1975}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c1f9d790653faeec04fbd933cba23717", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 1977}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 1977}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6f5bd4cc43d09592b6cbf67c3f9b5a53", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 1977}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 1977}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c814052af7142a4f817800240c78c9ab", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 1980}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 1980}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6f2535ad287b8e0423598cf1022eac54", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 1980}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 1980}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8a46b525bcbd6cbfca855c29771f91b5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 1994}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 1994}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "620d69e6ebdcc4280f2aa0ee5461d50c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 1994}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 1994}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3f0a85e1b8752c8d30b6ecae162439da", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2023}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2023}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6f5bd4cc43d09592b6cbf67c3f9b5a53", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2023}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2023}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c814052af7142a4f817800240c78c9ab", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2026}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2026}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6f2535ad287b8e0423598cf1022eac54", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2026}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2026}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8a46b525bcbd6cbfca855c29771f91b5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2056}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2056}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "34734c197f2d3fa156050df0cd669d17", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 2056}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 2056}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ff43b90a09315a4c2cb9aa9dd25c164a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 2065}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 2065}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8507d22e7303ff2d8d44aabe90a903d0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 2065}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 2065}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2a6911f17c32dd369d035b6f6765cf77", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2086}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2086}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6855288244bc68736e0f9876275903ca", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2086}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2086}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4003dc4ac4e6935fb2acf7d3f39de5f7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 20, "file": 0, "line": 2091}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e8503c8070abb5c113512b658303a3c0", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 20, "file": 0, "line": 2103}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 2103}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5118e02bafad9930d9af1dca6a98fe87", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 2103}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 2103}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5457f65997a4b919a557f8e6defe52f1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 2154}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 2154}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "aa4b3a849d6460c046630d22b46a5704", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 2154}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 2154}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a3f0958ac3e2169028b8981df62bef10", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 22, "file": 0, "line": 2164}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d716d52b8f03bc789c770055a650823f", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 38, "file": 0, "line": 2164}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 0, "line": 2164}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3782480e4f2223fad059ae122a2dcc19", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 0, "line": 2164}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 0, "line": 2164}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "76984179534a6402fbfdc4b936ead02e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 11, "file": 0, "line": 2171}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c466759627f7888258012fea3e9cfc15", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 22, "file": 0, "line": 2182}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a712cde55083dba5cd24de121c9874f0", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2221}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 2221}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "80e397e4c6a3b6cf1e7007ad131af4b7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 2221}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 2221}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "98a454b6f3cd41c8ea3899b402d6b718", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 2243}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 2243}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5b4a7de49c98a4764c87ed072fb0f480", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 2243}, "message": "{ (fixit)"}, {"location": {"col": 36, "file": 0, "line": 2243}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "78a1c82b8aca4803e97b21a9bb2ef28b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 0, "line": 2250}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 0, "line": 2250}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "397e31bcf38a3a6b9a70713dd5f923a6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 49, "file": 0, "line": 2250}, "message": "{ (fixit)"}, {"location": {"col": 48, "file": 0, "line": 2250}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b48537c75a2c6e691f5c43b4e535e4b5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 2266}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 2266}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2ee6b8b2175b7d217fdc68aed74ed5d0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 42, "file": 0, "line": 2266}, "message": "{ (fixit)"}, {"location": {"col": 41, "file": 0, "line": 2266}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b91f0a041bc64fef466359783a69af5f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 26, "file": 0, "line": 2285}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3d2b409a4cff418ae66f38515990fce0", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 2302}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 2302}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5797cdd27c6fb14c7eb64dae362bb83d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 2302}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 2302}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b5281febba4d5daf8bbd6d0c89f97b8b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 2304}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 2304}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "031c39fae88884b87c46364c10883482", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 2304}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 2304}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "71aa1ffe2cecabc8dbaae54220b9922a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 2394}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 2394}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "925b1de03e82d48579938c19bd3b3dc2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 2394}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 2394}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4eae205572f4935fba58ffc561d8887d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 2462}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 2462}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8f73bf46427b0044cd177bdb64ef7d3b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 2462}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 2462}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a1a95834ec94baf59d9284cb325ed3a0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 9, "file": 0, "line": 2467}, "message": "do not use 'else' after 'break'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7c077697da2e7b01f398c48031ed6a30", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 2467}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2467}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5e1789b3ce3e86a5c26f24567ded3552", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 2467}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2467}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "644aa929ca59f2aebff2c19277a663be", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 0, "line": 2510}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 0, "line": 2510}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "130b7510b0390550b731efc6cb7bd35c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 0, "line": 2510}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 0, "line": 2510}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d1d24445032209e1ce03c78a21c07019", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 2523}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 2523}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bb5cf3f27867d976d5b8ef052bcd8828", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 2523}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 2523}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7d3cd2bd00d616b3ba7aa34e2a0c6170", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2533}, "message": "const (fixit)"}, {"location": {"col": 32, "file": 0, "line": 2533}, "message": "pointer parameter 'what' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "cfbf1432edb5cd519293802fd9c62138", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 14, "file": 0, "line": 2559}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3769cd5c308247f6b3bdff364bc41be3", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 30, "file": 0, "line": 2559}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2559}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e2e1a8de21c2f97136048e82c4619f34", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 2559}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 2559}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4f86e198e21b3aa2039681fb08bee70b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 18, "file": 0, "line": 2574}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6c6ac2eca3ace87894116b8b2723a1bb", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 34, "file": 0, "line": 2574}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 2574}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "dff63aa4c323da0314ca26e6030169ba", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 2574}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 2574}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5b5f51df114a095027adeae5e0ec9dc4", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2576}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 2576}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3c263dac9ef520a7c07081646f269a8b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2576}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 2576}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "df6f827975a5bc4fbc845504e3b21efb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 18, "file": 0, "line": 2585}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e30427852bb0688f5462c4db6cf2d54c", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 18, "file": 0, "line": 2603}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e30427852bb0688f5462c4db6cf2d54c", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2610}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2610}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ccbf70fbfb74ea1cf0a71d486af3df95", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2610}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2610}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c9c482c79def77410404020b32487a4c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 18, "file": 0, "line": 2629}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e30427852bb0688f5462c4db6cf2d54c", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2636}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2636}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ccbf70fbfb74ea1cf0a71d486af3df95", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2636}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2636}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c9c482c79def77410404020b32487a4c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 18, "file": 0, "line": 2659}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e30427852bb0688f5462c4db6cf2d54c", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2666}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2666}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ccbf70fbfb74ea1cf0a71d486af3df95", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 2666}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 2666}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c9c482c79def77410404020b32487a4c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 2693}, "message": "const (fixit)"}, {"location": {"col": 40, "file": 0, "line": 2693}, "message": "pointer parameter 'val' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f7089fc0fcd32cb88643542af5233b1e", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 12, "file": 0, "line": 2697}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "940f452777c1c8cf4744ce49df27638a", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 25, "file": 0, "line": 2733}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "69ef7db226f667b1c85ba1187adc4f88", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 69, "file": 0, "line": 2735}, "message": "{ (fixit)"}, {"location": {"col": 68, "file": 0, "line": 2735}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "50f57d539b360a7235e4ea6a27a736ac", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 69, "file": 0, "line": 2735}, "message": "{ (fixit)"}, {"location": {"col": 68, "file": 0, "line": 2735}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e232bdf5be7f8571c429bc763e93a8e0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 2793}, "message": "example recursive call chain, starting from function 'peekchr'"}, {"location": {"col": 13, "file": 0, "line": 2916}, "message": "Frame #1: function 'peekchr' calls function 'peekchr' here:"}, {"location": {"col": 13, "file": 0, "line": 2916}, "message": "... which was the starting point of the recursive call chain; there may be other cycles"}, {"location": {"col": 12, "file": 0, "line": 2793}, "message": "function 'peekchr' is within a recursive call chain"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6d8a36bc7039c3a0cc37818411c07af6", "checkerName": "misc-no-recursion", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 32, "file": 0, "line": 2806}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 2806}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7d31b2ee868829db82b988f3e8466653", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 2806}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 2806}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "71ab4ca7a19edca1e3216ad38b29d946", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 2832}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 2832}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2803a3c595ed8d9133441862d7b21ac6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 2832}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 2832}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b0687cc4c07d398626de9ed57a4193a0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 2845}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 2845}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "41921bfd5ab0ad3d80e69b527ddd8f16", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 2845}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 2845}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "64176f8f33844a04cb6de2a818ea3617", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 2899}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 2899}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "638fc5ca324a6633030e10be9eb995e9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 2899}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 2899}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "db8a69864224343d66c1af60d71f3237", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 67, "file": 0, "line": 2925}, "message": "{ (fixit)"}, {"location": {"col": 66, "file": 0, "line": 2925}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c068f9bf27d975fd9249f1e2f044294d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 67, "file": 0, "line": 2925}, "message": "{ (fixit)"}, {"location": {"col": 66, "file": 0, "line": 2925}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "841c2c29d50929f793c6bec350c23a88", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2950}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2950}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2d8e921fa9c2e8be3ed9d5990114c3ed", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 2950}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 2950}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "35e28e15b1fd9c2cc1c73597fe84d25b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2952}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 2952}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3c263dac9ef520a7c07081646f269a8b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 2952}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 2952}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "df6f827975a5bc4fbc845504e3b21efb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3028}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3028}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c96df36113e098218ae3ea6693594106", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3028}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3028}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ebedfdd91338452dbb0298f3278e21b3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 3035}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 0, "line": 3035}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "97b0c26d933a00bfedf1e900d14de627", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 3035}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 0, "line": 3035}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a4af15e0431c63bf58f56200bb3b128c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3052}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3052}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "77ed287462a904a570e78a58bcd691e1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3052}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3052}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "28e0a4865daf0801118838cd219c2649", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 3060}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 0, "line": 3060}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "97b0c26d933a00bfedf1e900d14de627", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 3060}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 0, "line": 3060}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a4af15e0431c63bf58f56200bb3b128c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3081}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3081}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8f815d8de616aa6ac8ff460eef9f9222", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 3081}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 3081}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f47625b844cb32bac4dda678789c8d4a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 3088}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 0, "line": 3088}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "97b0c26d933a00bfedf1e900d14de627", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 15, "file": 0, "line": 3088}, "message": "{ (fixit)"}, {"location": {"col": 14, "file": 0, "line": 3088}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a4af15e0431c63bf58f56200bb3b128c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 3488}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 3488}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6617f9028274d209fead696e9c61f2aa", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 3488}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 3488}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8500d8eca6c216afd6cbcd40f6819714", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 0, "line": 3605}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 0, "line": 3605}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e7d50a6d7c5added26579fbd7ce320ac", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 46, "file": 0, "line": 3605}, "message": "{ (fixit)"}, {"location": {"col": 45, "file": 0, "line": 3605}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3ba0ddcbf034c74845ae51a598e129a3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 3607}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 3607}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "fa4eb28be2de64c08181a4687578d263", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 44, "file": 0, "line": 3607}, "message": "{ (fixit)"}, {"location": {"col": 43, "file": 0, "line": 3607}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3fc47e3a424f59abd93601d0a6ba486f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 3648}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 3648}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1798595a72aefe49d0cc13f1b43c8f8d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 19, "file": 0, "line": 3648}, "message": "{ (fixit)"}, {"location": {"col": 18, "file": 0, "line": 3648}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "eb0a729a8f06466324f3693cb204a568", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 3662}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 3662}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bbec337be818c7095d45b00503012da8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 3662}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 3662}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "34ee54058a6a110ba517211fb6d3ccb9", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 0, "line": 3727}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 0, "line": 3727}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f119e29f8157032bc823fc5df7caa34f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 0, "line": 3727}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 0, "line": 3727}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "415a712040d7964081a842dd5bb78f8e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3752}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9bea4e62040769cfa237281561cb8555", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3757}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "987097a5fbfb26927ce9859577b4454d", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 3, "file": 0, "line": 3758}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b40c268e95ed951379ce346a1e3828d1", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 3801}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 3801}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b57eb014366194293f29a3e86afab48d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 3801}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 3801}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bacc3d614b7645454fa553d2f4360729", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 3803}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 3803}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f5a3f071c3a66277fd4b000963d778b2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 3803}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 3803}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "49cd753a7a8c03453304f55292bbdf53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 3844}, "message": "const (fixit)"}, {"location": {"col": 17, "file": 0, "line": 3844}, "message": "pointer parameter 'tm' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7b612d11cb6b16978c23e3b9d10047db", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4007}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4007}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a337a22209ddae31ab293d46e1966556", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4007}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4007}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8c94168240ea3af565abf599d2903b3c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 14, "file": 0, "line": 4047}, "message": "end of the original"}, {"location": {"col": 56, "file": 0, "line": 4047}, "message": "clone 1 starts here"}, {"location": {"col": 34, "file": 0, "line": 4045}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "40f61dee51a44f4457f8f23d08dca5e4", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 0, "line": 4057}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "863af3094ab012d5f442d3ebd1a4b9b0", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 4079}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 4079}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a594f0736be1621b9b9e1c725244f6a8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 4079}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 4079}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "60a06c4782aeca4e17eb2d829b84fc5f", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4081}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4081}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4081}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4081}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 4143}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 4143}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "da6446ee98d4e378092b5cd462384eaf", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 4143}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 4143}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1920da43a45530f45f6fe13c420fd034", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4145}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4145}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4145}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4145}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 4150}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 4150}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f7eb62ecc3450f5b4cc921d5c9c2ac12", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 45, "file": 0, "line": 4150}, "message": "{ (fixit)"}, {"location": {"col": 44, "file": 0, "line": 4150}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0e05b07006acdead21d4fe624fccbad6", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4152}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4152}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4152}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4152}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4157}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4157}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6b25d0d222116429fd9a27c6c51142a3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4157}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4157}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bc72a937ae12bcf3e85b8234f507bce8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4159}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4159}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4159}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4159}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4164}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4164}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4e51336251c69d8149b949d5df3ebb71", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4164}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4164}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "58381e9fc562c63426d31ca4f636e490", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4166}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4166}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4166}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4166}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4171}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4171}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "83f0a8b1f4dda743fba982e3c30302ff", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4171}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4171}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d6e7aab0dffdebd3cb5921690740faaa", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4173}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4173}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4173}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4173}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 0, "line": 4178}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 0, "line": 4178}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b4842fc23ecc63872309dda790927f6e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 38, "file": 0, "line": 4178}, "message": "{ (fixit)"}, {"location": {"col": 37, "file": 0, "line": 4178}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4b7ba657b0ec6e0d62add2852ff0804a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4180}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4180}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4180}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4180}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4185}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4185}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d346a0b08e222d58ec78b03251b3b074", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4185}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4185}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0df06cbd86e379dbf28e0ff5e8e8ecba", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4187}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4187}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4187}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4187}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4192}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4192}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e1f11d7d7c0968d47f7382319877f7e3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4192}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4192}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b86ea830d75bc63a81ea9d9a991fd765", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4194}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4194}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4194}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4194}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 4199}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 4199}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "105bbf058d21903e204371fda8e45ad8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 4199}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 4199}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0528882002383ac07f68edc9ea4c9dff", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4201}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4201}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4201}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4201}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 4206}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 4206}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6ace715acdb2bb365c88099b3a7cb501", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 4206}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 4206}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "cb0e6cef8151a1ec18466ce7b637dde3", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4208}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4208}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4208}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4208}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 4213}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 4213}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "78bfefbc50dbb3f41c6e2b17b45e8596", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 4213}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 4213}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "eb96f77101bb66ffe5498e3f1b4628a5", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4215}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4215}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4215}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4215}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 4220}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 4220}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9c2fd58c92e84182f0d3de9c5f0ad689", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 39, "file": 0, "line": 4220}, "message": "{ (fixit)"}, {"location": {"col": 38, "file": 0, "line": 4220}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "abe152eb63c00dd1606961219890f166", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4222}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4222}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4222}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4222}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4227}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4227}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ec9c019ab2e1d89923d9dc29ba2e5659", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4227}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4227}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b8007016c8929356e7dc2fe2658ebfa2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4229}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4229}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4229}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4229}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4234}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4234}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3584bb06903612cb8d3998bf879232fe", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4234}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4234}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "fbd88d4c5edf0ffdcf7b55b3f3a26639", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4236}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4236}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4236}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4236}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4241}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4241}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2d0282f388288961c586fa6e7bc850f2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4241}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4241}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c2b00f0d64147dd7e4c94d6d37d6c964", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4243}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4243}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4243}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4243}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4248}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4248}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d6108c1db75b97b200106315f3a7267c", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4248}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4248}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "49087f47772ec042708a28f4acec96eb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4250}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4250}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4250}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4250}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4255}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4255}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "68da503acfc7be40b62de6e4c171f5af", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4255}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4255}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "02ea028cd2f770125328a1976b05125c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4257}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4257}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4257}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4257}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4262}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4262}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "02cc11eb584a23761362b177fb79cb47", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4262}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4262}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "066dfdc0f6025a3ec68e1183ca27316c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4264}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4264}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4264}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4264}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 4311}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 4311}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8507d22e7303ff2d8d44aabe90a903d0", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 4311}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 4311}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2a6911f17c32dd369d035b6f6765cf77", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 4312}, "message": "end of the original"}, {"location": {"col": 13, "file": 0, "line": 4314}, "message": "clone 1 starts here"}, {"location": {"col": 13, "file": 0, "line": 4312}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "84e93b6361644a26ce763e92ef7e2002", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 74, "file": 0, "line": 4313}, "message": "{ (fixit)"}, {"location": {"col": 73, "file": 0, "line": 4313}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "991a24fee04c478ade58a2a578745eda", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 74, "file": 0, "line": 4313}, "message": "{ (fixit)"}, {"location": {"col": 73, "file": 0, "line": 4313}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b5cbab759dd73751c40c5fb725bdbc33", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4315}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4315}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4701be1b7d128d443c0e2d1ca205717f", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 16, "file": 0, "line": 4315}, "message": "{ (fixit)"}, {"location": {"col": 15, "file": 0, "line": 4315}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de545ffef1ca615a086348bb90f6da53", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 4321}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "19ce416a16745a890a9ef5af1ce8722c", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 4386}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 4386}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e1ac67e4c4f68c6b17b935ea936b3917", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 48, "file": 0, "line": 4386}, "message": "{ (fixit)"}, {"location": {"col": 47, "file": 0, "line": 4386}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "165485d3c0940db9421e6969d7520ce0", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4387}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4387}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ce4a8fe361840a5f0988e777b66ec4e6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 40, "file": 0, "line": 4387}, "message": "{ (fixit)"}, {"location": {"col": 39, "file": 0, "line": 4387}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b413ed6faf2b5f19a19c0d3e86fb5d07", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 4392}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 4392}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4c1058e7c4f1053e168d25b9399fd838", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 53, "file": 0, "line": 4392}, "message": "{ (fixit)"}, {"location": {"col": 52, "file": 0, "line": 4392}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8a851d96ceff2e08d32ef3d6d79c5f12", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4417}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4417}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6324e78dc817d7696526866455e744ac", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4417}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4417}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "65af73343d061fa7a31b3735c44c0893", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 0, "line": 4430}, "message": "{ (fixit)"}, {"location": {"col": 53, "file": 0, "line": 4430}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ba1c2f95f74d8795aba3b61a4cc2b133", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 54, "file": 0, "line": 4430}, "message": "{ (fixit)"}, {"location": {"col": 53, "file": 0, "line": 4430}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2497ceaf0149001f2625a2f946df4676", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4448}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4448}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6324e78dc817d7696526866455e744ac", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4448}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4448}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "65af73343d061fa7a31b3735c44c0893", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4496}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4496}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6324e78dc817d7696526866455e744ac", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4496}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4496}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "65af73343d061fa7a31b3735c44c0893", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 4592}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 4592}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9ae0be4d4feaf74c2c038c1f0dad6e94", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 4592}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 4592}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5c0608e7a411841a33c4fc9402fe14df", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4596}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4596}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c62bb341184531ad5786a185f5ffc989", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4596}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4596}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bccc36922b29ecf49a657fab41d3674e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 4598}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 4598}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "24eda3e543f9f6ac63fadf8d1f323c48", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 4598}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 4598}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "63b78583e16e090881ec5e9ff968791b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4640}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4640}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c62bb341184531ad5786a185f5ffc989", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4640}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4640}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bccc36922b29ecf49a657fab41d3674e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4656}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4656}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "079786a1a8b3b0d720b8a78837baf4e8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4656}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4656}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e09f65934e7b87729294e117b33647cb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4669}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4669}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "079786a1a8b3b0d720b8a78837baf4e8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4669}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4669}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e09f65934e7b87729294e117b33647cb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4737}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4737}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "079786a1a8b3b0d720b8a78837baf4e8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 4737}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 4737}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e09f65934e7b87729294e117b33647cb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 4744}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 4744}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "88dbd8a669a912abdd724c202266baa9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 4744}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 4744}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "622943b6e52e2c74bcfb058f7ef85dad", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4754}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4754}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6324e78dc817d7696526866455e744ac", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 4754}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 4754}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "65af73343d061fa7a31b3735c44c0893", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4774}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4774}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c62bb341184531ad5786a185f5ffc989", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 0, "line": 4774}, "message": "{ (fixit)"}, {"location": {"col": 28, "file": 0, "line": 4774}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bccc36922b29ecf49a657fab41d3674e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 4826}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 4826}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1c1abd750fa17ea58b3da49f6251ac71", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 4826}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 4826}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "92c1b6cf0986aa5cdddaecc85f4028ea", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 4881}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 4881}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3ff0c71c5ba5b15e41029c1626f8b4c6", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 4881}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 4881}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4bbae06e402cedccd0b8882ba8624a93", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 4922}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 4922}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7cf94b85227fb600a31c20e5c8c1196d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 4922}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 4922}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "27d04f0d3dae8b6377d4df1c9c4be6d1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 4928}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 4928}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c1b21daada9e6326ae9659135ed712ab", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 35, "file": 0, "line": 4928}, "message": "{ (fixit)"}, {"location": {"col": 34, "file": 0, "line": 4928}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6b651d4a74cf2490e2d5f1d5a67d9c28", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 71, "file": 0, "line": 4942}, "message": "{ (fixit)"}, {"location": {"col": 70, "file": 0, "line": 4942}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e46c18da5f9d32d403e42851d1cf012a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 71, "file": 0, "line": 4942}, "message": "{ (fixit)"}, {"location": {"col": 70, "file": 0, "line": 4942}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "731e85dbf70f128e3d0d8fbf4e6c506c", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4946}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4946}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "fc2dfa64b4def0944440446c83289a92", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4946}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4946}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3914afcc930779ea905610f794304e9a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 4950}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 4950}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7cf94b85227fb600a31c20e5c8c1196d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 0, "line": 4950}, "message": "{ (fixit)"}, {"location": {"col": 31, "file": 0, "line": 4950}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "27d04f0d3dae8b6377d4df1c9c4be6d1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4991}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4991}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4cc9cca1caf05ef6c22440eff1f5ce2b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 36, "file": 0, "line": 4991}, "message": "{ (fixit)"}, {"location": {"col": 35, "file": 0, "line": 4991}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "cfe740bbed1b39f246c831d8c4768fc2", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 0, "line": 5016}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 0, "line": 5016}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d93462643bbe2295602a9a3c4e993a42", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 65, "file": 0, "line": 5016}, "message": "{ (fixit)"}, {"location": {"col": 64, "file": 0, "line": 5016}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d8c3ee6d49a27b1b9351a7373c5f3ccf", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5023}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5023}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bb66efe1afe3ae444744cc271480b0c3", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5023}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5023}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1f3775c1fc3def4dc4c609cc8a1e4225", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 5045}, "message": "redundant cast to the same type"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7aa1f3ace4c4896527394108800bb632", "checkerName": "google-readability-casting", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 33, "file": 0, "line": 5095}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 5095}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0bc51f1e015d7b25cc146005053a4bb8", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 5095}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 5095}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "80b3ad8b3f55f609ae7b4d17a7203b70", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 0, "line": 5105}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 0, "line": 5105}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0ec833ce4a863711fdb9b6ed29ad6e17", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 0, "line": 5105}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 0, "line": 5105}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9684a100cf1cf5ce488a0d3a7bd511d8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 5126}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 5126}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3e3c61d19a3b343a0580aaae4ffe0288", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 64, "file": 0, "line": 5126}, "message": "{ (fixit)"}, {"location": {"col": 63, "file": 0, "line": 5126}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "361fea6600d6d102ecd799ee369b261e", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 5130}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 5130}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f9a791ab4d1c2a0342fd732a4f233629", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 5130}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 5130}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "594bf9ccac190504ad819f58414db878", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 5132}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 5132}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "88dbd8a669a912abdd724c202266baa9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 5132}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 5132}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "622943b6e52e2c74bcfb058f7ef85dad", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 0, "line": 5157}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 0, "line": 5157}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "fe3a384eb9019fb7d832f39f0708230d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 61, "file": 0, "line": 5157}, "message": "{ (fixit)"}, {"location": {"col": 60, "file": 0, "line": 5157}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2a015bb8a813efc10754e618d3caa204", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5162}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5162}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4e1890a58eddf576e225d45059176f6e", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5162}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5162}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3fb31df45b25b77b9c7789c7f1752857", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 5399}, "message": "end of the original"}, {"location": {"col": 71, "file": 0, "line": 5399}, "message": "clone 1 starts here"}, {"location": {"col": 56, "file": 0, "line": 5397}, "message": "repeated branch in conditional chain"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7822e85965e02d13bfda3bce5bdd7ad5", "checkerName": "bugprone-branch-clone", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5479}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0f92b20e5ef49269511c085d2abb63e7", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 5503}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9bd128282cb4d230831dcc4394472857", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 0, "line": 5555}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 0, "line": 5555}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3eacdbd42b32ccfe8ee52eef87f3bad9", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 56, "file": 0, "line": 5555}, "message": "{ (fixit)"}, {"location": {"col": 55, "file": 0, "line": 5555}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "547055203f46408bdd4e1c733564496d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 527}, "message": "expanded from macro 'JUST_CALC_SIZE'"}, {"location": {"col": 12, "file": 0, "line": 5603}, "message": "integer to pointer cast pessimizes optimization opportunities"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e4ae1ff1506ef61c3a0ab690086487fc", "checkerName": "performance-no-int-to-ptr", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 43, "file": 0, "line": 5603}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 5603}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e0ce0efe5b010455a1573b1c58ea4b26", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 43, "file": 0, "line": 5603}, "message": "{ (fixit)"}, {"location": {"col": 42, "file": 0, "line": 5603}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "af5f85be92248c922d46740297c4ea12", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 5607}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 5607}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "103349c3703f825dc99ef255d32caff1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 20, "file": 0, "line": 5607}, "message": "{ (fixit)"}, {"location": {"col": 19, "file": 0, "line": 5607}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "cd392dda2a6647edad831024b2bd74f8", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 5610}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 5610}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d07cfe8d72650db41cdc589b25fc1254", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 5610}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 5610}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "02e9e5d19bcd89b6eeabfb47cb807437", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 7, "file": 0, "line": 5612}, "message": "return p + offset (fixit)"}, {"location": {"col": 3, "file": 0, "line": 5612}, "message": "do not use 'else' after 'return'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d9b32a1850b585b6933daf27517191a4", "checkerName": "readability-else-after-return", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 5612}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 7, "file": 0, "line": 5612}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3c263dac9ef520a7c07081646f269a8b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 1, "file": 0, "line": 5612}, "message": "note: this fix will not be applied because it overlaps with another fix (fixit)"}, {"location": {"col": 7, "file": 0, "line": 5612}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "df6f827975a5bc4fbc845504e3b21efb", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 37, "file": 0, "line": 5785}, "message": "const (fixit)"}, {"location": {"col": 45, "file": 0, "line": 5785}, "message": "pointer parameter 'scan' can be pointer to const"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "2d525b4431d6194bc581229640845a60", "checkerName": "readability-non-const-parameter", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 5789}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 5789}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a463172883dbbab62fd22b9cf6db0a99", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 5789}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 5789}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b180f2ca1b521fb51d525c1c54657977", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 5791}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 5791}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bc49cf04ad3bb739a3b555123de97ca5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 33, "file": 0, "line": 5791}, "message": "{ (fixit)"}, {"location": {"col": 32, "file": 0, "line": 5791}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7704f9d375a683823a499ccc89030c0b", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 5809}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 5809}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e0f85ce188e6790a72db8ac46a84f648", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 0, "line": 5809}, "message": "{ (fixit)"}, {"location": {"col": 23, "file": 0, "line": 5809}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "656a506ae964a7cc864a98198bf883b1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 5822}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 7, "file": 0, "line": 5822}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "e79bf172e0abb43064ba70c4eb703a45", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5831}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5831}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6a551bb3c798e2cfd333ac14ad4f8cda", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 28, "file": 0, "line": 5831}, "message": "{ (fixit)"}, {"location": {"col": 27, "file": 0, "line": 5831}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "cdc2975120f4fccb9f391f311ee66356", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 5833}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 5833}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "670c746bf88579161e81bb3a9403d66b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 5833}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 5833}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1afd0b96cfff798cb35819b73cad1e1a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 5851}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 5851}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3c837fcf63845270d5a4c1e31bacf67a", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 0, "line": 5851}, "message": "{ (fixit)"}, {"location": {"col": 25, "file": 0, "line": 5851}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a299c2290b5bc7a83f3f5602b8e6df95", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 5855}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 5855}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d647c084ee90ac5e7ef9c9923e3256cb", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 5855}, "message": "{ (fixit)"}, {"location": {"col": 17, "file": 0, "line": 5855}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "23ef0d7f77b63d804aa012f28de36e01", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 6411}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "867b4a29f17c7e1c62c301e863094540", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 5, "file": 0, "line": 6412}, "message": "multiple declarations in a single statement reduces readability"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b8a0d1a67cd89ed0aa1be4e9c45ccb32", "checkerName": "readability-isolate-declaration", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 6439}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 6439}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5bcb36dd385e03dc53cb17c9e47a96dc", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 6439}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 6439}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7062e2f5c66240757eb6c24e26464204", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 6514}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 6514}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "4fa6df8bae8a59ea3d3ae5fcb214901d", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 6514}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 6514}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0ce547c7a49b3bcf608767da17614ff7", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 6516}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 6516}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d26262fcc2a4a285585c209e91da7791", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 0, "line": 6518}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 6518}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "93912066e5697d051d465e68e9e3bbab", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 31, "file": 0, "line": 6518}, "message": "{ (fixit)"}, {"location": {"col": 30, "file": 0, "line": 6518}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "bf18d6a3db77967025558bde8b6e8215", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 6522}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 6522}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "de8c67536261ed273db25a9557ecf1ca", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 6522}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 6522}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5224a85308e8806c7826221d907bbf0d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 6524}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 6524}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "da4fef60c5022df7e0a97592939344b7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 6524}, "message": "{ (fixit)"}, {"location": {"col": 11, "file": 0, "line": 6524}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "138a5862362c4ee6740639cd711a4bae", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 6536}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 6536}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0237ceb873ec83c8d011f633fa1c4dc4", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 6536}, "message": "{ (fixit)"}, {"location": {"col": 24, "file": 0, "line": 6536}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f36700f57bd677b8ca25843e37ba640d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6538}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 6538}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "d4a7f96a425b75b223e0fedcf6759ae7", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 8, "file": 0, "line": 6538}, "message": "{ (fixit)"}, {"location": {"col": 7, "file": 0, "line": 6538}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "f8ca8387cc65ac48882e0e3f91633316", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 6691}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 6691}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6617f9028274d209fead696e9c61f2aa", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 6691}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 6691}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "8500d8eca6c216afd6cbcd40f6819714", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 6704}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 9, "file": 0, "line": 6704}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5c132131b9154cd53bacccb755d239e5", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 0, "line": 6730}, "message": "match_list (fixit)"}, {"location": {"col": 24, "file": 0, "line": 6730}, "message": "invalid case style for variable 'matchList'"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "55b0192316cd5f7a44b8ecb6ed75ac9d", "checkerName": "readability-identifier-naming", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 6805}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 6805}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "20a6df6820b6f3fedf248129bd99f2f5", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 10, "file": 0, "line": 6805}, "message": "{ (fixit)"}, {"location": {"col": 9, "file": 0, "line": 6805}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b23d8ae4c3e31e34e00e5c2583b5291a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 6807}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 6807}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "9049ef7bfcec338c23ac2805a18e5a0b", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 6807}, "message": "{ (fixit)"}, {"location": {"col": 29, "file": 0, "line": 6807}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7a56ba0d573411017a94cd9055a4f323", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 0, "line": 6961}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 0, "line": 6961}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "885cc4c4329220c73e30af5ee75fb0c2", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 47, "file": 0, "line": 6961}, "message": "{ (fixit)"}, {"location": {"col": 46, "file": 0, "line": 6961}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "a8cdf454d0b70f5109aa916ef2f11321", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 6964}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 6964}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "37374bd3ceb42a1135fd9b35b6911843", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 52, "file": 0, "line": 6964}, "message": "{ (fixit)"}, {"location": {"col": 51, "file": 0, "line": 6964}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6b3c2806a2a45a8e2070268b2e4a1c7d", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 6967}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 6967}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "7766a2b9cd892dae3e71aa5233871d17", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 0, "line": 6967}, "message": "{ (fixit)"}, {"location": {"col": 21, "file": 0, "line": 6967}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "0fd450595d88a4a2699b80b4e97d5615", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 6995}, "message": "{ (fixit)"}, {"location": {"col": 12, "file": 0, "line": 6995}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "01523f2822d13e458ba5989aa32e6e61", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 13, "file": 0, "line": 6995}, "message": "{ (fixit)"}, {"location": {"col": 12, "file": 0, "line": 6995}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "1ac59aa5feebe05d503e2f3cafa7e5ea", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 7036}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 7036}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "ea4ddf269522cf92c5e6e4b029ab90de", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 34, "file": 0, "line": 7036}, "message": "{ (fixit)"}, {"location": {"col": 33, "file": 0, "line": 7036}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "b874bcf86e188205662cf0c7f63c9c9a", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 7069}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 11, "file": 0, "line": 7069}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "34dfb4deda2794292b463cae2ce9ce0a", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 0, "line": 7076}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 7076}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "348804fa352fcf50a73a2731ee6db7e1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 7076}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 7076}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3c2f266d65e8c08d17fa0cc1aaf9bec1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 7077}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}, {"location": {"col": 29, "file": 1, "line": 220}, "message": "expanded from macro 'STRCPY'"}, {"location": {"col": 13, "file": 0, "line": 7077}, "message": "Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "c35665bd6f3dc39dc310144205c8cf11", "checkerName": "clang-analyzer-security.insecureAPI.strcpy", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 0, "line": 7079}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 7079}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "348804fa352fcf50a73a2731ee6db7e1", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 27, "file": 0, "line": 7079}, "message": "{ (fixit)"}, {"location": {"col": 26, "file": 0, "line": 7079}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "3c2f266d65e8c08d17fa0cc1aaf9bec1", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 0, "line": 7175}, "message": "suspicious #include of file with '.c' extension"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "6585aed43bc597a0b209214d5f23dbfe", "checkerName": "bugprone-suspicious-include", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 21, "file": 0, "line": 7293}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 7293}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "5f051639ca1ef321536462119f4b5121", "checkerName": "google-readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 0, "line": 7293}, "message": "{ (fixit)"}, {"location": {"col": 20, "file": 0, "line": 7293}, "message": "statement should be inside braces"}], "macros": [], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "834faeb145355a456543f9e56d312572", "checkerName": "readability-braces-around-statements", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
