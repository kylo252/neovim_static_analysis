<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "src/nvim/regexp.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/*\n * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()\n *\n * NOTICE:\n *\n * This is NOT the original regular expression code as written by Henry\n * Spencer.  This code has been modified specifically for use with the VIM\n * editor, and should not be used separately from Vim.  If you want a good\n * regular expression library, get the original code.  The copyright notice\n * that follows is from the original.\n *\n * END NOTICE\n *\n *\tCopyright (c) 1986 by University of Toronto.\n *\tWritten by Henry Spencer.  Not derived from licensed software.\n *\n *\tPermission is granted to anyone to use this software for any\n *\tpurpose on any computer system, and to redistribute it freely,\n *\tsubject to the following restrictions:\n *\n *\t1. The author is not responsible for the consequences of use of\n *\t\tthis software, no matter how awful, even if they arise\n *\t\tfrom defects in it.\n *\n *\t2. The origin of this software must not be misrepresented, either\n *\t\tby explicit claim or by omission.\n *\n *\t3. Altered versions must be plainly marked as such, and must not\n *\t\tbe misrepresented as being the original software.\n *\n * Beware that some of this code is subtly aware of the way operator\n * precedence is structured in regular expressions.  Serious changes in\n * regular-expression syntax might require a total rethink.\n *\n * Changes have been made by Tony Andrews, Olaf 'Rhialto' Seibert, Robert\n * Webb, Ciaran McCreesh and Bram Moolenaar.\n * Named character class support added by Walter Briscoe (1998 Jul 01)\n */\n\n// By default: do not create debugging logs or files related to regular\n// expressions, even when compiling with -DDEBUG.\n// Uncomment the second line to get the regexp debugging.\n// #undef REGEXP_DEBUG\n// #define REGEXP_DEBUG\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/eval/userfunc.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/mark.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/plines.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/strings.h\"\n\n#ifdef REGEXP_DEBUG\n/* show/save debugging data when BT engine is used */\n# define BT_REGEXP_DUMP\n/* save the debugging data to a file instead of displaying it */\n# define BT_REGEXP_LOG\n# define BT_REGEXP_DEBUG_LOG\n# define BT_REGEXP_DEBUG_LOG_NAME       \"bt_regexp_debug.log\"\n#endif\n\n/*\n * The \"internal use only\" fields in regexp_defs.h are present to pass info from\n * compile to execute that permits the execute phase to run lots faster on\n * simple cases.  They are:\n *\n * regstart\tchar that must begin a match; NUL if none obvious; Can be a\n *\t\tmulti-byte character.\n * reganch\tis the match anchored (at beginning-of-line only)?\n * regmust\tstring (pointer into program) that match must include, or NULL\n * regmlen\tlength of regmust string\n * regflags\tRF_ values or'ed together\n *\n * Regstart and reganch permit very fast decisions on suitable starting points\n * for a match, cutting down the work a lot.  Regmust permits fast rejection\n * of lines that cannot possibly match.  The regmust tests are costly enough\n * that vim_regcomp() supplies a regmust only if the r.e. contains something\n * potentially expensive (at present, the only such thing detected is * or +\n * at the start of the r.e., which can involve a lot of backup).  Regmlen is\n * supplied because the test in vim_regexec() needs it and vim_regcomp() is\n * computing it anyway.\n */\n\n/*\n * Structure for regexp \"program\".  This is essentially a linear encoding\n * of a nondeterministic finite-state machine (aka syntax charts or\n * \"railroad normal form\" in parsing technology).  Each node is an opcode\n * plus a \"next\" pointer, possibly plus an operand.  \"Next\" pointers of\n * all nodes except BRANCH and BRACES_COMPLEX implement concatenation; a \"next\"\n * pointer with a BRANCH on both ends of it is connecting two alternatives.\n * (Here we have one of the subtle syntax dependencies:\tan individual BRANCH\n * (as opposed to a collection of them) is never concatenated with anything\n * because of operator precedence).  The \"next\" pointer of a BRACES_COMPLEX\n * node points to the node after the stuff to be repeated.\n * The operand of some types of node is a literal string; for others, it is a\n * node leading into a sub-FSM.  In particular, the operand of a BRANCH node\n * is the first node of the branch.\n * (NB this is *not* a tree structure: the tail of the branch connects to the\n * thing following the set of BRANCHes.)\n *\n * pattern\tis coded like:\n *\n *\t\t\t  +-----------------+\n *\t\t\t  |\t\t    V\n * <aa>\\|<bb>\tBRANCH <aa> BRANCH <bb> --> END\n *\t\t     |\t    ^\t |\t    ^\n *\t\t     +------+\t +----------+\n *\n *\n *\t\t       +------------------+\n *\t\t       V\t\t  |\n * <aa>*\tBRANCH BRANCH <aa> --> BACK BRANCH --> NOTHING --> END\n *\t\t     |\t    |\t\t    ^\t\t\t   ^\n *\t\t     |\t    +---------------+\t\t\t   |\n *\t\t     +---------------------------------------------+\n *\n *\n *\t\t       +----------------------+\n *\t\t       V\t\t      |\n * <aa>\\+\tBRANCH <aa> --> BRANCH --> BACK  BRANCH --> NOTHING --> END\n *\t\t     |\t\t     |\t\t ^\t\t\t^\n *\t\t     |\t\t     +-----------+\t\t\t|\n *\t\t     +--------------------------------------------------+\n *\n *\n *\t\t\t\t\t+-------------------------+\n *\t\t\t\t\tV\t\t\t  |\n * <aa>\\{}\tBRANCH BRACE_LIMITS --> BRACE_COMPLEX <aa> --> BACK  END\n *\t\t     |\t\t\t\t    |\t\t     ^\n *\t\t     |\t\t\t\t    +----------------+\n *\t\t     +-----------------------------------------------+\n *\n *\n * <aa>\\@!<bb>\tBRANCH NOMATCH <aa> --> END  <bb> --> END\n *\t\t     |\t     |\t\t      ^       ^\n *\t\t     |\t     +----------------+       |\n *\t\t     +--------------------------------+\n *\n *\t\t\t\t\t\t      +---------+\n *\t\t\t\t\t\t      |\t\tV\n * \\z[abc]\tBRANCH BRANCH  a  BRANCH  b  BRANCH  c\tBRANCH\tNOTHING --> END\n *\t\t     |\t    |\t       |\t  |\t^\t\t    ^\n *\t\t     |\t    |\t       |\t  +-----+\t\t    |\n *\t\t     |\t    |\t       +----------------+\t\t    |\n *\t\t     |\t    +---------------------------+\t\t    |\n *\t\t     +------------------------------------------------------+\n *\n * They all start with a BRANCH for \"\\|\" alternatives, even when there is only\n * one alternative.\n */\n\n/*\n * The opcodes are:\n */\n\n/* definition\tnumber\t\t   opnd?    meaning */\n#define END             0       /*\tEnd of program or NOMATCH operand. */\n#define BOL             1       /*\tMatch \"\" at beginning of line. */\n#define EOL             2       /*\tMatch \"\" at end of line. */\n#define BRANCH          3       /* node Match this alternative, or the\n                                 *\tnext... */\n#define BACK            4       /*\tMatch \"\", \"next\" ptr points backward. */\n#define EXACTLY         5       /* str\tMatch this string. */\n#define NOTHING         6       /*\tMatch empty string. */\n#define STAR            7       /* node Match this (simple) thing 0 or more\n                                 *\ttimes. */\n#define PLUS            8       /* node Match this (simple) thing 1 or more\n                                 *\ttimes. */\n#define MATCH           9       /* node match the operand zero-width */\n#define NOMATCH         10      /* node check for no match with operand */\n#define BEHIND          11      /* node look behind for a match with operand */\n#define NOBEHIND        12      /* node look behind for no match with operand */\n#define SUBPAT          13      /* node match the operand here */\n#define BRACE_SIMPLE    14      /* node Match this (simple) thing between m and\n                                 *\tn times (\\{m,n\\}). */\n#define BOW             15      /*\tMatch \"\" after [^a-zA-Z0-9_] */\n#define EOW             16      /*\tMatch \"\" at    [^a-zA-Z0-9_] */\n#define BRACE_LIMITS    17      /* nr nr  define the min & max for BRACE_SIMPLE\n                                 *\tand BRACE_COMPLEX. */\n#define NEWL            18      /*\tMatch line-break */\n#define BHPOS           19      /*\tEnd position for BEHIND or NOBEHIND */\n\n\n/* character classes: 20-48 normal, 50-78 include a line-break */\n#define ADD_NL          30\n#define FIRST_NL        ANY + ADD_NL\n#define ANY             20      /*\tMatch any one character. */\n#define ANYOF           21      /* str\tMatch any character in this string. */\n#define ANYBUT          22      /* str\tMatch any character not in this\n                                 *\tstring. */\n#define IDENT           23      /*\tMatch identifier char */\n#define SIDENT          24      /*\tMatch identifier char but no digit */\n#define KWORD           25      /*\tMatch keyword char */\n#define SKWORD          26      /*\tMatch word char but no digit */\n#define FNAME           27      /*\tMatch file name char */\n#define SFNAME          28      /*\tMatch file name char but no digit */\n#define PRINT           29      /*\tMatch printable char */\n#define SPRINT          30      /*\tMatch printable char but no digit */\n#define WHITE           31      /*\tMatch whitespace char */\n#define NWHITE          32      /*\tMatch non-whitespace char */\n#define DIGIT           33      /*\tMatch digit char */\n#define NDIGIT          34      /*\tMatch non-digit char */\n#define HEX             35      /*\tMatch hex char */\n#define NHEX            36      /*\tMatch non-hex char */\n#define OCTAL           37      /*\tMatch octal char */\n#define NOCTAL          38      /*\tMatch non-octal char */\n#define WORD            39      /*\tMatch word char */\n#define NWORD           40      /*\tMatch non-word char */\n#define HEAD            41      /*\tMatch head char */\n#define NHEAD           42      /*\tMatch non-head char */\n#define ALPHA           43      /*\tMatch alpha char */\n#define NALPHA          44      /*\tMatch non-alpha char */\n#define LOWER           45      /*\tMatch lowercase char */\n#define NLOWER          46      /*\tMatch non-lowercase char */\n#define UPPER           47      /*\tMatch uppercase char */\n#define NUPPER          48      /*\tMatch non-uppercase char */\n#define LAST_NL         NUPPER + ADD_NL\n// -V:WITH_NL:560\n#define WITH_NL(op)     ((op) >= FIRST_NL && (op) <= LAST_NL)\n\n#define MOPEN           80   // -89 Mark this point in input as start of\n                             //     \\( \u2026 \\) subexpr.  MOPEN + 0 marks start of\n                             //     match.\n#define MCLOSE          90   // -99 Analogous to MOPEN.  MCLOSE + 0 marks\n                             //     end of match.\n#define BACKREF         100  // -109 node Match same string again \\1-\\9.\n\n# define ZOPEN          110  // -119 Mark this point in input as start of\n                             //  \\z( \u2026 \\) subexpr.\n# define ZCLOSE         120  // -129 Analogous to ZOPEN.\n# define ZREF           130  // -139 node Match external submatch \\z1-\\z9\n\n#define BRACE_COMPLEX   140 /* -149 node Match nodes between m & n times */\n\n#define NOPEN           150     // Mark this point in input as start of\n                                // \\%( subexpr.\n#define NCLOSE          151     // Analogous to NOPEN.\n\n#define MULTIBYTECODE   200     /* mbc\tMatch one multi-byte character */\n#define RE_BOF          201     /*\tMatch \"\" at beginning of file. */\n#define RE_EOF          202     /*\tMatch \"\" at end of file. */\n#define CURSOR          203     /*\tMatch location of cursor. */\n\n#define RE_LNUM         204     /* nr cmp  Match line number */\n#define RE_COL          205     /* nr cmp  Match column number */\n#define RE_VCOL         206     /* nr cmp  Match virtual column number */\n\n#define RE_MARK         207     /* mark cmp  Match mark position */\n#define RE_VISUAL       208     /*\tMatch Visual area */\n#define RE_COMPOSING    209     // any composing characters\n\n/*\n * Magic characters have a special meaning, they don't match literally.\n * Magic characters are negative.  This separates them from literal characters\n * (possibly multi-byte).  Only ASCII characters can be Magic.\n */\n#define Magic(x)        ((int)(x) - 256)\n#define un_Magic(x)     ((x) + 256)\n#define is_Magic(x)     ((x) < 0)\n\n/*\n * We should define ftpr as a pointer to a function returning a pointer to\n * a function returning a pointer to a function ...\n * This is impossible, so we declare a pointer to a function returning a\n * pointer to a function returning void. This should work for all compilers.\n */\ntypedef void (*(*fptr_T)(int *, int))(void);\n\ntypedef struct {\n  char_u     *regparse;\n  int prevchr_len;\n  int curchr;\n  int prevchr;\n  int prevprevchr;\n  int nextchr;\n  int at_start;\n  int prev_at_start;\n  int regnpar;\n} parse_state_T;\n\n/*\n * Structure used to save the current input state, when it needs to be\n * restored after trying a match.  Used by reg_save() and reg_restore().\n * Also stores the length of \"backpos\".\n */\ntypedef struct {\n  union {\n    char_u  *ptr;       ///< rex.input pointer, for single-line regexp\n    lpos_T pos;         ///< rex.input pos, for multi-line regexp\n  } rs_u;\n  int rs_len;\n} regsave_T;\n\n/* struct to save start/end pointer/position in for \\(\\) */\ntypedef struct {\n  union {\n    char_u  *ptr;\n    lpos_T pos;\n  } se_u;\n} save_se_T;\n\n/* used for BEHIND and NOBEHIND matching */\ntypedef struct regbehind_S {\n  regsave_T save_after;\n  regsave_T save_behind;\n  int save_need_clear_subexpr;\n  save_se_T save_start[NSUBEXP];\n  save_se_T save_end[NSUBEXP];\n} regbehind_T;\n\n/* Values for rs_state in regitem_T. */\ntypedef enum regstate_E {\n  RS_NOPEN = 0          /* NOPEN and NCLOSE */\n  , RS_MOPEN            /* MOPEN + [0-9] */\n  , RS_MCLOSE           /* MCLOSE + [0-9] */\n  , RS_ZOPEN            /* ZOPEN + [0-9] */\n  , RS_ZCLOSE           /* ZCLOSE + [0-9] */\n  , RS_BRANCH           /* BRANCH */\n  , RS_BRCPLX_MORE      /* BRACE_COMPLEX and trying one more match */\n  , RS_BRCPLX_LONG      /* BRACE_COMPLEX and trying longest match */\n  , RS_BRCPLX_SHORT     /* BRACE_COMPLEX and trying shortest match */\n  , RS_NOMATCH          /* NOMATCH */\n  , RS_BEHIND1          /* BEHIND / NOBEHIND matching rest */\n  , RS_BEHIND2          /* BEHIND / NOBEHIND matching behind part */\n  , RS_STAR_LONG        /* STAR/PLUS/BRACE_SIMPLE longest match */\n  , RS_STAR_SHORT       /* STAR/PLUS/BRACE_SIMPLE shortest match */\n} regstate_T;\n\n/*\n * When there are alternatives a regstate_T is put on the regstack to remember\n * what we are doing.\n * Before it may be another type of item, depending on rs_state, to remember\n * more things.\n */\ntypedef struct regitem_S {\n  regstate_T rs_state;          // what we are doing, one of RS_ above\n  uint16_t   rs_no;             // submatch nr or BEHIND/NOBEHIND\n  char_u     *rs_scan;          // current node in program\n  union {\n    save_se_T sesave;\n    regsave_T regsave;\n  } rs_un;                      ///< room for saving rex.input\n} regitem_T;\n\n\n/* used for STAR, PLUS and BRACE_SIMPLE matching */\ntypedef struct regstar_S {\n  int nextb;                    /* next byte */\n  int nextb_ic;                 /* next byte reverse case */\n  long count;\n  long minval;\n  long maxval;\n} regstar_T;\n\n/* used to store input position when a BACK was encountered, so that we now if\n * we made any progress since the last time. */\ntypedef struct backpos_S {\n  char_u      *bp_scan;         /* \"scan\" where BACK was encountered */\n  regsave_T bp_pos;             /* last input position */\n} backpos_T;\n\ntypedef struct {\n  int a, b, c;\n} decomp_T;\n\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"regexp.c.generated.h\"\n#endif\nstatic int no_Magic(int x)\n{\n  if (is_Magic(x))\n    return un_Magic(x);\n  return x;\n}\n\nstatic int toggle_Magic(int x)\n{\n  if (is_Magic(x))\n    return un_Magic(x);\n  return Magic(x);\n}\n\n/*\n * The first byte of the regexp internal \"program\" is actually this magic\n * number; the start node begins in the second byte.  It's used to catch the\n * most severe mutilation of the program by the caller.\n */\n\n#define REGMAGIC        0234\n\n/*\n * Opcode notes:\n *\n * BRANCH\tThe set of branches constituting a single choice are hooked\n *\t\ttogether with their \"next\" pointers, since precedence prevents\n *\t\tanything being concatenated to any individual branch.  The\n *\t\t\"next\" pointer of the last BRANCH in a choice points to the\n *\t\tthing following the whole choice.  This is also where the\n *\t\tfinal \"next\" pointer of each individual branch points; each\n *\t\tbranch starts with the operand node of a BRANCH node.\n *\n * BACK\t\tNormal \"next\" pointers all implicitly point forward; BACK\n *\t\texists to make loop structures possible.\n *\n * STAR,PLUS\t'=', and complex '*' and '+', are implemented as circular\n *\t\tBRANCH structures using BACK.  Simple cases (one character\n *\t\tper match) are implemented with STAR and PLUS for speed\n *\t\tand to minimize recursive plunges.\n *\n * BRACE_LIMITS\tThis is always followed by a BRACE_SIMPLE or BRACE_COMPLEX\n *\t\tnode, and defines the min and max limits to be used for that\n *\t\tnode.\n *\n * MOPEN,MCLOSE\t...are numbered at compile time.\n * ZOPEN,ZCLOSE\t...ditto\n */\n\n/*\n * A node is one char of opcode followed by two chars of \"next\" pointer.\n * \"Next\" pointers are stored as two 8-bit bytes, high order first.  The\n * value is a positive offset from the opcode of the node containing it.\n * An operand, if any, simply follows the node.  (Note that much of the\n * code generation knows about this implicit relationship.)\n *\n * Using two bytes for the \"next\" pointer is vast overkill for most things,\n * but allows patterns to get big without disasters.\n */\n#define OP(p)           ((int)*(p))\n#define NEXT(p)         (((*((p) + 1) & 0377) << 8) + (*((p) + 2) & 0377))\n#define OPERAND(p)      ((p) + 3)\n/* Obtain an operand that was stored as four bytes, MSB first. */\n#define OPERAND_MIN(p)  (((long)(p)[3] << 24) + ((long)(p)[4] << 16) \\\n                         + ((long)(p)[5] << 8) + (long)(p)[6])\n/* Obtain a second operand stored as four bytes. */\n#define OPERAND_MAX(p)  OPERAND_MIN((p) + 4)\n/* Obtain a second single-byte operand stored after a four bytes operand. */\n#define OPERAND_CMP(p)  (p)[7]\n\n/*\n * Utility definitions.\n */\n#define UCHARAT(p)      ((int)*(char_u *)(p))\n\n/* Used for an error (down from) vim_regcomp(): give the error message, set\n * rc_did_emsg and return NULL */\n#define EMSG_RET_NULL(m) return (EMSG(m), rc_did_emsg = true, (void *)NULL)\n#define IEMSG_RET_NULL(m) return (IEMSG(m), rc_did_emsg = true, (void *)NULL)\n#define EMSG_RET_FAIL(m) return (EMSG(m), rc_did_emsg = true, FAIL)\n#define EMSG2_RET_NULL(m, c) \\\n    return (EMSG2((m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = true, (void *)NULL)\n#define EMSG2_RET_FAIL(m, c) \\\n    return (EMSG2((m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = true, FAIL)\n#define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_( \\\n    \"E369: invalid item in %s%%[]\"), reg_magic == MAGIC_ALL)\n\n#define MAX_LIMIT       (32767L << 16L)\n\n\n#ifdef BT_REGEXP_DUMP\nstatic void regdump(char_u *, bt_regprog_T *);\n#endif\n#ifdef REGEXP_DEBUG\nstatic char_u   *regprop(char_u *);\n#endif\n\nstatic char_u e_missingbracket[] = N_(\"E769: Missing ] after %s[\");\nstatic char_u e_reverse_range[] = N_(\"E944: Reverse range in character class\");\nstatic char_u e_large_class[] = N_(\"E945: Range too large in character class\");\nstatic char_u e_unmatchedpp[] = N_(\"E53: Unmatched %s%%(\");\nstatic char_u e_unmatchedp[] = N_(\"E54: Unmatched %s(\");\nstatic char_u e_unmatchedpar[] = N_(\"E55: Unmatched %s)\");\nstatic char_u e_z_not_allowed[] = N_(\"E66: \\\\z( not allowed here\");\nstatic char_u e_z1_not_allowed[] = N_(\"E67: \\\\z1 - \\\\z9 not allowed here\");\nstatic char_u e_missing_sb[] = N_(\"E69: Missing ] after %s%%[\");\nstatic char_u e_empty_sb[]  = N_(\"E70: Empty %s%%[]\");\nstatic char_u e_recursive[]  = N_(\"E956: Cannot use pattern recursively\");\n\n#define NOT_MULTI       0\n#define MULTI_ONE       1\n#define MULTI_MULT      2\n/*\n * Return NOT_MULTI if c is not a \"multi\" operator.\n * Return MULTI_ONE if c is a single \"multi\" operator.\n * Return MULTI_MULT if c is a multi \"multi\" operator.\n */\nstatic int re_multi_type(int c)\n{\n  if (c == Magic('@') || c == Magic('=') || c == Magic('?'))\n    return MULTI_ONE;\n  if (c == Magic('*') || c == Magic('+') || c == Magic('{'))\n    return MULTI_MULT;\n  return NOT_MULTI;\n}\n\n/*\n * Flags to be passed up and down.\n */\n#define HASWIDTH        0x1     /* Known never to match null string. */\n#define SIMPLE          0x2     /* Simple enough to be STAR/PLUS operand. */\n#define SPSTART         0x4     /* Starts with * or +. */\n#define HASNL           0x8     /* Contains some \\n. */\n#define HASLOOKBH       0x10    /* Contains \"\\@<=\" or \"\\@<!\". */\n#define WORST           0       /* Worst case. */\n\n/*\n * When regcode is set to this value, code is not emitted and size is computed\n * instead.\n */\n#define JUST_CALC_SIZE  ((char_u *) -1)\n\nstatic char_u           *reg_prev_sub = NULL;\n\n/*\n * REGEXP_INRANGE contains all characters which are always special in a []\n * range after '\\'.\n * REGEXP_ABBR contains all characters which act as abbreviations after '\\'.\n * These are:\n *  \\n\t- New line (NL).\n *  \\r\t- Carriage Return (CR).\n *  \\t\t- Tab (TAB).\n *  \\e\t- Escape (ESC).\n *  \\b\t- Backspace (Ctrl_H).\n *  \\d  - Character code in decimal, eg \\d123\n *  \\o\t- Character code in octal, eg \\o80\n *  \\x\t- Character code in hex, eg \\x4a\n *  \\u\t- Multibyte character code, eg \\u20ac\n *  \\U\t- Long multibyte character code, eg \\U12345678\n */\nstatic char_u REGEXP_INRANGE[] = \"]^-n\\\\\";\nstatic char_u REGEXP_ABBR[] = \"nrtebdoxuU\";\n\n\n/*\n * Translate '\\x' to its control character, except \"\\n\", which is Magic.\n */\nstatic int backslash_trans(int c)\n{\n  switch (c) {\n  case 'r':   return CAR;\n  case 't':   return TAB;\n  case 'e':   return ESC;\n  case 'b':   return BS;\n  }\n  return c;\n}\n\n/*\n * Check for a character class name \"[:name:]\".  \"pp\" points to the '['.\n * Returns one of the CLASS_ items. CLASS_NONE means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\nstatic int get_char_class(char_u **pp)\n{\n  static const char *(class_names[]) =\n  {\n    \"alnum:]\",\n#define CLASS_ALNUM 0\n    \"alpha:]\",\n#define CLASS_ALPHA 1\n    \"blank:]\",\n#define CLASS_BLANK 2\n    \"cntrl:]\",\n#define CLASS_CNTRL 3\n    \"digit:]\",\n#define CLASS_DIGIT 4\n    \"graph:]\",\n#define CLASS_GRAPH 5\n    \"lower:]\",\n#define CLASS_LOWER 6\n    \"print:]\",\n#define CLASS_PRINT 7\n    \"punct:]\",\n#define CLASS_PUNCT 8\n    \"space:]\",\n#define CLASS_SPACE 9\n    \"upper:]\",\n#define CLASS_UPPER 10\n    \"xdigit:]\",\n#define CLASS_XDIGIT 11\n    \"tab:]\",\n#define CLASS_TAB 12\n    \"return:]\",\n#define CLASS_RETURN 13\n    \"backspace:]\",\n#define CLASS_BACKSPACE 14\n    \"escape:]\",\n#define CLASS_ESCAPE 15\n    \"ident:]\",\n#define CLASS_IDENT 16\n    \"keyword:]\",\n#define CLASS_KEYWORD 17\n    \"fname:]\",\n#define CLASS_FNAME 18\n  };\n#define CLASS_NONE 99\n  int i;\n\n  if ((*pp)[1] == ':') {\n    for (i = 0; i < (int)ARRAY_SIZE(class_names); ++i)\n      if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0) {\n        *pp += STRLEN(class_names[i]) + 2;\n        return i;\n      }\n  }\n  return CLASS_NONE;\n}\n\n/*\n * Specific version of character class functions.\n * Using a table to keep this fast.\n */\nstatic short class_tab[256];\n\n#define     RI_DIGIT    0x01\n#define     RI_HEX      0x02\n#define     RI_OCTAL    0x04\n#define     RI_WORD     0x08\n#define     RI_HEAD     0x10\n#define     RI_ALPHA    0x20\n#define     RI_LOWER    0x40\n#define     RI_UPPER    0x80\n#define     RI_WHITE    0x100\n\nstatic void init_class_tab(void)\n{\n  int i;\n  static int done = false;\n\n  if (done)\n    return;\n\n  for (i = 0; i < 256; ++i) {\n    if (i >= '0' && i <= '7')\n      class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;\n    else if (i >= '8' && i <= '9')\n      class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;\n    else if (i >= 'a' && i <= 'f')\n      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n    else if (i >= 'g' && i <= 'z')\n      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n    else if (i >= 'A' && i <= 'F')\n      class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n    else if (i >= 'G' && i <= 'Z')\n      class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n    else if (i == '_')\n      class_tab[i] = RI_WORD + RI_HEAD;\n    else\n      class_tab[i] = 0;\n  }\n  class_tab[' '] |= RI_WHITE;\n  class_tab['\\t'] |= RI_WHITE;\n  done = true;\n}\n\n# define ri_digit(c)    (c < 0x100 && (class_tab[c] & RI_DIGIT))\n# define ri_hex(c)      (c < 0x100 && (class_tab[c] & RI_HEX))\n# define ri_octal(c)    (c < 0x100 && (class_tab[c] & RI_OCTAL))\n# define ri_word(c)     (c < 0x100 && (class_tab[c] & RI_WORD))\n# define ri_head(c)     (c < 0x100 && (class_tab[c] & RI_HEAD))\n# define ri_alpha(c)    (c < 0x100 && (class_tab[c] & RI_ALPHA))\n# define ri_lower(c)    (c < 0x100 && (class_tab[c] & RI_LOWER))\n# define ri_upper(c)    (c < 0x100 && (class_tab[c] & RI_UPPER))\n# define ri_white(c)    (c < 0x100 && (class_tab[c] & RI_WHITE))\n\n/* flags for regflags */\n#define RF_ICASE    1   /* ignore case */\n#define RF_NOICASE  2   /* don't ignore case */\n#define RF_HASNL    4   /* can match a NL */\n#define RF_ICOMBINE 8   /* ignore combining characters */\n#define RF_LOOKBH   16  /* uses \"\\@<=\" or \"\\@<!\" */\n\n// Global work variables for vim_regcomp().\n\nstatic char_u *regparse;        ///< Input-scan pointer.\nstatic int prevchr_len;         ///< byte length of previous char\nstatic int num_complex_braces;  ///< Complex \\{...} count\nstatic int regnpar;             ///< () count.\nstatic bool wants_nfa;          ///< regex should use NFA engine\nstatic int regnzpar;            ///< \\z() count.\nstatic int re_has_z;            ///< \\z item detected\nstatic char_u *regcode;         ///< Code-emit pointer, or JUST_CALC_SIZE\nstatic long regsize;            ///< Code size.\nstatic int reg_toolong;         ///< true when offset out of range\nstatic char_u had_endbrace[NSUBEXP];  ///< flags, true if end of () found\nstatic unsigned regflags;         ///< RF_ flags for prog\nstatic long brace_min[10];        ///< Minimums for complex brace repeats\nstatic long brace_max[10];        ///< Maximums for complex brace repeats\nstatic int brace_count[10];       ///< Current counts for complex brace repeats\nstatic int had_eol;               ///< true when EOL found by vim_regcomp()\nstatic int one_exactly = false;   ///< only do one char for EXACTLY\n\nstatic int reg_magic;           /* magicness of the pattern: */\n#define MAGIC_NONE      1       /* \"\\V\" very unmagic */\n#define MAGIC_OFF       2       /* \"\\M\" or 'magic' off */\n#define MAGIC_ON        3       /* \"\\m\" or 'magic' */\n#define MAGIC_ALL       4       /* \"\\v\" very magic */\n\nstatic int reg_string;          /* matching with a string instead of a buffer\n                                   line */\nstatic int reg_strict;          /* \"[abc\" is illegal */\n\n/*\n * META contains all characters that may be magic, except '^' and '$'.\n */\n\n/* META[] is used often enough to justify turning it into a table. */\nstatic char_u META_flags[] = {\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  /*\t\t   %  &     (  )  *  +\t      .    */\n  0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,\n  /*     1  2  3\t4  5  6  7  8  9\t<  =  >  ? */\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,\n  /*  @  A     C\tD     F     H  I     K\tL  M\t O */\n  1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,\n  /*  P\t     S\t   U  V  W  X\t  Z  [\t\t _ */\n  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,\n  /*     a     c\td     f     h  i     k\tl  m  n  o */\n  0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,\n  /*  p\t     s\t   u  v  w  x\t  z  {\t|     ~    */\n  1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1\n};\n\nstatic int curchr;              /* currently parsed character */\n/* Previous character.  Note: prevchr is sometimes -1 when we are not at the\n * start, eg in /[ ^I]^ the pattern was never found even if it existed,\n * because ^ was taken to be magic -- webb */\nstatic int prevchr;\nstatic int prevprevchr;         /* previous-previous character */\nstatic int nextchr;             /* used for ungetchr() */\n\n/* arguments for reg() */\n#define REG_NOPAREN     0       /* toplevel reg() */\n#define REG_PAREN       1       /* \\(\\) */\n#define REG_ZPAREN      2       /* \\z(\\) */\n#define REG_NPAREN      3       /* \\%(\\) */\n\n/*\n * Forward declarations for vim_regcomp()'s friends.\n */\n# define REGMBC(x) regmbc(x);\n# define CASEMBC(x) case x:\n\nstatic regengine_T bt_regengine;\nstatic regengine_T nfa_regengine;\n\n// Return true if compiled regular expression \"prog\" can match a line break.\nint re_multiline(const regprog_T *prog)\n  FUNC_ATTR_NONNULL_ALL\n{\n  return prog->regflags & RF_HASNL;\n}\n\n/*\n * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['.\n * Returns a character representing the class. Zero means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\nstatic int get_equi_class(char_u **pp)\n{\n  int c;\n  int l = 1;\n  char_u      *p = *pp;\n\n  if (p[1] == '=' && p[2] != NUL) {\n    l = (*mb_ptr2len)(p + 2);\n    if (p[l + 2] == '=' && p[l + 3] == ']') {\n      c = utf_ptr2char(p + 2);\n      *pp += l + 4;\n      return c;\n    }\n  }\n  return 0;\n}\n\n\n/*\n * Produce the bytes for equivalence class \"c\".\n * Currently only handles latin1, latin9 and utf-8.\n * NOTE: When changing this function, also change nfa_emit_equi_class()\n */\nstatic void reg_equi_class(int c)\n{\n  {\n    switch (c) {\n      // Do not use '\\300' style, it results in a negative number.\n    case 'A': case 0xc0: case 0xc1: case 0xc2:\n    case 0xc3: case 0xc4: case 0xc5:\n      CASEMBC(0x100) CASEMBC(0x102) CASEMBC(0x104) CASEMBC(0x1cd)\n      CASEMBC(0x1de) CASEMBC(0x1e0) CASEMBC(0x1ea2)\n      regmbc('A'); regmbc(0xc0); regmbc(0xc1);\n      regmbc(0xc2); regmbc(0xc3); regmbc(0xc4);\n      regmbc(0xc5);\n      REGMBC(0x100) REGMBC(0x102) REGMBC(0x104)\n      REGMBC(0x1cd) REGMBC(0x1de) REGMBC(0x1e0)\n      REGMBC(0x1ea2)\n      return;\n    case 'B': CASEMBC(0x1e02) CASEMBC(0x1e06)\n      regmbc('B'); REGMBC(0x1e02) REGMBC(0x1e06)\n      return;\n    case 'C': case 0xc7:\n      CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a) CASEMBC(0x10c)\n      regmbc('C'); regmbc(0xc7);\n      REGMBC(0x106) REGMBC(0x108) REGMBC(0x10a)\n      REGMBC(0x10c)\n      return;\n    case 'D': CASEMBC(0x10e) CASEMBC(0x110) CASEMBC(0x1e0a)\n      CASEMBC(0x1e0e) CASEMBC(0x1e10)\n      regmbc('D'); REGMBC(0x10e) REGMBC(0x110)\n      REGMBC(0x1e0a) REGMBC(0x1e0e) REGMBC(0x1e10)\n      return;\n    case 'E': case 0xc8: case 0xc9: case 0xca: case 0xcb:\n      CASEMBC(0x112) CASEMBC(0x114) CASEMBC(0x116) CASEMBC(0x118)\n      CASEMBC(0x11a) CASEMBC(0x1eba) CASEMBC(0x1ebc)\n      regmbc('E'); regmbc(0xc8); regmbc(0xc9);\n      regmbc(0xca); regmbc(0xcb);\n      REGMBC(0x112) REGMBC(0x114) REGMBC(0x116)\n      REGMBC(0x118) REGMBC(0x11a) REGMBC(0x1eba)\n      REGMBC(0x1ebc)\n      return;\n    case 'F': CASEMBC(0x1e1e)\n      regmbc('F'); REGMBC(0x1e1e)\n      return;\n    case 'G': CASEMBC(0x11c) CASEMBC(0x11e) CASEMBC(0x120)\n      CASEMBC(0x122) CASEMBC(0x1e4) CASEMBC(0x1e6) CASEMBC(0x1f4)\n      CASEMBC(0x1e20)\n      regmbc('G'); REGMBC(0x11c) REGMBC(0x11e)\n      REGMBC(0x120) REGMBC(0x122) REGMBC(0x1e4)\n      REGMBC(0x1e6) REGMBC(0x1f4) REGMBC(0x1e20)\n      return;\n    case 'H': CASEMBC(0x124) CASEMBC(0x126) CASEMBC(0x1e22)\n      CASEMBC(0x1e26) CASEMBC(0x1e28)\n      regmbc('H'); REGMBC(0x124) REGMBC(0x126)\n      REGMBC(0x1e22) REGMBC(0x1e26) REGMBC(0x1e28)\n      return;\n    case 'I': case 0xcc: case 0xcd: case 0xce: case 0xcf:\n      CASEMBC(0x128) CASEMBC(0x12a) CASEMBC(0x12c) CASEMBC(0x12e)\n      CASEMBC(0x130) CASEMBC(0x1cf) CASEMBC(0x1ec8)\n      regmbc('I'); regmbc(0xcc); regmbc(0xcd);\n      regmbc(0xce); regmbc(0xcf);\n      REGMBC(0x128) REGMBC(0x12a) REGMBC(0x12c)\n      REGMBC(0x12e) REGMBC(0x130) REGMBC(0x1cf)\n      REGMBC(0x1ec8)\n      return;\n    case 'J': CASEMBC(0x134)\n      regmbc('J'); REGMBC(0x134)\n      return;\n    case 'K': CASEMBC(0x136) CASEMBC(0x1e8) CASEMBC(0x1e30)\n      CASEMBC(0x1e34)\n      regmbc('K'); REGMBC(0x136) REGMBC(0x1e8)\n      REGMBC(0x1e30) REGMBC(0x1e34)\n      return;\n    case 'L': CASEMBC(0x139) CASEMBC(0x13b) CASEMBC(0x13d)\n      CASEMBC(0x13f) CASEMBC(0x141) CASEMBC(0x1e3a)\n      regmbc('L'); REGMBC(0x139) REGMBC(0x13b)\n      REGMBC(0x13d) REGMBC(0x13f) REGMBC(0x141)\n      REGMBC(0x1e3a)\n      return;\n    case 'M': CASEMBC(0x1e3e) CASEMBC(0x1e40)\n      regmbc('M'); REGMBC(0x1e3e) REGMBC(0x1e40)\n      return;\n    case 'N': case 0xd1:\n      CASEMBC(0x143) CASEMBC(0x145) CASEMBC(0x147) CASEMBC(0x1e44)\n      CASEMBC(0x1e48)\n      regmbc('N'); regmbc(0xd1);\n      REGMBC(0x143) REGMBC(0x145) REGMBC(0x147)\n      REGMBC(0x1e44) REGMBC(0x1e48)\n      return;\n    case 'O': case 0xd2: case 0xd3: case 0xd4: case 0xd5:\n    case 0xd6: case 0xd8:\n      CASEMBC(0x14c) CASEMBC(0x14e) CASEMBC(0x150) CASEMBC(0x1a0)\n      CASEMBC(0x1d1) CASEMBC(0x1ea) CASEMBC(0x1ec) CASEMBC(0x1ece)\n      regmbc('O'); regmbc(0xd2); regmbc(0xd3);\n      regmbc(0xd4); regmbc(0xd5); regmbc(0xd6);\n      regmbc(0xd8);\n      REGMBC(0x14c) REGMBC(0x14e) REGMBC(0x150)\n      REGMBC(0x1a0) REGMBC(0x1d1) REGMBC(0x1ea)\n      REGMBC(0x1ec) REGMBC(0x1ece)\n      return;\n    case 'P': case 0x1e54: case 0x1e56:\n      regmbc('P'); REGMBC(0x1e54) REGMBC(0x1e56)\n      return;\n    case 'R': CASEMBC(0x154) CASEMBC(0x156) CASEMBC(0x158)\n      CASEMBC(0x1e58) CASEMBC(0x1e5e)\n      regmbc('R'); REGMBC(0x154) REGMBC(0x156) REGMBC(0x158)\n      REGMBC(0x1e58) REGMBC(0x1e5e)\n      return;\n    case 'S': CASEMBC(0x15a) CASEMBC(0x15c) CASEMBC(0x15e)\n      CASEMBC(0x160) CASEMBC(0x1e60)\n      regmbc('S'); REGMBC(0x15a) REGMBC(0x15c)\n      REGMBC(0x15e) REGMBC(0x160) REGMBC(0x1e60)\n      return;\n    case 'T': CASEMBC(0x162) CASEMBC(0x164) CASEMBC(0x166)\n      CASEMBC(0x1e6a) CASEMBC(0x1e6e)\n      regmbc('T'); REGMBC(0x162) REGMBC(0x164)\n      REGMBC(0x166) REGMBC(0x1e6a) REGMBC(0x1e6e)\n      return;\n    case 'U': case 0xd9: case 0xda: case 0xdb: case 0xdc:\n      CASEMBC(0x168) CASEMBC(0x16a) CASEMBC(0x16c) CASEMBC(0x16e)\n      CASEMBC(0x170) CASEMBC(0x172) CASEMBC(0x1af) CASEMBC(0x1d3)\n      CASEMBC(0x1ee6)\n      regmbc('U'); regmbc(0xd9); regmbc(0xda);\n      regmbc(0xdb); regmbc(0xdc);\n      REGMBC(0x168) REGMBC(0x16a) REGMBC(0x16c)\n      REGMBC(0x16e) REGMBC(0x170) REGMBC(0x172)\n      REGMBC(0x1af) REGMBC(0x1d3) REGMBC(0x1ee6)\n      return;\n    case 'V': CASEMBC(0x1e7c)\n      regmbc('V'); REGMBC(0x1e7c)\n      return;\n    case 'W': CASEMBC(0x174) CASEMBC(0x1e80) CASEMBC(0x1e82)\n      CASEMBC(0x1e84) CASEMBC(0x1e86)\n      regmbc('W'); REGMBC(0x174) REGMBC(0x1e80)\n      REGMBC(0x1e82) REGMBC(0x1e84) REGMBC(0x1e86)\n      return;\n    case 'X': CASEMBC(0x1e8a) CASEMBC(0x1e8c)\n      regmbc('X'); REGMBC(0x1e8a) REGMBC(0x1e8c)\n      return;\n    case 'Y': case 0xdd:\n      CASEMBC(0x176) CASEMBC(0x178) CASEMBC(0x1e8e) CASEMBC(0x1ef2)\n      CASEMBC(0x1ef6) CASEMBC(0x1ef8)\n      regmbc('Y'); regmbc(0xdd);\n      REGMBC(0x176) REGMBC(0x178) REGMBC(0x1e8e)\n      REGMBC(0x1ef2) REGMBC(0x1ef6) REGMBC(0x1ef8)\n      return;\n    case 'Z': CASEMBC(0x179) CASEMBC(0x17b) CASEMBC(0x17d)\n      CASEMBC(0x1b5) CASEMBC(0x1e90) CASEMBC(0x1e94)\n      regmbc('Z'); REGMBC(0x179) REGMBC(0x17b)\n      REGMBC(0x17d) REGMBC(0x1b5) REGMBC(0x1e90)\n      REGMBC(0x1e94)\n      return;\n    case 'a': case 0xe0: case 0xe1: case 0xe2:\n    case 0xe3: case 0xe4: case 0xe5:\n      CASEMBC(0x101) CASEMBC(0x103) CASEMBC(0x105) CASEMBC(0x1ce)\n      CASEMBC(0x1df) CASEMBC(0x1e1) CASEMBC(0x1ea3)\n      regmbc('a'); regmbc(0xe0); regmbc(0xe1);\n      regmbc(0xe2); regmbc(0xe3); regmbc(0xe4);\n      regmbc(0xe5);\n      REGMBC(0x101) REGMBC(0x103) REGMBC(0x105)\n      REGMBC(0x1ce) REGMBC(0x1df) REGMBC(0x1e1)\n      REGMBC(0x1ea3)\n      return;\n    case 'b': CASEMBC(0x1e03) CASEMBC(0x1e07)\n      regmbc('b'); REGMBC(0x1e03) REGMBC(0x1e07)\n      return;\n    case 'c': case 0xe7:\n      CASEMBC(0x107) CASEMBC(0x109) CASEMBC(0x10b) CASEMBC(0x10d)\n      regmbc('c'); regmbc(0xe7);\n      REGMBC(0x107) REGMBC(0x109) REGMBC(0x10b)\n      REGMBC(0x10d)\n      return;\n    case 'd': CASEMBC(0x10f) CASEMBC(0x111) CASEMBC(0x1e0b)\n      CASEMBC(0x1e0f) CASEMBC(0x1e11)\n      regmbc('d'); REGMBC(0x10f) REGMBC(0x111)\n      REGMBC(0x1e0b) REGMBC(0x1e0f) REGMBC(0x1e11)\n      return;\n    case 'e': case 0xe8: case 0xe9: case 0xea: case 0xeb:\n      CASEMBC(0x113) CASEMBC(0x115) CASEMBC(0x117) CASEMBC(0x119)\n      CASEMBC(0x11b) CASEMBC(0x1ebb) CASEMBC(0x1ebd)\n      regmbc('e'); regmbc(0xe8); regmbc(0xe9);\n      regmbc(0xea); regmbc(0xeb);\n      REGMBC(0x113) REGMBC(0x115) REGMBC(0x117)\n      REGMBC(0x119) REGMBC(0x11b) REGMBC(0x1ebb)\n      REGMBC(0x1ebd)\n      return;\n    case 'f': CASEMBC(0x1e1f)\n      regmbc('f'); REGMBC(0x1e1f)\n      return;\n    case 'g': CASEMBC(0x11d) CASEMBC(0x11f) CASEMBC(0x121)\n      CASEMBC(0x123) CASEMBC(0x1e5) CASEMBC(0x1e7) CASEMBC(0x1f5)\n      CASEMBC(0x1e21)\n      regmbc('g'); REGMBC(0x11d) REGMBC(0x11f)\n      REGMBC(0x121) REGMBC(0x123) REGMBC(0x1e5)\n      REGMBC(0x1e7) REGMBC(0x1f5) REGMBC(0x1e21)\n      return;\n    case 'h': CASEMBC(0x125) CASEMBC(0x127) CASEMBC(0x1e23)\n      CASEMBC(0x1e27) CASEMBC(0x1e29) CASEMBC(0x1e96)\n      regmbc('h'); REGMBC(0x125) REGMBC(0x127)\n      REGMBC(0x1e23) REGMBC(0x1e27) REGMBC(0x1e29)\n      REGMBC(0x1e96)\n      return;\n    case 'i': case 0xec: case 0xed: case 0xee: case 0xef:\n      CASEMBC(0x129) CASEMBC(0x12b) CASEMBC(0x12d) CASEMBC(0x12f)\n      CASEMBC(0x1d0) CASEMBC(0x1ec9)\n      regmbc('i'); regmbc(0xec); regmbc(0xed);\n      regmbc(0xee); regmbc(0xef);\n      REGMBC(0x129) REGMBC(0x12b) REGMBC(0x12d)\n      REGMBC(0x12f) REGMBC(0x1d0) REGMBC(0x1ec9)\n      return;\n    case 'j': CASEMBC(0x135) CASEMBC(0x1f0)\n      regmbc('j'); REGMBC(0x135) REGMBC(0x1f0)\n      return;\n    case 'k': CASEMBC(0x137) CASEMBC(0x1e9) CASEMBC(0x1e31)\n      CASEMBC(0x1e35)\n      regmbc('k'); REGMBC(0x137) REGMBC(0x1e9)\n      REGMBC(0x1e31) REGMBC(0x1e35)\n      return;\n    case 'l': CASEMBC(0x13a) CASEMBC(0x13c) CASEMBC(0x13e)\n      CASEMBC(0x140) CASEMBC(0x142) CASEMBC(0x1e3b)\n      regmbc('l'); REGMBC(0x13a) REGMBC(0x13c)\n      REGMBC(0x13e) REGMBC(0x140) REGMBC(0x142)\n      REGMBC(0x1e3b)\n      return;\n    case 'm': CASEMBC(0x1e3f) CASEMBC(0x1e41)\n      regmbc('m'); REGMBC(0x1e3f) REGMBC(0x1e41)\n      return;\n    case 'n': case 0xf1:\n      CASEMBC(0x144) CASEMBC(0x146) CASEMBC(0x148) CASEMBC(0x149)\n      CASEMBC(0x1e45) CASEMBC(0x1e49)\n      regmbc('n'); regmbc(0xf1);\n      REGMBC(0x144) REGMBC(0x146) REGMBC(0x148)\n      REGMBC(0x149) REGMBC(0x1e45) REGMBC(0x1e49)\n      return;\n    case 'o': case 0xf2: case 0xf3: case 0xf4: case 0xf5:\n    case 0xf6: case 0xf8:\n      CASEMBC(0x14d) CASEMBC(0x14f) CASEMBC(0x151) CASEMBC(0x1a1)\n      CASEMBC(0x1d2) CASEMBC(0x1eb) CASEMBC(0x1ed) CASEMBC(0x1ecf)\n      regmbc('o'); regmbc(0xf2); regmbc(0xf3);\n      regmbc(0xf4); regmbc(0xf5); regmbc(0xf6);\n      regmbc(0xf8);\n      REGMBC(0x14d) REGMBC(0x14f) REGMBC(0x151)\n      REGMBC(0x1a1) REGMBC(0x1d2) REGMBC(0x1eb)\n      REGMBC(0x1ed) REGMBC(0x1ecf)\n      return;\n    case 'p': CASEMBC(0x1e55) CASEMBC(0x1e57)\n      regmbc('p'); REGMBC(0x1e55) REGMBC(0x1e57)\n      return;\n    case 'r': CASEMBC(0x155) CASEMBC(0x157) CASEMBC(0x159)\n      CASEMBC(0x1e59) CASEMBC(0x1e5f)\n      regmbc('r'); REGMBC(0x155) REGMBC(0x157) REGMBC(0x159)\n      REGMBC(0x1e59) REGMBC(0x1e5f)\n      return;\n    case 's': CASEMBC(0x15b) CASEMBC(0x15d) CASEMBC(0x15f)\n      CASEMBC(0x161) CASEMBC(0x1e61)\n      regmbc('s'); REGMBC(0x15b) REGMBC(0x15d)\n      REGMBC(0x15f) REGMBC(0x161) REGMBC(0x1e61)\n      return;\n    case 't': CASEMBC(0x163) CASEMBC(0x165) CASEMBC(0x167)\n      CASEMBC(0x1e6b) CASEMBC(0x1e6f) CASEMBC(0x1e97)\n      regmbc('t'); REGMBC(0x163) REGMBC(0x165) REGMBC(0x167)\n      REGMBC(0x1e6b) REGMBC(0x1e6f) REGMBC(0x1e97)\n      return;\n    case 'u': case 0xf9: case 0xfa: case 0xfb: case 0xfc:\n      CASEMBC(0x169) CASEMBC(0x16b) CASEMBC(0x16d) CASEMBC(0x16f)\n      CASEMBC(0x171) CASEMBC(0x173) CASEMBC(0x1b0) CASEMBC(0x1d4)\n      CASEMBC(0x1ee7)\n      regmbc('u'); regmbc(0xf9); regmbc(0xfa);\n      regmbc(0xfb); regmbc(0xfc);\n      REGMBC(0x169) REGMBC(0x16b) REGMBC(0x16d)\n      REGMBC(0x16f) REGMBC(0x171) REGMBC(0x173)\n      REGMBC(0x1b0) REGMBC(0x1d4) REGMBC(0x1ee7)\n      return;\n    case 'v': CASEMBC(0x1e7d)\n      regmbc('v'); REGMBC(0x1e7d)\n      return;\n    case 'w': CASEMBC(0x175) CASEMBC(0x1e81) CASEMBC(0x1e83)\n      CASEMBC(0x1e85) CASEMBC(0x1e87) CASEMBC(0x1e98)\n      regmbc('w'); REGMBC(0x175) REGMBC(0x1e81)\n      REGMBC(0x1e83) REGMBC(0x1e85) REGMBC(0x1e87)\n      REGMBC(0x1e98)\n      return;\n    case 'x': CASEMBC(0x1e8b) CASEMBC(0x1e8d)\n      regmbc('x'); REGMBC(0x1e8b) REGMBC(0x1e8d)\n      return;\n    case 'y': case 0xfd: case 0xff:\n      CASEMBC(0x177) CASEMBC(0x1e8f) CASEMBC(0x1e99)\n      CASEMBC(0x1ef3) CASEMBC(0x1ef7) CASEMBC(0x1ef9)\n      regmbc('y'); regmbc(0xfd); regmbc(0xff);\n      REGMBC(0x177) REGMBC(0x1e8f) REGMBC(0x1e99)\n      REGMBC(0x1ef3) REGMBC(0x1ef7) REGMBC(0x1ef9)\n      return;\n    case 'z': CASEMBC(0x17a) CASEMBC(0x17c) CASEMBC(0x17e)\n      CASEMBC(0x1b6) CASEMBC(0x1e91) CASEMBC(0x1e95)\n      regmbc('z'); REGMBC(0x17a) REGMBC(0x17c)\n      REGMBC(0x17e) REGMBC(0x1b6) REGMBC(0x1e91)\n      REGMBC(0x1e95)\n      return;\n    }\n  }\n  regmbc(c);\n}\n\n/*\n * Check for a collating element \"[.a.]\".  \"pp\" points to the '['.\n * Returns a character. Zero means that no item was recognized.  Otherwise\n * \"pp\" is advanced to after the item.\n * Currently only single characters are recognized!\n */\nstatic int get_coll_element(char_u **pp)\n{\n  int c;\n  int l = 1;\n  char_u      *p = *pp;\n\n  if (p[0] != NUL && p[1] == '.' && p[2] != NUL) {\n    l = utfc_ptr2len(p + 2);\n    if (p[l + 2] == '.' && p[l + 3] == ']') {\n      c = utf_ptr2char(p + 2);\n      *pp += l + 4;\n      return c;\n    }\n  }\n  return 0;\n}\n\nstatic int reg_cpo_lit; /* 'cpoptions' contains 'l' flag */\n\nstatic void get_cpo_flags(void)\n{\n  reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;\n}\n\n/*\n * Skip over a \"[]\" range.\n * \"p\" must point to the character after the '['.\n * The returned pointer is on the matching ']', or the terminating NUL.\n */\nstatic char_u *skip_anyof(char_u *p)\n{\n  int l;\n\n  if (*p == '^')        /* Complement of range. */\n    ++p;\n  if (*p == ']' || *p == '-')\n    ++p;\n  while (*p != NUL && *p != ']') {\n    if ((l = (*mb_ptr2len)(p)) > 1) {\n      p += l;\n    } else if (*p == '-')  {\n      p++;\n      if (*p != ']' && *p != NUL) {\n        MB_PTR_ADV(p);\n      }\n    } else if (*p == '\\\\'\n               && (vim_strchr(REGEXP_INRANGE, p[1]) != NULL\n                   || (!reg_cpo_lit\n                       && vim_strchr(REGEXP_ABBR, p[1]) != NULL))) {\n      p += 2;\n    } else if (*p == '[') {\n      if (get_char_class(&p) == CLASS_NONE\n          && get_equi_class(&p) == 0\n          && get_coll_element(&p) == 0\n          && *p != NUL) {\n        p++;          // It is not a class name and not NUL\n      }\n    } else {\n      p++;\n    }\n  }\n\n  return p;\n}\n\n/*\n * Skip past regular expression.\n * Stop at end of \"startp\" or where \"dirc\" is found ('/', '?', etc).\n * Take care of characters with a backslash in front of it.\n * Skip strings inside [ and ].\n * When \"newp\" is not NULL and \"dirc\" is '?', make an allocated copy of the\n * expression and change \"\\?\" to \"?\".  If \"*newp\" is not NULL the expression\n * is changed in-place.\n */\nchar_u *skip_regexp(char_u *startp, int dirc, int magic, char_u **newp)\n{\n  int mymagic;\n  char_u      *p = startp;\n\n  if (magic)\n    mymagic = MAGIC_ON;\n  else\n    mymagic = MAGIC_OFF;\n  get_cpo_flags();\n\n  for (; p[0] != NUL; MB_PTR_ADV(p)) {\n    if (p[0] == dirc) {         // found end of regexp\n      break;\n    }\n    if ((p[0] == '[' && mymagic >= MAGIC_ON)\n        || (p[0] == '\\\\' && p[1] == '[' && mymagic <= MAGIC_OFF)) {\n      p = skip_anyof(p + 1);\n      if (p[0] == NUL)\n        break;\n    } else if (p[0] == '\\\\' && p[1] != NUL)   {\n      if (dirc == '?' && newp != NULL && p[1] == '?') {\n        /* change \"\\?\" to \"?\", make a copy first. */\n        if (*newp == NULL) {\n          *newp = vim_strsave(startp);\n          p = *newp + (p - startp);\n        }\n        STRMOVE(p, p + 1);\n      } else\n        ++p;            /* skip next character */\n      if (*p == 'v')\n        mymagic = MAGIC_ALL;\n      else if (*p == 'V')\n        mymagic = MAGIC_NONE;\n    }\n  }\n  return p;\n}\n\n/// Return true if the back reference is legal. We must have seen the close\n/// brace.\n/// TODO(vim): Should also check that we don't refer to something repeated\n/// (+*=): what instance of the repetition should we match?\nstatic int seen_endbrace(int refnum)\n{\n  if (!had_endbrace[refnum]) {\n      char_u *p;\n\n      // Trick: check if \"@<=\" or \"@<!\" follows, in which case\n      // the \\1 can appear before the referenced match.\n      for (p = regparse; *p != NUL; p++) {\n        if (p[0] == '@' && p[1] == '<' && (p[2] == '!' || p[2] == '=')) {\n          break;\n        }\n      }\n\n    if (*p == NUL) {\n      EMSG(_(\"E65: Illegal back reference\"));\n      rc_did_emsg = true;\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n * bt_regcomp() - compile a regular expression into internal code for the\n * traditional back track matcher.\n * Returns the program in allocated space.  Returns NULL for an error.\n *\n * We can't allocate space until we know how big the compiled form will be,\n * but we can't compile it (and thus know how big it is) until we've got a\n * place to put the code.  So we cheat:  we compile it twice, once with code\n * generation turned off and size counting turned on, and once \"for real\".\n * This also means that we don't allocate space until we are sure that the\n * thing really will compile successfully, and we never have to move the\n * code and thus invalidate pointers into it.  (Note that it has to be in\n * one piece because free() must be able to free it all.)\n *\n * Whether upper/lower case is to be ignored is decided when executing the\n * program, it does not matter here.\n *\n * Beware that the optimization-preparation code in here knows about some\n * of the structure of the compiled regexp.\n * \"re_flags\": RE_MAGIC and/or RE_STRING.\n */\nstatic regprog_T *bt_regcomp(char_u *expr, int re_flags)\n{\n  char_u      *scan;\n  char_u      *longest;\n  int len;\n  int flags;\n\n  if (expr == NULL) {\n    IEMSG_RET_NULL(_(e_null));\n  }\n\n  init_class_tab();\n\n  /*\n   * First pass: determine size, legality.\n   */\n  regcomp_start(expr, re_flags);\n  regcode = JUST_CALC_SIZE;\n  regc(REGMAGIC);\n  if (reg(REG_NOPAREN, &flags) == NULL)\n    return NULL;\n\n  /* Allocate space. */\n  bt_regprog_T *r = xmalloc(sizeof(bt_regprog_T) + regsize);\n  r->re_in_use = false;\n\n  /*\n   * Second pass: emit code.\n   */\n  regcomp_start(expr, re_flags);\n  regcode = r->program;\n  regc(REGMAGIC);\n  if (reg(REG_NOPAREN, &flags) == NULL || reg_toolong) {\n    xfree(r);\n    if (reg_toolong)\n      EMSG_RET_NULL(_(\"E339: Pattern too long\"));\n    return NULL;\n  }\n\n  /* Dig out information for optimizations. */\n  r->regstart = NUL;            /* Worst-case defaults. */\n  r->reganch = 0;\n  r->regmust = NULL;\n  r->regmlen = 0;\n  r->regflags = regflags;\n  if (flags & HASNL)\n    r->regflags |= RF_HASNL;\n  if (flags & HASLOOKBH)\n    r->regflags |= RF_LOOKBH;\n  /* Remember whether this pattern has any \\z specials in it. */\n  r->reghasz = re_has_z;\n  scan = r->program + 1;        /* First BRANCH. */\n  if (OP(regnext(scan)) == END) {   /* Only one top-level choice. */\n    scan = OPERAND(scan);\n\n    /* Starting-point info. */\n    if (OP(scan) == BOL || OP(scan) == RE_BOF) {\n      r->reganch++;\n      scan = regnext(scan);\n    }\n\n    if (OP(scan) == EXACTLY) {\n      r->regstart = utf_ptr2char(OPERAND(scan));\n    } else if (OP(scan) == BOW\n               || OP(scan) == EOW\n               || OP(scan) == NOTHING\n               || OP(scan) == MOPEN  + 0 || OP(scan) == NOPEN\n               || OP(scan) == MCLOSE + 0 || OP(scan) == NCLOSE) {\n      char_u *regnext_scan = regnext(scan);\n      if (OP(regnext_scan) == EXACTLY) {\n        r->regstart = utf_ptr2char(OPERAND(regnext_scan));\n      }\n    }\n\n    /*\n     * If there's something expensive in the r.e., find the longest\n     * literal string that must appear and make it the regmust.  Resolve\n     * ties in favor of later strings, since the regstart check works\n     * with the beginning of the r.e. and avoiding duplication\n     * strengthens checking.  Not a strong reason, but sufficient in the\n     * absence of others.\n     */\n    /*\n     * When the r.e. starts with BOW, it is faster to look for a regmust\n     * first. Used a lot for \"#\" and \"*\" commands. (Added by mool).\n     */\n    if ((flags & SPSTART || OP(scan) == BOW || OP(scan) == EOW)\n        && !(flags & HASNL)) {\n      longest = NULL;\n      len = 0;\n      for (; scan != NULL; scan = regnext(scan))\n        if (OP(scan) == EXACTLY && STRLEN(OPERAND(scan)) >= (size_t)len) {\n          longest = OPERAND(scan);\n          len = (int)STRLEN(OPERAND(scan));\n        }\n      r->regmust = longest;\n      r->regmlen = len;\n    }\n  }\n#ifdef BT_REGEXP_DUMP\n  regdump(expr, r);\n#endif\n  r->engine = &bt_regengine;\n  return (regprog_T *)r;\n}\n\n/*\n * Free a compiled regexp program, returned by bt_regcomp().\n */\nstatic void bt_regfree(regprog_T *prog)\n{\n  xfree(prog);\n}\n\n/*\n * Setup to parse the regexp.  Used once to get the length and once to do it.\n */\nstatic void \nregcomp_start (\n    char_u *expr,\n    int re_flags                       /* see vim_regcomp() */\n)\n{\n  initchr(expr);\n  if (re_flags & RE_MAGIC)\n    reg_magic = MAGIC_ON;\n  else\n    reg_magic = MAGIC_OFF;\n  reg_string = (re_flags & RE_STRING);\n  reg_strict = (re_flags & RE_STRICT);\n  get_cpo_flags();\n\n  num_complex_braces = 0;\n  regnpar = 1;\n  memset(had_endbrace, 0, sizeof(had_endbrace));\n  regnzpar = 1;\n  re_has_z = 0;\n  regsize = 0L;\n  reg_toolong = false;\n  regflags = 0;\n  had_eol = false;\n}\n\n/*\n * Check if during the previous call to vim_regcomp the EOL item \"$\" has been\n * found.  This is messy, but it works fine.\n */\nint vim_regcomp_had_eol(void)\n{\n  return had_eol;\n}\n\n// variables used for parsing\nstatic int at_start;       // True when on the first character\nstatic int prev_at_start;  // True when on the second character\n\n/*\n * Parse regular expression, i.e. main body or parenthesized thing.\n *\n * Caller must absorb opening parenthesis.\n *\n * Combining parenthesis handling with the base level of regular expression\n * is a trifle forced, but the need to tie the tails of the branches to what\n * follows makes it hard to avoid.\n */\nstatic char_u *\nreg (\n    int paren,              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */\n    int *flagp\n)\n{\n  char_u      *ret;\n  char_u      *br;\n  char_u      *ender;\n  int parno = 0;\n  int flags;\n\n  *flagp = HASWIDTH;            /* Tentatively. */\n\n  if (paren == REG_ZPAREN) {\n    /* Make a ZOPEN node. */\n    if (regnzpar >= NSUBEXP)\n      EMSG_RET_NULL(_(\"E50: Too many \\\\z(\"));\n    parno = regnzpar;\n    regnzpar++;\n    ret = regnode(ZOPEN + parno);\n  } else if (paren == REG_PAREN)    {\n    /* Make a MOPEN node. */\n    if (regnpar >= NSUBEXP)\n      EMSG2_RET_NULL(_(\"E51: Too many %s(\"), reg_magic == MAGIC_ALL);\n    parno = regnpar;\n    ++regnpar;\n    ret = regnode(MOPEN + parno);\n  } else if (paren == REG_NPAREN)   {\n    /* Make a NOPEN node. */\n    ret = regnode(NOPEN);\n  } else\n    ret = NULL;\n\n  /* Pick up the branches, linking them together. */\n  br = regbranch(&flags);\n  if (br == NULL)\n    return NULL;\n  if (ret != NULL)\n    regtail(ret, br);           /* [MZ]OPEN -> first. */\n  else\n    ret = br;\n  /* If one of the branches can be zero-width, the whole thing can.\n   * If one of the branches has * at start or matches a line-break, the\n   * whole thing can. */\n  if (!(flags & HASWIDTH))\n    *flagp &= ~HASWIDTH;\n  *flagp |= flags & (SPSTART | HASNL | HASLOOKBH);\n  while (peekchr() == Magic('|')) {\n    skipchr();\n    br = regbranch(&flags);\n    if (br == NULL || reg_toolong)\n      return NULL;\n    regtail(ret, br);           /* BRANCH -> BRANCH. */\n    if (!(flags & HASWIDTH))\n      *flagp &= ~HASWIDTH;\n    *flagp |= flags & (SPSTART | HASNL | HASLOOKBH);\n  }\n\n  /* Make a closing node, and hook it on the end. */\n  ender = regnode(\n      paren == REG_ZPAREN ? ZCLOSE + parno :\n      paren == REG_PAREN ? MCLOSE + parno :\n      paren == REG_NPAREN ? NCLOSE : END);\n  regtail(ret, ender);\n\n  /* Hook the tails of the branches to the closing node. */\n  for (br = ret; br != NULL; br = regnext(br))\n    regoptail(br, ender);\n\n  /* Check for proper termination. */\n  if (paren != REG_NOPAREN && getchr() != Magic(')')) {\n    if (paren == REG_ZPAREN)\n      EMSG_RET_NULL(_(\"E52: Unmatched \\\\z(\"));\n    else if (paren == REG_NPAREN)\n      EMSG2_RET_NULL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);\n    else\n      EMSG2_RET_NULL(_(e_unmatchedp), reg_magic == MAGIC_ALL);\n  } else if (paren == REG_NOPAREN && peekchr() != NUL) {\n    if (curchr == Magic(')'))\n      EMSG2_RET_NULL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);\n    else\n      EMSG_RET_NULL(_(e_trailing));             /* \"Can't happen\". */\n    /* NOTREACHED */\n  }\n  // Here we set the flag allowing back references to this set of\n  // parentheses.\n  if (paren == REG_PAREN) {\n    had_endbrace[parno] = true;  // have seen the close paren\n  }\n  return ret;\n}\n\n/*\n * Parse one alternative of an | operator.\n * Implements the & operator.\n */\nstatic char_u *regbranch(int *flagp)\n{\n  char_u      *ret;\n  char_u      *chain = NULL;\n  char_u      *latest;\n  int flags;\n\n  *flagp = WORST | HASNL;               /* Tentatively. */\n\n  ret = regnode(BRANCH);\n  for (;; ) {\n    latest = regconcat(&flags);\n    if (latest == NULL)\n      return NULL;\n    /* If one of the branches has width, the whole thing has.  If one of\n     * the branches anchors at start-of-line, the whole thing does.\n     * If one of the branches uses look-behind, the whole thing does. */\n    *flagp |= flags & (HASWIDTH | SPSTART | HASLOOKBH);\n    /* If one of the branches doesn't match a line-break, the whole thing\n     * doesn't. */\n    *flagp &= ~HASNL | (flags & HASNL);\n    if (chain != NULL)\n      regtail(chain, latest);\n    if (peekchr() != Magic('&'))\n      break;\n    skipchr();\n    regtail(latest, regnode(END));     /* operand ends */\n    if (reg_toolong)\n      break;\n    reginsert(MATCH, latest);\n    chain = latest;\n  }\n\n  return ret;\n}\n\n/*\n * Parse one alternative of an | or & operator.\n * Implements the concatenation operator.\n */\nstatic char_u *regconcat(int *flagp)\n{\n  char_u      *first = NULL;\n  char_u      *chain = NULL;\n  char_u      *latest;\n  int flags;\n  int cont = true;\n\n  *flagp = WORST;               /* Tentatively. */\n\n  while (cont) {\n    switch (peekchr()) {\n    case NUL:\n    case Magic('|'):\n    case Magic('&'):\n    case Magic(')'):\n      cont = false;\n      break;\n    case Magic('Z'):\n      regflags |= RF_ICOMBINE;\n      skipchr_keepstart();\n      break;\n    case Magic('c'):\n      regflags |= RF_ICASE;\n      skipchr_keepstart();\n      break;\n    case Magic('C'):\n      regflags |= RF_NOICASE;\n      skipchr_keepstart();\n      break;\n    case Magic('v'):\n      reg_magic = MAGIC_ALL;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n    case Magic('m'):\n      reg_magic = MAGIC_ON;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n    case Magic('M'):\n      reg_magic = MAGIC_OFF;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n    case Magic('V'):\n      reg_magic = MAGIC_NONE;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n    default:\n      latest = regpiece(&flags);\n      if (latest == NULL || reg_toolong)\n        return NULL;\n      *flagp |= flags & (HASWIDTH | HASNL | HASLOOKBH);\n      if (chain == NULL)                        /* First piece. */\n        *flagp |= flags & SPSTART;\n      else\n        regtail(chain, latest);\n      chain = latest;\n      if (first == NULL)\n        first = latest;\n      break;\n    }\n  }\n  if (first == NULL)            /* Loop ran zero times. */\n    first = regnode(NOTHING);\n  return first;\n}\n\n/*\n * Parse something followed by possible [*+=].\n *\n * Note that the branching code sequences used for = and the general cases\n * of * and + are somewhat optimized:  they use the same NOTHING node as\n * both the endmarker for their branch list and the body of the last branch.\n * It might seem that this node could be dispensed with entirely, but the\n * endmarker role is not redundant.\n */\nstatic char_u *regpiece(int *flagp)\n{\n  char_u          *ret;\n  int op;\n  char_u          *next;\n  int flags;\n  long minval;\n  long maxval;\n\n  ret = regatom(&flags);\n  if (ret == NULL)\n    return NULL;\n\n  op = peekchr();\n  if (re_multi_type(op) == NOT_MULTI) {\n    *flagp = flags;\n    return ret;\n  }\n  /* default flags */\n  *flagp = (WORST | SPSTART | (flags & (HASNL | HASLOOKBH)));\n\n  skipchr();\n  switch (op) {\n  case Magic('*'):\n    if (flags & SIMPLE)\n      reginsert(STAR, ret);\n    else {\n      /* Emit x* as (x&|), where & means \"self\". */\n      reginsert(BRANCH, ret);           /* Either x */\n      regoptail(ret, regnode(BACK));            /* and loop */\n      regoptail(ret, ret);              /* back */\n      regtail(ret, regnode(BRANCH));            /* or */\n      regtail(ret, regnode(NOTHING));           /* null. */\n    }\n    break;\n\n  case Magic('+'):\n    if (flags & SIMPLE)\n      reginsert(PLUS, ret);\n    else {\n      /* Emit x+ as x(&|), where & means \"self\". */\n      next = regnode(BRANCH);           /* Either */\n      regtail(ret, next);\n      regtail(regnode(BACK), ret);              /* loop back */\n      regtail(next, regnode(BRANCH));           /* or */\n      regtail(ret, regnode(NOTHING));           /* null. */\n    }\n    *flagp = (WORST | HASWIDTH | (flags & (HASNL | HASLOOKBH)));\n    break;\n\n  case Magic('@'):\n  {\n    int lop = END;\n    int64_t nr = getdecchrs();\n\n    switch (no_Magic(getchr())) {\n    case '=': lop = MATCH; break;                                 /* \\@= */\n    case '!': lop = NOMATCH; break;                               /* \\@! */\n    case '>': lop = SUBPAT; break;                                /* \\@> */\n    case '<': switch (no_Magic(getchr())) {\n      case '=': lop = BEHIND; break;                               /* \\@<= */\n      case '!': lop = NOBEHIND; break;                             /* \\@<! */\n    }\n    }\n    if (lop == END)\n      EMSG2_RET_NULL(_(\"E59: invalid character after %s@\"),\n          reg_magic == MAGIC_ALL);\n    /* Look behind must match with behind_pos. */\n    if (lop == BEHIND || lop == NOBEHIND) {\n      regtail(ret, regnode(BHPOS));\n      *flagp |= HASLOOKBH;\n    }\n    regtail(ret, regnode(END));             /* operand ends */\n    if (lop == BEHIND || lop == NOBEHIND) {\n      if (nr < 0)\n        nr = 0;                 /* no limit is same as zero limit */\n      reginsert_nr(lop, (uint32_t)nr, ret);\n    } else\n      reginsert(lop, ret);\n    break;\n  }\n\n  case Magic('?'):\n  case Magic('='):\n    /* Emit x= as (x|) */\n    reginsert(BRANCH, ret);                     /* Either x */\n    regtail(ret, regnode(BRANCH));              /* or */\n    next = regnode(NOTHING);                    /* null. */\n    regtail(ret, next);\n    regoptail(ret, next);\n    break;\n\n  case Magic('{'):\n    if (!read_limits(&minval, &maxval))\n      return NULL;\n    if (flags & SIMPLE) {\n      reginsert(BRACE_SIMPLE, ret);\n      reginsert_limits(BRACE_LIMITS, minval, maxval, ret);\n    } else {\n      if (num_complex_braces >= 10)\n        EMSG2_RET_NULL(_(\"E60: Too many complex %s{...}s\"),\n            reg_magic == MAGIC_ALL);\n      reginsert(BRACE_COMPLEX + num_complex_braces, ret);\n      regoptail(ret, regnode(BACK));\n      regoptail(ret, ret);\n      reginsert_limits(BRACE_LIMITS, minval, maxval, ret);\n      ++num_complex_braces;\n    }\n    if (minval > 0 && maxval > 0)\n      *flagp = (HASWIDTH | (flags & (HASNL | HASLOOKBH)));\n    break;\n  }\n  if (re_multi_type(peekchr()) != NOT_MULTI) {\n    /* Can't have a multi follow a multi. */\n    if (peekchr() == Magic('*'))\n      sprintf((char *)IObuff, _(\"E61: Nested %s*\"),\n          reg_magic >= MAGIC_ON ? \"\" : \"\\\\\");\n    else\n      sprintf((char *)IObuff, _(\"E62: Nested %s%c\"),\n          reg_magic == MAGIC_ALL ? \"\" : \"\\\\\", no_Magic(peekchr()));\n    EMSG_RET_NULL(IObuff);\n  }\n\n  return ret;\n}\n\n/* When making changes to classchars also change nfa_classcodes. */\nstatic char_u   *classchars = (char_u *)\".iIkKfFpPsSdDxXoOwWhHaAlLuU\";\nstatic int classcodes[] = {\n  ANY, IDENT, SIDENT, KWORD, SKWORD,\n  FNAME, SFNAME, PRINT, SPRINT,\n  WHITE, NWHITE, DIGIT, NDIGIT,\n  HEX, NHEX, OCTAL, NOCTAL,\n  WORD, NWORD, HEAD, NHEAD,\n  ALPHA, NALPHA, LOWER, NLOWER,\n  UPPER, NUPPER\n};\n\n/*\n * Parse the lowest level.\n *\n * Optimization:  gobbles an entire sequence of ordinary characters so that\n * it can turn them into a single node, which is smaller to store and\n * faster to run.  Don't do this when one_exactly is set.\n */\nstatic char_u *regatom(int *flagp)\n{\n  char_u          *ret;\n  int flags;\n  int c;\n  char_u          *p;\n  int extra = 0;\n  int save_prev_at_start = prev_at_start;\n\n  *flagp = WORST;               /* Tentatively. */\n\n  c = getchr();\n  switch (c) {\n  case Magic('^'):\n    ret = regnode(BOL);\n    break;\n\n  case Magic('$'):\n    ret = regnode(EOL);\n    had_eol = true;\n    break;\n\n  case Magic('<'):\n    ret = regnode(BOW);\n    break;\n\n  case Magic('>'):\n    ret = regnode(EOW);\n    break;\n\n  case Magic('_'):\n    c = no_Magic(getchr());\n    if (c == '^') {             /* \"\\_^\" is start-of-line */\n      ret = regnode(BOL);\n      break;\n    }\n    if (c == '$') {             /* \"\\_$\" is end-of-line */\n      ret = regnode(EOL);\n      had_eol = true;\n      break;\n    }\n\n    extra = ADD_NL;\n    *flagp |= HASNL;\n\n    /* \"\\_[\" is character range plus newline */\n    if (c == '[')\n      goto collection;\n\n  // \"\\_x\" is character class plus newline\n  FALLTHROUGH;\n\n  /*\n   * Character classes.\n   */\n  case Magic('.'):\n  case Magic('i'):\n  case Magic('I'):\n  case Magic('k'):\n  case Magic('K'):\n  case Magic('f'):\n  case Magic('F'):\n  case Magic('p'):\n  case Magic('P'):\n  case Magic('s'):\n  case Magic('S'):\n  case Magic('d'):\n  case Magic('D'):\n  case Magic('x'):\n  case Magic('X'):\n  case Magic('o'):\n  case Magic('O'):\n  case Magic('w'):\n  case Magic('W'):\n  case Magic('h'):\n  case Magic('H'):\n  case Magic('a'):\n  case Magic('A'):\n  case Magic('l'):\n  case Magic('L'):\n  case Magic('u'):\n  case Magic('U'):\n    p = vim_strchr(classchars, no_Magic(c));\n    if (p == NULL)\n      EMSG_RET_NULL(_(\"E63: invalid use of \\\\_\"));\n    /* When '.' is followed by a composing char ignore the dot, so that\n     * the composing char is matched here. */\n    if (c == Magic('.') && utf_iscomposing(peekchr())) {\n      c = getchr();\n      goto do_multibyte;\n    }\n    ret = regnode(classcodes[p - classchars] + extra);\n    *flagp |= HASWIDTH | SIMPLE;\n    break;\n\n  case Magic('n'):\n    if (reg_string) {\n      /* In a string \"\\n\" matches a newline character. */\n      ret = regnode(EXACTLY);\n      regc(NL);\n      regc(NUL);\n      *flagp |= HASWIDTH | SIMPLE;\n    } else {\n      /* In buffer text \"\\n\" matches the end of a line. */\n      ret = regnode(NEWL);\n      *flagp |= HASWIDTH | HASNL;\n    }\n    break;\n\n  case Magic('('):\n    if (one_exactly)\n      EMSG_ONE_RET_NULL;\n    ret = reg(REG_PAREN, &flags);\n    if (ret == NULL)\n      return NULL;\n    *flagp |= flags & (HASWIDTH | SPSTART | HASNL | HASLOOKBH);\n    break;\n\n  case NUL:\n  case Magic('|'):\n  case Magic('&'):\n  case Magic(')'):\n    if (one_exactly)\n      EMSG_ONE_RET_NULL;\n    IEMSG_RET_NULL(_(e_internal));       // Supposed to be caught earlier.\n  // NOTREACHED\n\n  case Magic('='):\n  case Magic('?'):\n  case Magic('+'):\n  case Magic('@'):\n  case Magic('{'):\n  case Magic('*'):\n    c = no_Magic(c);\n    sprintf((char *)IObuff, _(\"E64: %s%c follows nothing\"),\n        (c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL)\n        ? \"\" : \"\\\\\", c);\n    EMSG_RET_NULL(IObuff);\n  /* NOTREACHED */\n\n  case Magic('~'):              /* previous substitute pattern */\n    if (reg_prev_sub != NULL) {\n      char_u      *lp;\n\n      ret = regnode(EXACTLY);\n      lp = reg_prev_sub;\n      while (*lp != NUL)\n        regc(*lp++);\n      regc(NUL);\n      if (*reg_prev_sub != NUL) {\n        *flagp |= HASWIDTH;\n        if ((lp - reg_prev_sub) == 1)\n          *flagp |= SIMPLE;\n      }\n    } else\n      EMSG_RET_NULL(_(e_nopresub));\n    break;\n\n  case Magic('1'):\n  case Magic('2'):\n  case Magic('3'):\n  case Magic('4'):\n  case Magic('5'):\n  case Magic('6'):\n  case Magic('7'):\n  case Magic('8'):\n  case Magic('9'):\n  {\n    int refnum;\n\n    refnum = c - Magic('0');\n    if (!seen_endbrace(refnum)) {\n      return NULL;\n    }\n    ret = regnode(BACKREF + refnum);\n  }\n  break;\n\n  case Magic('z'):\n  {\n    c = no_Magic(getchr());\n    switch (c) {\n    case '(': if ((reg_do_extmatch & REX_SET) == 0)\n        EMSG_RET_NULL(_(e_z_not_allowed));\n      if (one_exactly)\n        EMSG_ONE_RET_NULL;\n      ret = reg(REG_ZPAREN, &flags);\n      if (ret == NULL)\n        return NULL;\n      *flagp |= flags & (HASWIDTH|SPSTART|HASNL|HASLOOKBH);\n      re_has_z = REX_SET;\n      break;\n\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9': if ((reg_do_extmatch & REX_USE) == 0)\n        EMSG_RET_NULL(_(e_z1_not_allowed));\n      ret = regnode(ZREF + c - '0');\n      re_has_z = REX_USE;\n      break;\n\n    case 's': ret = regnode(MOPEN + 0);\n      if (!re_mult_next(\"\\\\zs\")) {\n        return NULL;\n      }\n      break;\n\n    case 'e': ret = regnode(MCLOSE + 0);\n      if (!re_mult_next(\"\\\\ze\")) {\n        return NULL;\n      }\n      break;\n\n    default:  EMSG_RET_NULL(_(\"E68: Invalid character after \\\\z\"));\n    }\n  }\n  break;\n\n  case Magic('%'):\n  {\n    c = no_Magic(getchr());\n    switch (c) {\n    /* () without a back reference */\n    case '(':\n      if (one_exactly)\n        EMSG_ONE_RET_NULL;\n      ret = reg(REG_NPAREN, &flags);\n      if (ret == NULL)\n        return NULL;\n      *flagp |= flags & (HASWIDTH | SPSTART | HASNL | HASLOOKBH);\n      break;\n\n    /* Catch \\%^ and \\%$ regardless of where they appear in the\n     * pattern -- regardless of whether or not it makes sense. */\n    case '^':\n      ret = regnode(RE_BOF);\n      break;\n\n    case '$':\n      ret = regnode(RE_EOF);\n      break;\n\n    case '#':\n      ret = regnode(CURSOR);\n      break;\n\n    case 'V':\n      ret = regnode(RE_VISUAL);\n      break;\n\n    case 'C':\n      ret = regnode(RE_COMPOSING);\n      break;\n\n    /* \\%[abc]: Emit as a list of branches, all ending at the last\n     * branch which matches nothing. */\n    case '[':\n      if (one_exactly)                          /* doesn't nest */\n        EMSG_ONE_RET_NULL;\n      {\n        char_u    *lastbranch;\n        char_u    *lastnode = NULL;\n        char_u    *br;\n\n        ret = NULL;\n        while ((c = getchr()) != ']') {\n          if (c == NUL)\n            EMSG2_RET_NULL(_(e_missing_sb),\n                reg_magic == MAGIC_ALL);\n          br = regnode(BRANCH);\n          if (ret == NULL) {\n            ret = br;\n          } else {\n            regtail(lastnode, br);\n            if (reg_toolong) {\n              return NULL;\n            }\n          }\n\n          ungetchr();\n          one_exactly = true;\n          lastnode = regatom(flagp);\n          one_exactly = false;\n          if (lastnode == NULL) {\n            return NULL;\n          }\n        }\n        if (ret == NULL)\n          EMSG2_RET_NULL(_(e_empty_sb),\n              reg_magic == MAGIC_ALL);\n        lastbranch = regnode(BRANCH);\n        br = regnode(NOTHING);\n        if (ret != JUST_CALC_SIZE) {\n          regtail(lastnode, br);\n          regtail(lastbranch, br);\n          /* connect all branches to the NOTHING\n           * branch at the end */\n          for (br = ret; br != lastnode; ) {\n            if (OP(br) == BRANCH) {\n              regtail(br, lastbranch);\n              if (reg_toolong) {\n                return NULL;\n              }\n              br = OPERAND(br);\n            } else\n              br = regnext(br);\n          }\n        }\n        *flagp &= ~(HASWIDTH | SIMPLE);\n        break;\n      }\n\n    case 'd':               /* %d123 decimal */\n    case 'o':               /* %o123 octal */\n    case 'x':               /* %xab hex 2 */\n    case 'u':               /* %uabcd hex 4 */\n    case 'U':               /* %U1234abcd hex 8 */\n    {\n      int64_t i;\n\n      switch (c) {\n      case 'd': i = getdecchrs(); break;\n      case 'o': i = getoctchrs(); break;\n      case 'x': i = gethexchrs(2); break;\n      case 'u': i = gethexchrs(4); break;\n      case 'U': i = gethexchrs(8); break;\n      default:  i = -1; break;\n      }\n\n      if (i < 0 || i > INT_MAX) {\n        EMSG2_RET_NULL(_(\"E678: Invalid character after %s%%[dxouU]\"),\n                       reg_magic == MAGIC_ALL);\n      }\n      if (use_multibytecode(i)) {\n        ret = regnode(MULTIBYTECODE);\n      } else {\n        ret = regnode(EXACTLY);\n      }\n      if (i == 0) {\n        regc(0x0a);\n      } else {\n        regmbc(i);\n      }\n      regc(NUL);\n      *flagp |= HASWIDTH;\n      break;\n    }\n\n    default:\n      if (ascii_isdigit(c) || c == '<' || c == '>'\n          || c == '\\'') {\n        uint32_t n = 0;\n        int cmp;\n\n        cmp = c;\n        if (cmp == '<' || cmp == '>')\n          c = getchr();\n        while (ascii_isdigit(c)) {\n          n = n * 10 + (uint32_t)(c - '0');\n          c = getchr();\n        }\n        if (c == '\\'' && n == 0) {\n          /* \"\\%'m\", \"\\%<'m\" and \"\\%>'m\": Mark */\n          c = getchr();\n          ret = regnode(RE_MARK);\n          if (ret == JUST_CALC_SIZE)\n            regsize += 2;\n          else {\n            *regcode++ = c;\n            *regcode++ = cmp;\n          }\n          break;\n        } else if (c == 'l' || c == 'c' || c == 'v') {\n          if (c == 'l') {\n            ret = regnode(RE_LNUM);\n            if (save_prev_at_start) {\n              at_start = true;\n            }\n          } else if (c == 'c') {\n            ret = regnode(RE_COL);\n          } else {\n            ret = regnode(RE_VCOL);\n          }\n          if (ret == JUST_CALC_SIZE) {\n            regsize += 5;\n          } else {\n            // put the number and the optional\n            // comparator after the opcode\n            regcode = re_put_uint32(regcode, n);\n            *regcode++ = cmp;\n          }\n          break;\n        }\n      }\n\n      EMSG2_RET_NULL(_(\"E71: Invalid character after %s%%\"),\n          reg_magic == MAGIC_ALL);\n    }\n  }\n  break;\n\n  case Magic('['):\ncollection:\n    {\n      char_u      *lp;\n\n      /*\n       * If there is no matching ']', we assume the '[' is a normal\n       * character.  This makes 'incsearch' and \":help [\" work.\n       */\n      lp = skip_anyof(regparse);\n      if (*lp == ']') {         /* there is a matching ']' */\n        int startc = -1;                /* > 0 when next '-' is a range */\n        int endc;\n\n        /*\n         * In a character class, different parsing rules apply.\n         * Not even \\ is special anymore, nothing is.\n         */\n        if (*regparse == '^') {             /* Complement of range. */\n          ret = regnode(ANYBUT + extra);\n          regparse++;\n        } else\n          ret = regnode(ANYOF + extra);\n\n        /* At the start ']' and '-' mean the literal character. */\n        if (*regparse == ']' || *regparse == '-') {\n          startc = *regparse;\n          regc(*regparse++);\n        }\n\n        while (*regparse != NUL && *regparse != ']') {\n          if (*regparse == '-') {\n            ++regparse;\n            /* The '-' is not used for a range at the end and\n             * after or before a '\\n'. */\n            if (*regparse == ']' || *regparse == NUL\n                || startc == -1\n                || (regparse[0] == '\\\\' && regparse[1] == 'n')) {\n              regc('-');\n              startc = '-';                     /* [--x] is a range */\n            } else {\n              /* Also accept \"a-[.z.]\" */\n              endc = 0;\n              if (*regparse == '[')\n                endc = get_coll_element(&regparse);\n              if (endc == 0) {\n                endc = mb_ptr2char_adv((const char_u **)&regparse);\n              }\n\n              /* Handle \\o40, \\x20 and \\u20AC style sequences */\n              if (endc == '\\\\' && !reg_cpo_lit)\n                endc = coll_get_char();\n\n              if (startc > endc) {\n                EMSG_RET_NULL(_(e_reverse_range));\n              }\n              if ((*mb_char2len)(startc) > 1\n                  || (*mb_char2len)(endc) > 1) {\n                // Limit to a range of 256 chars\n                if (endc > startc + 256) {\n                  EMSG_RET_NULL(_(e_large_class));\n                }\n                while (++startc <= endc) {\n                  regmbc(startc);\n                }\n              } else {\n                while (++startc <= endc)\n                  regc(startc);\n              }\n              startc = -1;\n            }\n          }\n          /*\n           * Only \"\\]\", \"\\^\", \"\\]\" and \"\\\\\" are special in Vi.  Vim\n           * accepts \"\\t\", \"\\e\", etc., but only when the 'l' flag in\n           * 'cpoptions' is not included.\n           */\n          else if (*regparse == '\\\\'\n                   && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL\n                       || (!reg_cpo_lit\n                           && vim_strchr(REGEXP_ABBR,\n                               regparse[1]) != NULL))) {\n            regparse++;\n            if (*regparse == 'n') {\n              /* '\\n' in range: also match NL */\n              if (ret != JUST_CALC_SIZE) {\n                /* Using \\n inside [^] does not change what\n                 * matches. \"[^\\n]\" is the same as \".\". */\n                if (*ret == ANYOF) {\n                  *ret = ANYOF + ADD_NL;\n                  *flagp |= HASNL;\n                }\n                /* else: must have had a \\n already */\n              }\n              regparse++;\n              startc = -1;\n            } else if (*regparse == 'd'\n                       || *regparse == 'o'\n                       || *regparse == 'x'\n                       || *regparse == 'u'\n                       || *regparse == 'U') {\n              startc = coll_get_char();\n              if (startc == 0)\n                regc(0x0a);\n              else\n                regmbc(startc);\n            } else {\n              startc = backslash_trans(*regparse++);\n              regc(startc);\n            }\n          } else if (*regparse == '[') {\n            int c_class;\n            int cu;\n\n            c_class = get_char_class(&regparse);\n            startc = -1;\n            /* Characters assumed to be 8 bits! */\n            switch (c_class) {\n            case CLASS_NONE:\n              c_class = get_equi_class(&regparse);\n              if (c_class != 0) {\n                /* produce equivalence class */\n                reg_equi_class(c_class);\n              } else if ((c_class =\n                            get_coll_element(&regparse)) != 0) {\n                /* produce a collating element */\n                regmbc(c_class);\n              } else {\n                /* literal '[', allow [[-x] as a range */\n                startc = *regparse++;\n                regc(startc);\n              }\n              break;\n            case CLASS_ALNUM:\n              for (cu = 1; cu < 128; cu++) {\n                if (isalnum(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_ALPHA:\n              for (cu = 1; cu < 128; cu++) {\n                if (isalpha(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_BLANK:\n              regc(' ');\n              regc('\\t');\n              break;\n            case CLASS_CNTRL:\n              for (cu = 1; cu <= 127; cu++) {\n                if (iscntrl(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_DIGIT:\n              for (cu = 1; cu <= 127; cu++) {\n                if (ascii_isdigit(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_GRAPH:\n              for (cu = 1; cu <= 127; cu++) {\n                if (isgraph(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_LOWER:\n              for (cu = 1; cu <= 255; cu++) {\n                if (mb_islower(cu) && cu != 170 && cu != 186) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_PRINT:\n              for (cu = 1; cu <= 255; cu++) {\n                if (vim_isprintc(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_PUNCT:\n              for (cu = 1; cu < 128; cu++) {\n                if (ispunct(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_SPACE:\n              for (cu = 9; cu <= 13; cu++)\n                regc(cu);\n              regc(' ');\n              break;\n            case CLASS_UPPER:\n              for (cu = 1; cu <= 255; cu++) {\n                if (mb_isupper(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_XDIGIT:\n              for (cu = 1; cu <= 255; cu++) {\n                if (ascii_isxdigit(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_TAB:\n              regc('\\t');\n              break;\n            case CLASS_RETURN:\n              regc('\\r');\n              break;\n            case CLASS_BACKSPACE:\n              regc('\\b');\n              break;\n            case CLASS_ESCAPE:\n              regc(ESC);\n              break;\n            case CLASS_IDENT:\n              for (cu = 1; cu <= 255; cu++) {\n                if (vim_isIDc(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_KEYWORD:\n              for (cu = 1; cu <= 255; cu++) {\n                if (reg_iswordc(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            case CLASS_FNAME:\n              for (cu = 1; cu <= 255; cu++) {\n                if (vim_isfilec(cu)) {\n                  regmbc(cu);\n                }\n              }\n              break;\n            }\n          } else {\n            // produce a multibyte character, including any\n            // following composing characters.\n            startc = utf_ptr2char(regparse);\n            int len = utfc_ptr2len(regparse);\n            if (utf_char2len(startc) != len) {\n              // composing chars\n              startc = -1;\n            }\n            while (--len >= 0) {\n              regc(*regparse++);\n            }\n          }\n        }\n        regc(NUL);\n        prevchr_len = 1;                /* last char was the ']' */\n        if (*regparse != ']')\n          EMSG_RET_NULL(_(e_toomsbra));                 /* Cannot happen? */\n        skipchr();                  /* let's be friends with the lexer again */\n        *flagp |= HASWIDTH | SIMPLE;\n        break;\n      } else if (reg_strict)\n        EMSG2_RET_NULL(_(e_missingbracket), reg_magic > MAGIC_OFF);\n    }\n    FALLTHROUGH;\n\n  default:\n  {\n    int len;\n\n    /* A multi-byte character is handled as a separate atom if it's\n     * before a multi and when it's a composing char. */\n    if (use_multibytecode(c)) {\ndo_multibyte:\n      ret = regnode(MULTIBYTECODE);\n      regmbc(c);\n      *flagp |= HASWIDTH | SIMPLE;\n      break;\n    }\n\n    ret = regnode(EXACTLY);\n\n    /*\n     * Append characters as long as:\n     * - there is no following multi, we then need the character in\n     *   front of it as a single character operand\n     * - not running into a Magic character\n     * - \"one_exactly\" is not set\n     * But always emit at least one character.  Might be a Multi,\n     * e.g., a \"[\" without matching \"]\".\n     */\n    for (len = 0; c != NUL && (len == 0\n                               || (re_multi_type(peekchr()) == NOT_MULTI\n                                   && !one_exactly\n                                   && !is_Magic(c))); ++len) {\n      c = no_Magic(c);\n      {\n        regmbc(c);\n        {\n          int l;\n\n          /* Need to get composing character too. */\n          for (;; ) {\n            l = utf_ptr2len(regparse);\n            if (!UTF_COMPOSINGLIKE(regparse, regparse + l))\n              break;\n            regmbc(utf_ptr2char(regparse));\n            skipchr();\n          }\n        }\n      }\n      c = getchr();\n    }\n    ungetchr();\n\n    regc(NUL);\n    *flagp |= HASWIDTH;\n    if (len == 1)\n      *flagp |= SIMPLE;\n  }\n  break;\n  }\n\n  return ret;\n}\n\n/// Used in a place where no * or \\+ can follow.\nstatic bool re_mult_next(char *what)\n{\n  if (re_multi_type(peekchr()) == MULTI_MULT) {\n    EMSG2_RET_FAIL(_(\"E888: (NFA regexp) cannot repeat %s\"), what);\n  }\n  return true;\n}\n\n// Return true if MULTIBYTECODE should be used instead of EXACTLY for\n// character \"c\".\nstatic bool use_multibytecode(int c)\n{\n  return utf_char2len(c) > 1\n         && (re_multi_type(peekchr()) != NOT_MULTI\n             || utf_iscomposing(c));\n}\n\n/*\n * Emit a node.\n * Return pointer to generated code.\n */\nstatic char_u *regnode(int op)\n{\n  char_u  *ret;\n\n  ret = regcode;\n  if (ret == JUST_CALC_SIZE)\n    regsize += 3;\n  else {\n    *regcode++ = op;\n    *regcode++ = NUL;                   /* Null \"next\" pointer. */\n    *regcode++ = NUL;\n  }\n  return ret;\n}\n\n/*\n * Emit (if appropriate) a byte of code\n */\nstatic void regc(int b)\n{\n  if (regcode == JUST_CALC_SIZE)\n    regsize++;\n  else\n    *regcode++ = b;\n}\n\n/*\n * Emit (if appropriate) a multi-byte character of code\n */\nstatic void regmbc(int c)\n{\n  if (regcode == JUST_CALC_SIZE) {\n    regsize += utf_char2len(c);\n  } else {\n    regcode += utf_char2bytes(c, regcode);\n  }\n}\n\n/*\n * Insert an operator in front of already-emitted operand\n *\n * Means relocating the operand.\n */\nstatic void reginsert(int op, char_u *opnd)\n{\n  char_u      *src;\n  char_u      *dst;\n  char_u      *place;\n\n  if (regcode == JUST_CALC_SIZE) {\n    regsize += 3;\n    return;\n  }\n  src = regcode;\n  regcode += 3;\n  dst = regcode;\n  while (src > opnd)\n    *--dst = *--src;\n\n  place = opnd;                 /* Op node, where operand used to be. */\n  *place++ = op;\n  *place++ = NUL;\n  *place = NUL;\n}\n\n/*\n * Insert an operator in front of already-emitted operand.\n * Add a number to the operator.\n */\nstatic void reginsert_nr(int op, long val, char_u *opnd)\n{\n  char_u      *src;\n  char_u      *dst;\n  char_u      *place;\n\n  if (regcode == JUST_CALC_SIZE) {\n    regsize += 7;\n    return;\n  }\n  src = regcode;\n  regcode += 7;\n  dst = regcode;\n  while (src > opnd)\n    *--dst = *--src;\n\n  place = opnd;                 /* Op node, where operand used to be. */\n  *place++ = op;\n  *place++ = NUL;\n  *place++ = NUL;\n  assert(val >= 0 && (uintmax_t)val <= UINT32_MAX);\n  re_put_uint32(place, (uint32_t)val);\n}\n\n/*\n * Insert an operator in front of already-emitted operand.\n * The operator has the given limit values as operands.  Also set next pointer.\n *\n * Means relocating the operand.\n */\nstatic void reginsert_limits(int op, long minval, long maxval, char_u *opnd)\n{\n  char_u      *src;\n  char_u      *dst;\n  char_u      *place;\n\n  if (regcode == JUST_CALC_SIZE) {\n    regsize += 11;\n    return;\n  }\n  src = regcode;\n  regcode += 11;\n  dst = regcode;\n  while (src > opnd)\n    *--dst = *--src;\n\n  place = opnd;                 /* Op node, where operand used to be. */\n  *place++ = op;\n  *place++ = NUL;\n  *place++ = NUL;\n  assert(minval >= 0 && (uintmax_t)minval <= UINT32_MAX);\n  place = re_put_uint32(place, (uint32_t)minval);\n  assert(maxval >= 0 && (uintmax_t)maxval <= UINT32_MAX);\n  place = re_put_uint32(place, (uint32_t)maxval);\n  regtail(opnd, place);\n}\n\n/*\n * Write a four bytes number at \"p\" and return pointer to the next char.\n */\nstatic char_u *re_put_uint32(char_u *p, uint32_t val)\n{\n  *p++ = (char_u) ((val >> 24) & 0377);\n  *p++ = (char_u) ((val >> 16) & 0377);\n  *p++ = (char_u) ((val >> 8) & 0377);\n  *p++ = (char_u) (val & 0377);\n  return p;\n}\n\n// Set the next-pointer at the end of a node chain.\nstatic void regtail(char_u *p, char_u *val)\n{\n  int offset;\n\n  if (p == JUST_CALC_SIZE) {\n    return;\n  }\n\n  // Find last node.\n  char_u *scan = p;\n  for (;; ) {\n    char_u *temp = regnext(scan);\n    if (temp == NULL) {\n      break;\n    }\n    scan = temp;\n  }\n\n  if (OP(scan) == BACK) {\n    offset = (int)(scan - val);\n  } else {\n    offset = (int)(val - scan);\n  }\n  // When the offset uses more than 16 bits it can no longer fit in the two\n  // bytes available.  Use a global flag to avoid having to check return\n  // values in too many places.\n  if (offset > 0xffff) {\n    reg_toolong = true;\n  } else {\n    *(scan + 1) = (char_u)(((unsigned)offset >> 8) & 0377);\n    *(scan + 2) = (char_u)(offset & 0377);\n  }\n}\n\n/*\n * Like regtail, on item after a BRANCH; nop if none.\n */\nstatic void regoptail(char_u *p, char_u *val)\n{\n  /* When op is neither BRANCH nor BRACE_COMPLEX0-9, it is \"operandless\" */\n  if (p == NULL || p == JUST_CALC_SIZE\n      || (OP(p) != BRANCH\n          && (OP(p) < BRACE_COMPLEX || OP(p) > BRACE_COMPLEX + 9)))\n    return;\n  regtail(OPERAND(p), val);\n}\n\n/*\n * Functions for getting characters from the regexp input.\n */\n\n/*\n * Start parsing at \"str\".\n */\nstatic void initchr(char_u *str)\n{\n  regparse = str;\n  prevchr_len = 0;\n  curchr = prevprevchr = prevchr = nextchr = -1;\n  at_start = true;\n  prev_at_start = false;\n}\n\n/*\n * Save the current parse state, so that it can be restored and parsing\n * starts in the same state again.\n */\nstatic void save_parse_state(parse_state_T *ps)\n{\n  ps->regparse = regparse;\n  ps->prevchr_len = prevchr_len;\n  ps->curchr = curchr;\n  ps->prevchr = prevchr;\n  ps->prevprevchr = prevprevchr;\n  ps->nextchr = nextchr;\n  ps->at_start = at_start;\n  ps->prev_at_start = prev_at_start;\n  ps->regnpar = regnpar;\n}\n\n/*\n * Restore a previously saved parse state.\n */\nstatic void restore_parse_state(parse_state_T *ps)\n{\n  regparse = ps->regparse;\n  prevchr_len = ps->prevchr_len;\n  curchr = ps->curchr;\n  prevchr = ps->prevchr;\n  prevprevchr = ps->prevprevchr;\n  nextchr = ps->nextchr;\n  at_start = ps->at_start;\n  prev_at_start = ps->prev_at_start;\n  regnpar = ps->regnpar;\n}\n\n\n/*\n * Get the next character without advancing.\n */\nstatic int peekchr(void)\n{\n  static int after_slash = false;\n\n  if (curchr != -1) {\n    return curchr;\n  }\n\n  switch (curchr = regparse[0]) {\n  case '.':\n  case '[':\n  case '~':\n    /* magic when 'magic' is on */\n    if (reg_magic >= MAGIC_ON)\n      curchr = Magic(curchr);\n    break;\n  case '(':\n  case ')':\n  case '{':\n  case '%':\n  case '+':\n  case '=':\n  case '?':\n  case '@':\n  case '!':\n  case '&':\n  case '|':\n  case '<':\n  case '>':\n  case '#':           /* future ext. */\n  case '\"':           /* future ext. */\n  case '\\'':          /* future ext. */\n  case ',':           /* future ext. */\n  case '-':           /* future ext. */\n  case ':':           /* future ext. */\n  case ';':           /* future ext. */\n  case '`':           /* future ext. */\n  case '/':           /* Can't be used in / command */\n    /* magic only after \"\\v\" */\n    if (reg_magic == MAGIC_ALL)\n      curchr = Magic(curchr);\n    break;\n  case '*':\n    /* * is not magic as the very first character, eg \"?*ptr\", when\n     * after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But\n     * \"\\(\\*\" is not magic, thus must be magic if \"after_slash\" */\n    if (reg_magic >= MAGIC_ON\n        && !at_start\n        && !(prev_at_start && prevchr == Magic('^'))\n        && (after_slash\n            || (prevchr != Magic('(')\n                && prevchr != Magic('&')\n                && prevchr != Magic('|'))))\n      curchr = Magic('*');\n    break;\n  case '^':\n    /* '^' is only magic as the very first character and if it's after\n     * \"\\(\", \"\\|\", \"\\&' or \"\\n\" */\n    if (reg_magic >= MAGIC_OFF\n        && (at_start\n            || reg_magic == MAGIC_ALL\n            || prevchr == Magic('(')\n            || prevchr == Magic('|')\n            || prevchr == Magic('&')\n            || prevchr == Magic('n')\n            || (no_Magic(prevchr) == '('\n                && prevprevchr == Magic('%')))) {\n      curchr = Magic('^');\n      at_start = true;\n      prev_at_start = false;\n    }\n    break;\n  case '$':\n    /* '$' is only magic as the very last char and if it's in front of\n     * either \"\\|\", \"\\)\", \"\\&\", or \"\\n\" */\n    if (reg_magic >= MAGIC_OFF) {\n      char_u *p = regparse + 1;\n      bool is_magic_all = (reg_magic == MAGIC_ALL);\n\n      // ignore \\c \\C \\m \\M \\v \\V and \\Z after '$'\n      while (p[0] == '\\\\' && (p[1] == 'c' || p[1] == 'C'\n                              || p[1] == 'm' || p[1] == 'M'\n                              || p[1] == 'v' || p[1] == 'V'\n                              || p[1] == 'Z')) {\n        if (p[1] == 'v') {\n          is_magic_all = true;\n        } else if (p[1] == 'm' || p[1] == 'M' || p[1] == 'V') {\n          is_magic_all = false;\n        }\n        p += 2;\n      }\n      if (p[0] == NUL\n          || (p[0] == '\\\\'\n              && (p[1] == '|' || p[1] == '&' || p[1] == ')'\n                  || p[1] == 'n'))\n          || (is_magic_all\n              && (p[0] == '|' || p[0] == '&' || p[0] == ')'))\n          || reg_magic == MAGIC_ALL) {\n        curchr = Magic('$');\n      }\n    }\n    break;\n  case '\\\\':\n  {\n    int c = regparse[1];\n\n    if (c == NUL)\n      curchr = '\\\\';                  /* trailing '\\' */\n    else if (\n      c <= '~' && META_flags[c]\n      ) {\n      /*\n       * META contains everything that may be magic sometimes,\n       * except ^ and $ (\"\\^\" and \"\\$\" are only magic after\n       * \"\\V\").  We now fetch the next character and toggle its\n       * magicness.  Therefore, \\ is so meta-magic that it is\n       * not in META.\n       */\n      curchr = -1;\n      prev_at_start = at_start;\n      at_start = false;  // be able to say \"/\\*ptr\"\n      regparse++;\n      after_slash++;\n      (void)peekchr();\n      regparse--;\n      after_slash--;\n      curchr = toggle_Magic(curchr);\n    } else if (vim_strchr(REGEXP_ABBR, c)) {\n      /*\n       * Handle abbreviations, like \"\\t\" for TAB -- webb\n       */\n      curchr = backslash_trans(c);\n    } else if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))\n      curchr = toggle_Magic(c);\n    else {\n      /*\n       * Next character can never be (made) magic?\n       * Then backslashing it won't do anything.\n       */\n      curchr = utf_ptr2char(regparse + 1);\n    }\n    break;\n  }\n\n  default:\n    curchr = utf_ptr2char(regparse);\n  }\n\n  return curchr;\n}\n\n/*\n * Eat one lexed character.  Do this in a way that we can undo it.\n */\nstatic void skipchr(void)\n{\n  /* peekchr() eats a backslash, do the same here */\n  if (*regparse == '\\\\')\n    prevchr_len = 1;\n  else\n    prevchr_len = 0;\n  if (regparse[prevchr_len] != NUL) {\n    // Exclude composing chars that utfc_ptr2len does include.\n    prevchr_len += utf_ptr2len(regparse + prevchr_len);\n  }\n  regparse += prevchr_len;\n  prev_at_start = at_start;\n  at_start = false;\n  prevprevchr = prevchr;\n  prevchr = curchr;\n  curchr = nextchr;         /* use previously unget char, or -1 */\n  nextchr = -1;\n}\n\n/*\n * Skip a character while keeping the value of prev_at_start for at_start.\n * prevchr and prevprevchr are also kept.\n */\nstatic void skipchr_keepstart(void)\n{\n  int as = prev_at_start;\n  int pr = prevchr;\n  int prpr = prevprevchr;\n\n  skipchr();\n  at_start = as;\n  prevchr = pr;\n  prevprevchr = prpr;\n}\n\n/*\n * Get the next character from the pattern. We know about magic and such, so\n * therefore we need a lexical analyzer.\n */\nstatic int getchr(void)\n{\n  int chr = peekchr();\n\n  skipchr();\n  return chr;\n}\n\n/*\n * put character back.  Works only once!\n */\nstatic void ungetchr(void)\n{\n  nextchr = curchr;\n  curchr = prevchr;\n  prevchr = prevprevchr;\n  at_start = prev_at_start;\n  prev_at_start = false;\n\n  /* Backup regparse, so that it's at the same position as before the\n   * getchr(). */\n  regparse -= prevchr_len;\n}\n\n/*\n * Get and return the value of the hex string at the current position.\n * Return -1 if there is no valid hex number.\n * The position is updated:\n *     blahblah\\%x20asdf\n *\t   before-^ ^-after\n * The parameter controls the maximum number of input characters. This will be\n * 2 when reading a \\%x20 sequence and 4 when reading a \\%u20AC sequence.\n */\nstatic int64_t gethexchrs(int maxinputlen)\n{\n  int64_t nr = 0;\n  int c;\n  int i;\n\n  for (i = 0; i < maxinputlen; ++i) {\n    c = regparse[0];\n    if (!ascii_isxdigit(c))\n      break;\n    nr <<= 4;\n    nr |= hex2nr(c);\n    ++regparse;\n  }\n\n  if (i == 0)\n    return -1;\n  return nr;\n}\n\n/*\n * Get and return the value of the decimal string immediately after the\n * current position. Return -1 for invalid.  Consumes all digits.\n */\nstatic int64_t getdecchrs(void)\n{\n  int64_t nr = 0;\n  int c;\n  int i;\n\n  for (i = 0;; ++i) {\n    c = regparse[0];\n    if (c < '0' || c > '9')\n      break;\n    nr *= 10;\n    nr += c - '0';\n    ++regparse;\n    curchr = -1;     /* no longer valid */\n  }\n\n  if (i == 0)\n    return -1;\n  return nr;\n}\n\n/*\n * get and return the value of the octal string immediately after the current\n * position. Return -1 for invalid, or 0-255 for valid. Smart enough to handle\n * numbers > 377 correctly (for example, 400 is treated as 40) and doesn't\n * treat 8 or 9 as recognised characters. Position is updated:\n *     blahblah\\%o210asdf\n *\t   before-^  ^-after\n */\nstatic int64_t getoctchrs(void)\n{\n  int64_t nr = 0;\n  int c;\n  int i;\n\n  for (i = 0; i < 3 && nr < 040; i++) {  // -V536\n    c = regparse[0];\n    if (c < '0' || c > '7')\n      break;\n    nr <<= 3;\n    nr |= hex2nr(c);\n    ++regparse;\n  }\n\n  if (i == 0)\n    return -1;\n  return nr;\n}\n\n/*\n * Get a number after a backslash that is inside [].\n * When nothing is recognized return a backslash.\n */\nstatic int coll_get_char(void)\n{\n  int64_t nr = -1;\n\n  switch (*regparse++) {\n  case 'd': nr = getdecchrs(); break;\n  case 'o': nr = getoctchrs(); break;\n  case 'x': nr = gethexchrs(2); break;\n  case 'u': nr = gethexchrs(4); break;\n  case 'U': nr = gethexchrs(8); break;\n  }\n  if (nr < 0 || nr > INT_MAX) {\n    // If getting the number fails be backwards compatible: the character\n    // is a backslash.\n    regparse--;\n    nr = '\\\\';\n  }\n  return nr;\n}\n\n/*\n * read_limits - Read two integers to be taken as a minimum and maximum.\n * If the first character is '-', then the range is reversed.\n * Should end with 'end'.  If minval is missing, zero is default, if maxval is\n * missing, a very big number is the default.\n */\nstatic int read_limits(long *minval, long *maxval)\n{\n  int reverse = false;\n  char_u      *first_char;\n  long tmp;\n\n  if (*regparse == '-') {\n    // Starts with '-', so reverse the range later.\n    regparse++;\n    reverse = true;\n  }\n  first_char = regparse;\n  *minval = getdigits_long(&regparse, false, 0);\n  if (*regparse == ',') {           // There is a comma.\n    if (ascii_isdigit(*++regparse)) {\n      *maxval = getdigits_long(&regparse, false, MAX_LIMIT);\n    } else {\n      *maxval = MAX_LIMIT;\n    }\n  } else if (ascii_isdigit(*first_char)) {\n    *maxval = *minval;              // It was \\{n} or \\{-n}\n  } else {\n    *maxval = MAX_LIMIT;            // It was \\{} or \\{-}\n  }\n  if (*regparse == '\\\\') {\n    regparse++;         // Allow either \\{...} or \\{...\\}\n  }\n  if (*regparse != '}') {\n    sprintf((char *)IObuff, _(\"E554: Syntax error in %s{...}\"),\n        reg_magic == MAGIC_ALL ? \"\" : \"\\\\\");\n    EMSG_RET_FAIL(IObuff);\n  }\n\n  /*\n   * Reverse the range if there was a '-', or make sure it is in the right\n   * order otherwise.\n   */\n  if ((!reverse && *minval > *maxval) || (reverse && *minval < *maxval)) {\n    tmp = *minval;\n    *minval = *maxval;\n    *maxval = tmp;\n  }\n  skipchr();            /* let's be friends with the lexer again */\n  return OK;\n}\n\n/*\n * vim_regexec and friends\n */\n\n/*\n * Global work variables for vim_regexec().\n */\n\n/* Save the sub-expressions before attempting a match. */\n#define save_se(savep, posp, pp) \\\n  REG_MULTI ? save_se_multi((savep), (posp)) : save_se_one((savep), (pp))\n\n/* After a failed match restore the sub-expressions. */\n#define restore_se(savep, posp, pp) { \\\n    if (REG_MULTI) \\\n      *(posp) = (savep)->se_u.pos; \\\n    else \\\n      *(pp) = (savep)->se_u.ptr; }\n\n\n#ifdef REGEXP_DEBUG\nint regnarrate = 0;\n#endif\n\n// Sometimes need to save a copy of a line.  Since alloc()/free() is very\n// slow, we keep one allocated piece of memory and only re-allocate it when\n// it's too small.  It's freed in bt_regexec_both() when finished.\nstatic char_u   *reg_tofree = NULL;\nstatic unsigned reg_tofreelen;\n\n// Structure used to store the execution state of the regex engine.\n// Which ones are set depends on whether a single-line or multi-line match is\n// done:\n//                      single-line             multi-line\n// reg_match            &regmatch_T             NULL\n// reg_mmatch           NULL                    &regmmatch_T\n// reg_startp           reg_match->startp       <invalid>\n// reg_endp             reg_match->endp         <invalid>\n// reg_startpos         <invalid>               reg_mmatch->startpos\n// reg_endpos           <invalid>               reg_mmatch->endpos\n// reg_win              NULL                    window in which to search\n// reg_buf              curbuf                  buffer in which to search\n// reg_firstlnum        <invalid>               first line in which to search\n// reg_maxline          0                       last line nr\n// reg_line_lbr         false or true           false\ntypedef struct {\n  regmatch_T *reg_match;\n  regmmatch_T *reg_mmatch;\n  char_u **reg_startp;\n  char_u **reg_endp;\n  lpos_T *reg_startpos;\n  lpos_T *reg_endpos;\n  win_T *reg_win;\n  buf_T *reg_buf;\n  linenr_T reg_firstlnum;\n  linenr_T reg_maxline;\n  bool reg_line_lbr;  // \"\\n\" in string is line break\n\n  // The current match-position is remembered with these variables:\n  linenr_T lnum;  ///< line number, relative to first line\n  char_u *line;   ///< start of current line\n  char_u *input;  ///< current input, points into \"regline\"\n\n  int need_clear_subexpr;   ///< subexpressions still need to be cleared\n  int need_clear_zsubexpr;  ///< extmatch subexpressions still need to be\n                            ///< cleared\n\n\n  // Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().\n  // Normally it gets the value of \"rm_ic\" or \"rmm_ic\", but when the pattern\n  // contains '\\c' or '\\C' the value is overruled.\n  bool reg_ic;\n\n  // Similar to \"reg_ic\", but only for 'combining' characters.  Set with \\Z\n  // flag in the regexp.  Defaults to false, always.\n  bool reg_icombine;\n\n  // Copy of \"rmm_maxcol\": maximum column to search for a match.  Zero when\n  // there is no maximum.\n  colnr_T reg_maxcol;\n\n  // State for the NFA engine regexec.\n  int nfa_has_zend;     ///< NFA regexp \\ze operator encountered.\n  int nfa_has_backref;  ///< NFA regexp \\1 .. \\9 encountered.\n  int nfa_nsubexpr;     ///< Number of sub expressions actually being used\n                        ///< during execution. 1 if only the whole match\n                        ///< (subexpr 0) is used.\n  // listid is global, so that it increases on recursive calls to\n  // nfa_regmatch(), which means we don't have to clear the lastlist field of\n  // all the states.\n  int nfa_listid;\n  int nfa_alt_listid;\n\n  int nfa_has_zsubexpr;  ///< NFA regexp has \\z( ), set zsubexpr.\n} regexec_T;\n\nstatic regexec_T rex;\nstatic bool rex_in_use = false;\n\n/*\n * \"regstack\" and \"backpos\" are used by regmatch().  They are kept over calls\n * to avoid invoking malloc() and free() often.\n * \"regstack\" is a stack with regitem_T items, sometimes preceded by regstar_T\n * or regbehind_T.\n * \"backpos_T\" is a table with backpos_T for BACK\n */\nstatic garray_T regstack = GA_EMPTY_INIT_VALUE;\nstatic garray_T backpos = GA_EMPTY_INIT_VALUE;\n\n/*\n * Both for regstack and backpos tables we use the following strategy of\n * allocation (to reduce malloc/free calls):\n * - Initial size is fairly small.\n * - When needed, the tables are grown bigger (8 times at first, double after\n *   that).\n * - After executing the match we free the memory only if the array has grown.\n *   Thus the memory is kept allocated when it's at the initial size.\n * This makes it fast while not keeping a lot of memory allocated.\n * A three times speed increase was observed when using many simple patterns.\n */\n#define REGSTACK_INITIAL        2048\n#define BACKPOS_INITIAL         64\n\n#if defined(EXITFREE)\nvoid free_regexp_stuff(void)\n{\n  ga_clear(&regstack);\n  ga_clear(&backpos);\n  xfree(reg_tofree);\n  xfree(reg_prev_sub);\n}\n\n#endif\n\n// Return true if character 'c' is included in 'iskeyword' option for\n// \"reg_buf\" buffer.\nstatic bool reg_iswordc(int c)\n{\n  return vim_iswordc_buf(c, rex.reg_buf);\n}\n\n/*\n * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\".\n */\nstatic char_u *reg_getline(linenr_T lnum)\n{\n  // when looking behind for a match/no-match lnum is negative.  But we\n  // can't go before line 1\n  if (rex.reg_firstlnum + lnum < 1) {\n    return NULL;\n  }\n  if (lnum > rex.reg_maxline) {\n    // Must have matched the \"\\n\" in the last line.\n    return (char_u *)\"\";\n  }\n  return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, false);\n}\n\nstatic regsave_T behind_pos;\n\nstatic char_u   *reg_startzp[NSUBEXP];  /* Workspace to mark beginning */\nstatic char_u   *reg_endzp[NSUBEXP];    /*   and end of \\z(...\\) matches */\nstatic lpos_T reg_startzpos[NSUBEXP];   /* idem, beginning pos */\nstatic lpos_T reg_endzpos[NSUBEXP];     /* idem, end pos */\n\n// true if using multi-line regexp.\n#define REG_MULTI       (rex.reg_match == NULL)\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n * Uses curbuf for line count and 'iskeyword'.\n * If \"line_lbr\" is true, consider a \"\\n\" in \"line\" to be a line break.\n *\n * Returns 0 for failure, number of lines contained in the match otherwise.\n */\nstatic int \nbt_regexec_nl (\n    regmatch_T *rmp,\n    char_u *line,      /* string to match against */\n    colnr_T col,       /* column to start looking for match */\n    bool line_lbr\n)\n{\n  rex.reg_match = rmp;\n  rex.reg_mmatch = NULL;\n  rex.reg_maxline = 0;\n  rex.reg_line_lbr = line_lbr;\n  rex.reg_buf = curbuf;\n  rex.reg_win = NULL;\n  rex.reg_ic = rmp->rm_ic;\n  rex.reg_icombine = false;\n  rex.reg_maxcol = 0;\n\n  long r = bt_regexec_both(line, col, NULL, NULL);\n  assert(r <= INT_MAX);\n  return (int)r;\n}\n\n/// Wrapper around strchr which accounts for case-insensitive searches and\n/// non-ASCII characters.\n///\n/// This function is used a lot for simple searches, keep it fast!\n///\n/// @param  s  string to search\n/// @param  c  character to find in @a s\n///\n/// @return  NULL if no match, otherwise pointer to the position in @a s\nstatic inline char_u *cstrchr(const char_u *const s, const int c)\n  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL\n  FUNC_ATTR_ALWAYS_INLINE\n{\n  if (!rex.reg_ic) {\n    return vim_strchr(s, c);\n  }\n\n  // Use folded case for UTF-8, slow! For ASCII use libc strpbrk which is\n  // expected to be highly optimized.\n  if (c > 0x80) {\n    const int folded_c = utf_fold(c);\n    for (const char_u *p = s; *p != NUL; p += utfc_ptr2len(p)) {\n      if (utf_fold(utf_ptr2char(p)) == folded_c) {\n        return (char_u *)p;\n      }\n    }\n    return NULL;\n  }\n\n  int cc;\n  if (ASCII_ISUPPER(c)) {\n    cc = TOLOWER_ASC(c);\n  } else if (ASCII_ISLOWER(c)) {\n    cc = TOUPPER_ASC(c);\n  } else {\n    return vim_strchr(s, c);\n  }\n\n  char tofind[] = { (char)c, (char)cc, NUL };\n  return (char_u *)strpbrk((const char *)s, tofind);\n}\n\n/// Matches a regexp against multiple lines.\n/// \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n/// Uses curbuf for line count and 'iskeyword'.\n/// \n/// @param win Window in which to search or NULL\n/// @param buf Buffer in which to search\n/// @param lnum Number of line to start looking for match \n/// @param col Column to start looking for match\n/// @param tm Timeout limit or NULL\n///\n/// @return zero if there is no match and number of lines contained in the match\n///         otherwise.\nstatic long bt_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf,\n                             linenr_T lnum, colnr_T col,\n                             proftime_T *tm, int *timed_out)\n{\n  rex.reg_match = NULL;\n  rex.reg_mmatch = rmp;\n  rex.reg_buf = buf;\n  rex.reg_win = win;\n  rex.reg_firstlnum = lnum;\n  rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;\n  rex.reg_line_lbr = false;\n  rex.reg_ic = rmp->rmm_ic;\n  rex.reg_icombine = false;\n  rex.reg_maxcol = rmp->rmm_maxcol;\n\n  return bt_regexec_both(NULL, col, tm, timed_out);\n}\n\n/// Match a regexp against a string (\"line\" points to the string) or multiple\n/// lines (if \"line\" is NULL, use reg_getline()).\n/// @return 0 for failure, or number of lines contained in the match.\nstatic long bt_regexec_both(char_u *line,\n                            colnr_T col,      // column to start search\n                            proftime_T *tm,   // timeout limit or NULL\n                            int *timed_out)   // flag set on timeout or NULL\n{\n  bt_regprog_T        *prog;\n  char_u      *s;\n  long retval = 0L;\n\n  /* Create \"regstack\" and \"backpos\" if they are not allocated yet.\n   * We allocate *_INITIAL amount of bytes first and then set the grow size\n   * to much bigger value to avoid many malloc calls in case of deep regular\n   * expressions.  */\n  if (regstack.ga_data == NULL) {\n    /* Use an item size of 1 byte, since we push different things\n     * onto the regstack. */\n    ga_init(&regstack, 1, REGSTACK_INITIAL);\n    ga_grow(&regstack, REGSTACK_INITIAL);\n    ga_set_growsize(&regstack, REGSTACK_INITIAL * 8);\n  }\n\n  if (backpos.ga_data == NULL) {\n    ga_init(&backpos, sizeof(backpos_T), BACKPOS_INITIAL);\n    ga_grow(&backpos, BACKPOS_INITIAL);\n    ga_set_growsize(&backpos, BACKPOS_INITIAL * 8);\n  }\n\n  if (REG_MULTI) {\n    prog = (bt_regprog_T *)rex.reg_mmatch->regprog;\n    line = reg_getline((linenr_T)0);\n    rex.reg_startpos = rex.reg_mmatch->startpos;\n    rex.reg_endpos = rex.reg_mmatch->endpos;\n  } else {\n    prog = (bt_regprog_T *)rex.reg_match->regprog;\n    rex.reg_startp = rex.reg_match->startp;\n    rex.reg_endp = rex.reg_match->endp;\n  }\n\n  /* Be paranoid... */\n  if (prog == NULL || line == NULL) {\n    IEMSG(_(e_null));\n    goto theend;\n  }\n\n  /* Check validity of program. */\n  if (prog_magic_wrong())\n    goto theend;\n\n  // If the start column is past the maximum column: no need to try.\n  if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol) {\n    goto theend;\n  }\n\n  // If pattern contains \"\\c\" or \"\\C\": overrule value of rex.reg_ic\n  if (prog->regflags & RF_ICASE) {\n    rex.reg_ic = true;\n  } else if (prog->regflags & RF_NOICASE) {\n    rex.reg_ic = false;\n  }\n\n  // If pattern contains \"\\Z\" overrule value of rex.reg_icombine\n  if (prog->regflags & RF_ICOMBINE) {\n    rex.reg_icombine = true;\n  }\n\n  /* If there is a \"must appear\" string, look for it. */\n  if (prog->regmust != NULL) {\n    int c = utf_ptr2char(prog->regmust);\n    s = line + col;\n\n    // This is used very often, esp. for \":global\".  Use two versions of\n    // the loop to avoid overhead of conditions.\n    if (!rex.reg_ic) {\n      while ((s = vim_strchr(s, c)) != NULL) {\n        if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0) {\n          break;  // Found it.\n        }\n        MB_PTR_ADV(s);\n      }\n    } else {\n      while ((s = cstrchr(s, c)) != NULL) {\n        if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0) {\n          break;  // Found it.\n        }\n        MB_PTR_ADV(s);\n      }\n    }\n    if (s == NULL) {  // Not present.\n      goto theend;\n    }\n  }\n\n  rex.line = line;\n  rex.lnum = 0;\n  reg_toolong = false;\n\n  /* Simplest case: Anchored match need be tried only once. */\n  if (prog->reganch) {\n    int c = utf_ptr2char(rex.line + col);\n    if (prog->regstart == NUL\n        || prog->regstart == c\n        || (rex.reg_ic\n            && (utf_fold(prog->regstart) == utf_fold(c)\n                || (c < 255 && prog->regstart < 255\n                    && mb_tolower(prog->regstart) == mb_tolower(c))))) {\n      retval = regtry(prog, col, tm, timed_out);\n    } else {\n      retval = 0;\n    }\n  } else {\n    int tm_count = 0;\n    /* Messy cases:  unanchored match. */\n    while (!got_int) {\n      if (prog->regstart != NUL) {\n        // Skip until the char we know it must start with.\n        s = cstrchr(rex.line + col, prog->regstart);\n        if (s == NULL) {\n          retval = 0;\n          break;\n        }\n        col = (int)(s - rex.line);\n      }\n\n      // Check for maximum column to try.\n      if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol) {\n        retval = 0;\n        break;\n      }\n\n      retval = regtry(prog, col, tm, timed_out);\n      if (retval > 0) {\n        break;\n      }\n\n      // if not currently on the first line, get it again\n      if (rex.lnum != 0) {\n        rex.lnum = 0;\n        rex.line = reg_getline((linenr_T)0);\n      }\n      if (rex.line[col] == NUL) {\n        break;\n      }\n      col += (*mb_ptr2len)(rex.line + col);\n      // Check for timeout once in a twenty times to avoid overhead.\n      if (tm != NULL && ++tm_count == 20) {\n        tm_count = 0;\n        if (profile_passed_limit(*tm)) {\n          if (timed_out != NULL) {\n            *timed_out = true;\n          }\n          break;\n        }\n      }\n    }\n  }\n\ntheend:\n  /* Free \"reg_tofree\" when it's a bit big.\n   * Free regstack and backpos if they are bigger than their initial size. */\n  if (reg_tofreelen > 400) {\n    XFREE_CLEAR(reg_tofree);\n  }\n  if (regstack.ga_maxlen > REGSTACK_INITIAL)\n    ga_clear(&regstack);\n  if (backpos.ga_maxlen > BACKPOS_INITIAL)\n    ga_clear(&backpos);\n\n  if (retval > 0) {\n    // Make sure the end is never before the start.  Can happen when \\zs\n    // and \\ze are used.\n    if (REG_MULTI) {\n      const lpos_T *const start = &rex.reg_mmatch->startpos[0];\n      const lpos_T *const end = &rex.reg_mmatch->endpos[0];\n\n      if (end->lnum < start->lnum\n          || (end->lnum == start->lnum && end->col < start->col)) {\n        rex.reg_mmatch->endpos[0] = rex.reg_mmatch->startpos[0];\n      }\n    } else {\n      if (rex.reg_match->endp[0] < rex.reg_match->startp[0]) {\n        rex.reg_match->endp[0] = rex.reg_match->startp[0];\n      }\n    }\n  }\n\n  return retval;\n}\n\n\n/*\n * Create a new extmatch and mark it as referenced once.\n */\nstatic reg_extmatch_T *make_extmatch(void)\n  FUNC_ATTR_NONNULL_RET\n{\n  reg_extmatch_T *em = xcalloc(1, sizeof(reg_extmatch_T));\n  em->refcnt = 1;\n  return em;\n}\n\n/*\n * Add a reference to an extmatch.\n */\nreg_extmatch_T *ref_extmatch(reg_extmatch_T *em)\n{\n  if (em != NULL)\n    em->refcnt++;\n  return em;\n}\n\n/*\n * Remove a reference to an extmatch.  If there are no references left, free\n * the info.\n */\nvoid unref_extmatch(reg_extmatch_T *em)\n{\n  int i;\n\n  if (em != NULL && --em->refcnt <= 0) {\n    for (i = 0; i < NSUBEXP; ++i)\n      xfree(em->matches[i]);\n    xfree(em);\n  }\n}\n\n/// Try match of \"prog\" with at rex.line[\"col\"].\n/// @returns 0 for failure, or number of lines contained in the match.\nstatic long regtry(bt_regprog_T *prog,\n                   colnr_T col,\n                   proftime_T *tm,    // timeout limit or NULL\n                   int *timed_out)    // flag set on timeout or NULL\n{\n  rex.input = rex.line + col;\n  rex.need_clear_subexpr = true;\n  // Clear the external match subpointers if necessaey.\n  rex.need_clear_zsubexpr = (prog->reghasz == REX_SET);\n\n  if (regmatch(prog->program + 1, tm, timed_out) == 0) {\n    return 0;\n  }\n\n  cleanup_subexpr();\n  if (REG_MULTI) {\n    if (rex.reg_startpos[0].lnum < 0) {\n      rex.reg_startpos[0].lnum = 0;\n      rex.reg_startpos[0].col = col;\n    }\n    if (rex.reg_endpos[0].lnum < 0) {\n      rex.reg_endpos[0].lnum = rex.lnum;\n      rex.reg_endpos[0].col = (int)(rex.input - rex.line);\n    } else {\n      // Use line number of \"\\ze\".\n      rex.lnum = rex.reg_endpos[0].lnum;\n    }\n  } else {\n    if (rex.reg_startp[0] == NULL) {\n      rex.reg_startp[0] = rex.line + col;\n    }\n    if (rex.reg_endp[0] == NULL) {\n      rex.reg_endp[0] = rex.input;\n    }\n  }\n  /* Package any found \\z(...\\) matches for export. Default is none. */\n  unref_extmatch(re_extmatch_out);\n  re_extmatch_out = NULL;\n\n  if (prog->reghasz == REX_SET) {\n    int i;\n\n    cleanup_zsubexpr();\n    re_extmatch_out = make_extmatch();\n    for (i = 0; i < NSUBEXP; i++) {\n      if (REG_MULTI) {\n        /* Only accept single line matches. */\n        if (reg_startzpos[i].lnum >= 0\n            && reg_endzpos[i].lnum == reg_startzpos[i].lnum\n            && reg_endzpos[i].col >= reg_startzpos[i].col) {\n          re_extmatch_out->matches[i] =\n            vim_strnsave(reg_getline(reg_startzpos[i].lnum)\n                         + reg_startzpos[i].col,\n                         reg_endzpos[i].col\n                         - reg_startzpos[i].col);\n        }\n      } else {\n        if (reg_startzp[i] != NULL && reg_endzp[i] != NULL)\n          re_extmatch_out->matches[i] =\n            vim_strnsave(reg_startzp[i], reg_endzp[i] - reg_startzp[i]);\n      }\n    }\n  }\n  return 1 + rex.lnum;\n}\n\n\n// Get class of previous character.\nstatic int reg_prev_class(void)\n{\n  if (rex.input > rex.line) {\n    return mb_get_class_tab(\n        rex.input - 1 - utf_head_off(rex.line, rex.input - 1),\n        rex.reg_buf->b_chartab);\n  }\n  return -1;\n}\n\n\n// Return true if the current rex.input position matches the Visual area.\nstatic bool reg_match_visual(void)\n{\n  pos_T top, bot;\n  linenr_T lnum;\n  colnr_T col;\n  win_T *wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n  int mode;\n  colnr_T start, end;\n  colnr_T start2, end2;\n  colnr_T curswant;\n\n  // Check if the buffer is the current buffer.\n  if (rex.reg_buf != curbuf || VIsual.lnum == 0) {\n    return false;\n  }\n\n  if (VIsual_active) {\n    if (lt(VIsual, wp->w_cursor)) {\n      top = VIsual;\n      bot = wp->w_cursor;\n    } else {\n      top = wp->w_cursor;\n      bot = VIsual;\n    }\n    mode = VIsual_mode;\n    curswant = wp->w_curswant;\n  } else {\n    if (lt(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end)) {\n      top = curbuf->b_visual.vi_start;\n      bot = curbuf->b_visual.vi_end;\n    } else {\n      top = curbuf->b_visual.vi_end;\n      bot = curbuf->b_visual.vi_start;\n    }\n    mode = curbuf->b_visual.vi_mode;\n    curswant = curbuf->b_visual.vi_curswant;\n  }\n  lnum = rex.lnum + rex.reg_firstlnum;\n  if (lnum < top.lnum || lnum > bot.lnum) {\n    return false;\n  }\n\n  if (mode == 'v') {\n    col = (colnr_T)(rex.input - rex.line);\n    if ((lnum == top.lnum && col < top.col)\n        || (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e'))) {\n      return false;\n    }\n  } else if (mode == Ctrl_V) {\n    getvvcol(wp, &top, &start, NULL, &end);\n    getvvcol(wp, &bot, &start2, NULL, &end2);\n    if (start2 < start)\n      start = start2;\n    if (end2 > end)\n      end = end2;\n    if (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL) {\n      end = MAXCOL;\n    }\n    unsigned int cols_u = win_linetabsize(wp, rex.line,\n                                          (colnr_T)(rex.input - rex.line));\n    assert(cols_u <= MAXCOL);\n    colnr_T cols = (colnr_T)cols_u;\n    if (cols < start || cols > end - (*p_sel == 'e')) {\n      return false;\n    }\n  }\n  return true;\n}\n\n#define ADVANCE_REGINPUT() MB_PTR_ADV(rex.input)\n\n/*\n * The arguments from BRACE_LIMITS are stored here.  They are actually local\n * to regmatch(), but they are here to reduce the amount of stack space used\n * (it can be called recursively many times).\n */\nstatic long bl_minval;\nstatic long bl_maxval;\n\n/// Main matching routine\n///\n/// Conceptually the strategy is simple: Check to see whether the current node\n/// matches, push an item onto the regstack and loop to see whether the rest\n/// matches, and then act accordingly.  In practice we make some effort to\n/// avoid using the regstack, in particular by going through \"ordinary\" nodes\n/// (that don't need to know whether the rest of the match failed) by a nested\n/// loop.\n///\n/// Returns true when there is a match.  Leaves rex.input and rex.lnum\n/// just after the last matched character.\n/// Returns false when there is no match.  Leaves rex.input and rex.lnum in an\n/// undefined state!\nstatic bool regmatch(\n    char_u *scan,               // Current node.\n    proftime_T *tm,             // timeout limit or NULL\n    int *timed_out              // flag set on timeout or NULL\n)\n{\n  char_u        *next;          /* Next node. */\n  int op;\n  int c;\n  regitem_T     *rp;\n  int no;\n  int status;                   // one of the RA_ values:\n  int tm_count = 0;\n#define RA_FAIL         1       // something failed, abort\n#define RA_CONT         2       // continue in inner loop\n#define RA_BREAK        3       // break inner loop\n#define RA_MATCH        4       // successful match\n#define RA_NOMATCH      5       // didn't match\n\n  // Make \"regstack\" and \"backpos\" empty.  They are allocated and freed in\n  // bt_regexec_both() to reduce malloc()/free() calls.\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n\n  /*\n   * Repeat until \"regstack\" is empty.\n   */\n  for (;; ) {\n    /* Some patterns may take a long time to match, e.g., \"\\([a-z]\\+\\)\\+Q\".\n     * Allow interrupting them with CTRL-C. */\n    fast_breakcheck();\n\n#ifdef REGEXP_DEBUG\n    if (scan != NULL && regnarrate) {\n      mch_errmsg((char *)regprop(scan));\n      mch_errmsg(\"(\\n\");\n    }\n#endif\n\n    /*\n     * Repeat for items that can be matched sequentially, without using the\n     * regstack.\n     */\n    for (;; ) {\n      if (got_int || scan == NULL) {\n        status = RA_FAIL;\n        break;\n      }\n      // Check for timeout once in a 100 times to avoid overhead.\n      if (tm != NULL && ++tm_count == 100) {\n        tm_count = 0;\n        if (profile_passed_limit(*tm)) {\n          if (timed_out != NULL) {\n            *timed_out = true;\n          }\n          status = RA_FAIL;\n          break;\n        }\n      }\n      status = RA_CONT;\n\n#ifdef REGEXP_DEBUG\n      if (regnarrate) {\n        mch_errmsg((char *)regprop(scan));\n        mch_errmsg(\"...\\n\");\n        if (re_extmatch_in != NULL) {\n          int i;\n\n          mch_errmsg(_(\"External submatches:\\n\"));\n          for (i = 0; i < NSUBEXP; i++) {\n            mch_errmsg(\"    \\\"\");\n            if (re_extmatch_in->matches[i] != NULL)\n              mch_errmsg((char *)re_extmatch_in->matches[i]);\n            mch_errmsg(\"\\\"\\n\");\n          }\n        }\n      }\n#endif\n      next = regnext(scan);\n\n      op = OP(scan);\n      // Check for character class with NL added.\n      if (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n          && *rex.input == NUL && rex.lnum <= rex.reg_maxline) {\n        reg_nextline();\n      } else if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n') {\n        ADVANCE_REGINPUT();\n      } else {\n        if (WITH_NL(op)) {\n          op -= ADD_NL;\n        }\n        c = utf_ptr2char(rex.input);\n        switch (op) {\n        case BOL:\n          if (rex.input != rex.line) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case EOL:\n          if (c != NUL) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case RE_BOF:\n          // We're not at the beginning of the file when below the first\n          // line where we started, not at the start of the line or we\n          // didn't start at the first line of the buffer.\n          if (rex.lnum != 0 || rex.input != rex.line\n              || (REG_MULTI && rex.reg_firstlnum > 1)) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case RE_EOF:\n          if (rex.lnum != rex.reg_maxline || c != NUL) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case CURSOR:\n          // Check if the buffer is in a window and compare the\n          // rex.reg_win->w_cursor position to the match position.\n          if (rex.reg_win == NULL\n              || (rex.lnum + rex.reg_firstlnum != rex.reg_win->w_cursor.lnum)\n              || ((colnr_T)(rex.input - rex.line) !=\n                  rex.reg_win->w_cursor.col)) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case RE_MARK:\n          /* Compare the mark position to the match position. */\n        {\n          int mark = OPERAND(scan)[0];\n          int cmp = OPERAND(scan)[1];\n          pos_T   *pos;\n\n          pos = getmark_buf(rex.reg_buf, mark, false);\n          if (pos == NULL                    // mark doesn't exist\n              || pos->lnum <= 0) {           // mark isn't set in reg_buf\n            status = RA_NOMATCH;\n          } else {\n            const colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n              && pos->col == MAXCOL\n              ? (colnr_T)STRLEN(reg_getline(pos->lnum - rex.reg_firstlnum))\n              : pos->col;\n\n            if (pos->lnum == rex.lnum + rex.reg_firstlnum\n                ? (pos_col == (colnr_T)(rex.input - rex.line)\n                   ? (cmp == '<' || cmp == '>')\n                   : (pos_col < (colnr_T)(rex.input - rex.line)\n                      ? cmp != '>'\n                      : cmp != '<'))\n                : (pos->lnum < rex.lnum + rex.reg_firstlnum\n                   ? cmp != '>'\n                   : cmp != '<')) {\n              status = RA_NOMATCH;\n            }\n          }\n        }\n        break;\n\n        case RE_VISUAL:\n          if (!reg_match_visual())\n            status = RA_NOMATCH;\n          break;\n\n        case RE_LNUM:\n          assert(rex.lnum + rex.reg_firstlnum >= 0\n                 && (uintmax_t)(rex.lnum + rex.reg_firstlnum) <= UINT32_MAX);\n          if (!REG_MULTI\n              || !re_num_cmp((uint32_t)(rex.lnum + rex.reg_firstlnum), scan)) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case RE_COL:\n          assert(rex.input - rex.line + 1 >= 0\n                 && (uintmax_t)(rex.input - rex.line + 1) <= UINT32_MAX);\n          if (!re_num_cmp((uint32_t)(rex.input - rex.line + 1), scan)) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case RE_VCOL:\n          if (!re_num_cmp(win_linetabsize(rex.reg_win == NULL\n                                          ? curwin : rex.reg_win,\n                                          rex.line,\n                                          (colnr_T)(rex.input - rex.line)) + 1,\n                          scan)) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case BOW:  // \\<word; rex.input points to w\n          if (c == NUL) {  // Can't match at end of line\n            status = RA_NOMATCH;\n          } else {\n            // Get class of current and previous char (if it exists).\n            const int this_class =\n              mb_get_class_tab(rex.input, rex.reg_buf->b_chartab);\n            if (this_class <= 1) {\n              status = RA_NOMATCH;  // Not on a word at all.\n            } else if (reg_prev_class() == this_class) {\n              status = RA_NOMATCH;  // Previous char is in same word.\n            }\n          }\n          break;\n\n        case EOW:  // word\\>; rex.input points after d\n          if (rex.input == rex.line) {  // Can't match at start of line\n            status = RA_NOMATCH;\n          } else {\n            int this_class, prev_class;\n\n            // Get class of current and previous char (if it exists).\n            this_class = mb_get_class_tab(rex.input, rex.reg_buf->b_chartab);\n            prev_class = reg_prev_class();\n            if (this_class == prev_class\n                || prev_class == 0 || prev_class == 1) {\n              status = RA_NOMATCH;\n            }\n          }\n          break;  // Matched with EOW\n\n        case ANY:\n          // ANY does not match new lines.\n          if (c == NUL) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case IDENT:\n          if (!vim_isIDc(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case SIDENT:\n          if (ascii_isdigit(*rex.input) || !vim_isIDc(c)) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case KWORD:\n          if (!vim_iswordp_buf(rex.input, rex.reg_buf)) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case SKWORD:\n          if (ascii_isdigit(*rex.input)\n              || !vim_iswordp_buf(rex.input, rex.reg_buf)) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case FNAME:\n          if (!vim_isfilec(c)) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case SFNAME:\n          if (ascii_isdigit(*rex.input) || !vim_isfilec(c)) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case PRINT:\n          if (!vim_isprintc(PTR2CHAR(rex.input))) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case SPRINT:\n          if (ascii_isdigit(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input))) {\n            status = RA_NOMATCH;\n          } else {\n            ADVANCE_REGINPUT();\n          }\n          break;\n\n        case WHITE:\n          if (!ascii_iswhite(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NWHITE:\n          if (c == NUL || ascii_iswhite(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case DIGIT:\n          if (!ri_digit(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NDIGIT:\n          if (c == NUL || ri_digit(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case HEX:\n          if (!ri_hex(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NHEX:\n          if (c == NUL || ri_hex(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case OCTAL:\n          if (!ri_octal(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NOCTAL:\n          if (c == NUL || ri_octal(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case WORD:\n          if (!ri_word(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NWORD:\n          if (c == NUL || ri_word(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case HEAD:\n          if (!ri_head(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NHEAD:\n          if (c == NUL || ri_head(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case ALPHA:\n          if (!ri_alpha(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NALPHA:\n          if (c == NUL || ri_alpha(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case LOWER:\n          if (!ri_lower(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NLOWER:\n          if (c == NUL || ri_lower(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case UPPER:\n          if (!ri_upper(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case NUPPER:\n          if (c == NUL || ri_upper(c))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case EXACTLY:\n        {\n          int len;\n          char_u  *opnd;\n\n          opnd = OPERAND(scan);\n          // Inline the first byte, for speed.\n          if (*opnd != *rex.input\n              && (!rex.reg_ic)) {\n            status = RA_NOMATCH;\n          } else if (*opnd == NUL) {\n            // match empty string always works; happens when \"~\" is\n            // empty.\n          } else {\n            if (opnd[1] == NUL && !rex.reg_ic) {\n              len = 1;  // matched a single byte above\n            } else {\n              // Need to match first byte again for multi-byte.\n              len = (int)STRLEN(opnd);\n              if (cstrncmp(opnd, rex.input, &len) != 0) {\n                status = RA_NOMATCH;\n              }\n            }\n            // Check for following composing character, unless %C\n            // follows (skips over all composing chars).\n            if (status != RA_NOMATCH\n                && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n                && !rex.reg_icombine\n                && OP(next) != RE_COMPOSING) {\n              // raaron: This code makes a composing character get\n              // ignored, which is the correct behavior (sometimes)\n              // for voweled Hebrew texts.\n              status = RA_NOMATCH;\n            }\n            if (status != RA_NOMATCH) {\n              rex.input += len;\n            }\n          }\n        }\n        break;\n\n        case ANYOF:\n        case ANYBUT:\n          if (c == NUL)\n            status = RA_NOMATCH;\n          else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n            status = RA_NOMATCH;\n          else\n            ADVANCE_REGINPUT();\n          break;\n\n        case MULTIBYTECODE:\n          {\n            int i, len;\n\n            const char_u *opnd = OPERAND(scan);\n            // Safety check (just in case 'encoding' was changed since\n            // compiling the program).\n            if ((len = (*mb_ptr2len)(opnd)) < 2) {\n              status = RA_NOMATCH;\n              break;\n            }\n            const int opndc = utf_ptr2char(opnd);\n            if (utf_iscomposing(opndc)) {\n              // When only a composing char is given match at any\n              // position where that composing char appears.\n              status = RA_NOMATCH;\n              for (i = 0; rex.input[i] != NUL;\n                   i += utf_ptr2len(rex.input + i)) {\n                const int inpc = utf_ptr2char(rex.input + i);\n                if (!utf_iscomposing(inpc)) {\n                  if (i > 0) {\n                    break;\n                  }\n                } else if (opndc == inpc) {\n                  // Include all following composing chars.\n                  len = i + utfc_ptr2len(rex.input + i);\n                  status = RA_MATCH;\n                  break;\n                }\n              }\n            } else {\n              for (i = 0; i < len; i++) {\n                if (opnd[i] != rex.input[i]) {\n                  status = RA_NOMATCH;\n                  break;\n                }\n              }\n            }\n            rex.input += len;\n          }\n          break;\n\n        case RE_COMPOSING:\n          {\n            // Skip composing characters.\n            while (utf_iscomposing(utf_ptr2char(rex.input))) {\n              MB_CPTR_ADV(rex.input);\n            }\n          }\n          break;\n\n        case NOTHING:\n          break;\n\n        case BACK:\n        {\n          int i;\n\n          /*\n           * When we run into BACK we need to check if we don't keep\n           * looping without matching any input.  The second and later\n           * times a BACK is encountered it fails if the input is still\n           * at the same position as the previous time.\n           * The positions are stored in \"backpos\" and found by the\n           * current value of \"scan\", the position in the RE program.\n           */\n          backpos_T *bp = (backpos_T *)backpos.ga_data;\n          for (i = 0; i < backpos.ga_len; ++i)\n            if (bp[i].bp_scan == scan)\n              break;\n          if (i == backpos.ga_len) {\n            backpos_T *p = GA_APPEND_VIA_PTR(backpos_T, &backpos);\n            p->bp_scan = scan;\n          } else if (reg_save_equal(&bp[i].bp_pos))\n            /* Still at same position as last time, fail. */\n            status = RA_NOMATCH;\n\n          assert(status != RA_FAIL);\n          if (status != RA_NOMATCH) {\n            reg_save(&bp[i].bp_pos, &backpos);\n          }\n        }\n        break;\n\n        case MOPEN + 0:     /* Match start: \\zs */\n        case MOPEN + 1:     /* \\( */\n        case MOPEN + 2:\n        case MOPEN + 3:\n        case MOPEN + 4:\n        case MOPEN + 5:\n        case MOPEN + 6:\n        case MOPEN + 7:\n        case MOPEN + 8:\n        case MOPEN + 9:\n        {\n          no = op - MOPEN;\n          cleanup_subexpr();\n          rp = regstack_push(RS_MOPEN, scan);\n          if (rp == NULL)\n            status = RA_FAIL;\n          else {\n            rp->rs_no = no;\n            save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n                    &rex.reg_startp[no]);\n            // We simply continue and handle the result when done.\n          }\n        }\n        break;\n\n        case NOPEN:         /* \\%( */\n        case NCLOSE:        /* \\) after \\%( */\n          if (regstack_push(RS_NOPEN, scan) == NULL)\n            status = RA_FAIL;\n          /* We simply continue and handle the result when done. */\n          break;\n\n        case ZOPEN + 1:\n        case ZOPEN + 2:\n        case ZOPEN + 3:\n        case ZOPEN + 4:\n        case ZOPEN + 5:\n        case ZOPEN + 6:\n        case ZOPEN + 7:\n        case ZOPEN + 8:\n        case ZOPEN + 9:\n        {\n          no = op - ZOPEN;\n          cleanup_zsubexpr();\n          rp = regstack_push(RS_ZOPEN, scan);\n          if (rp == NULL)\n            status = RA_FAIL;\n          else {\n            rp->rs_no = no;\n            save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n                &reg_startzp[no]);\n            /* We simply continue and handle the result when done. */\n          }\n        }\n        break;\n\n        case MCLOSE + 0:    /* Match end: \\ze */\n        case MCLOSE + 1:    /* \\) */\n        case MCLOSE + 2:\n        case MCLOSE + 3:\n        case MCLOSE + 4:\n        case MCLOSE + 5:\n        case MCLOSE + 6:\n        case MCLOSE + 7:\n        case MCLOSE + 8:\n        case MCLOSE + 9:\n        {\n          no = op - MCLOSE;\n          cleanup_subexpr();\n          rp = regstack_push(RS_MCLOSE, scan);\n          if (rp == NULL) {\n            status = RA_FAIL;\n          } else {\n            rp->rs_no = no;\n            save_se(&rp->rs_un.sesave, &rex.reg_endpos[no], &rex.reg_endp[no]);\n            // We simply continue and handle the result when done.\n          }\n        }\n        break;\n\n        case ZCLOSE + 1:    /* \\) after \\z( */\n        case ZCLOSE + 2:\n        case ZCLOSE + 3:\n        case ZCLOSE + 4:\n        case ZCLOSE + 5:\n        case ZCLOSE + 6:\n        case ZCLOSE + 7:\n        case ZCLOSE + 8:\n        case ZCLOSE + 9:\n        {\n          no = op - ZCLOSE;\n          cleanup_zsubexpr();\n          rp = regstack_push(RS_ZCLOSE, scan);\n          if (rp == NULL)\n            status = RA_FAIL;\n          else {\n            rp->rs_no = no;\n            save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n                &reg_endzp[no]);\n            /* We simply continue and handle the result when done. */\n          }\n        }\n        break;\n\n        case BACKREF + 1:\n        case BACKREF + 2:\n        case BACKREF + 3:\n        case BACKREF + 4:\n        case BACKREF + 5:\n        case BACKREF + 6:\n        case BACKREF + 7:\n        case BACKREF + 8:\n        case BACKREF + 9:\n        {\n          int len;\n\n          no = op - BACKREF;\n          cleanup_subexpr();\n          if (!REG_MULTI) {  // Single-line regexp\n            if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL) {\n              // Backref was not set: Match an empty string.\n              len = 0;\n            } else {\n              // Compare current input with back-ref in the same line.\n              len = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n              if (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0) {\n                status = RA_NOMATCH;\n              }\n            }\n          } else {  // Multi-line regexp\n            if (rex.reg_startpos[no].lnum < 0 || rex.reg_endpos[no].lnum < 0) {\n              // Backref was not set: Match an empty string.\n              len = 0;\n            } else {\n              if (rex.reg_startpos[no].lnum == rex.lnum\n                  && rex.reg_endpos[no].lnum == rex.lnum) {\n                // Compare back-ref within the current line.\n                len = rex.reg_endpos[no].col - rex.reg_startpos[no].col;\n                if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n                             rex.input, &len) != 0) {\n                  status = RA_NOMATCH;\n                }\n              } else {\n                // Messy situation: Need to compare between two lines.\n                int r = match_with_backref(rex.reg_startpos[no].lnum,\n                                           rex.reg_startpos[no].col,\n                                           rex.reg_endpos[no].lnum,\n                                           rex.reg_endpos[no].col,\n                                           &len);\n                if (r != RA_MATCH) {\n                  status = r;\n                }\n              }\n            }\n          }\n\n          // Matched the backref, skip over it.\n          rex.input += len;\n        }\n        break;\n\n        case ZREF + 1:\n        case ZREF + 2:\n        case ZREF + 3:\n        case ZREF + 4:\n        case ZREF + 5:\n        case ZREF + 6:\n        case ZREF + 7:\n        case ZREF + 8:\n        case ZREF + 9:\n        {\n          cleanup_zsubexpr();\n          no = op - ZREF;\n          if (re_extmatch_in != NULL\n              && re_extmatch_in->matches[no] != NULL) {\n            int len = (int)STRLEN(re_extmatch_in->matches[no]);\n            if (cstrncmp(re_extmatch_in->matches[no], rex.input, &len) != 0) {\n              status = RA_NOMATCH;\n            } else {\n              rex.input += len;\n            }\n          } else {\n            // Backref was not set: Match an empty string.\n          }\n        }\n        break;\n\n        case BRANCH:\n        {\n          if (OP(next) != BRANCH)       /* No choice. */\n            next = OPERAND(scan);               /* Avoid recursion. */\n          else {\n            rp = regstack_push(RS_BRANCH, scan);\n            if (rp == NULL)\n              status = RA_FAIL;\n            else\n              status = RA_BREAK;                /* rest is below */\n          }\n        }\n        break;\n\n        case BRACE_LIMITS:\n        {\n          if (OP(next) == BRACE_SIMPLE) {\n            bl_minval = OPERAND_MIN(scan);\n            bl_maxval = OPERAND_MAX(scan);\n          } else if (OP(next) >= BRACE_COMPLEX\n                     && OP(next) < BRACE_COMPLEX + 10) {\n            no = OP(next) - BRACE_COMPLEX;\n            brace_min[no] = OPERAND_MIN(scan);\n            brace_max[no] = OPERAND_MAX(scan);\n            brace_count[no] = 0;\n          } else {\n            internal_error(\"BRACE_LIMITS\");\n            status = RA_FAIL;\n          }\n        }\n        break;\n\n        case BRACE_COMPLEX + 0:\n        case BRACE_COMPLEX + 1:\n        case BRACE_COMPLEX + 2:\n        case BRACE_COMPLEX + 3:\n        case BRACE_COMPLEX + 4:\n        case BRACE_COMPLEX + 5:\n        case BRACE_COMPLEX + 6:\n        case BRACE_COMPLEX + 7:\n        case BRACE_COMPLEX + 8:\n        case BRACE_COMPLEX + 9:\n        {\n          no = op - BRACE_COMPLEX;\n          ++brace_count[no];\n\n          /* If not matched enough times yet, try one more */\n          if (brace_count[no] <= (brace_min[no] <= brace_max[no]\n                                  ? brace_min[no] : brace_max[no])) {\n            rp = regstack_push(RS_BRCPLX_MORE, scan);\n            if (rp == NULL)\n              status = RA_FAIL;\n            else {\n              rp->rs_no = no;\n              reg_save(&rp->rs_un.regsave, &backpos);\n              next = OPERAND(scan);\n              /* We continue and handle the result when done. */\n            }\n            break;\n          }\n\n          /* If matched enough times, may try matching some more */\n          if (brace_min[no] <= brace_max[no]) {\n            /* Range is the normal way around, use longest match */\n            if (brace_count[no] <= brace_max[no]) {\n              rp = regstack_push(RS_BRCPLX_LONG, scan);\n              if (rp == NULL)\n                status = RA_FAIL;\n              else {\n                rp->rs_no = no;\n                reg_save(&rp->rs_un.regsave, &backpos);\n                next = OPERAND(scan);\n                /* We continue and handle the result when done. */\n              }\n            }\n          } else {\n            /* Range is backwards, use shortest match first */\n            if (brace_count[no] <= brace_min[no]) {\n              rp = regstack_push(RS_BRCPLX_SHORT, scan);\n              if (rp == NULL)\n                status = RA_FAIL;\n              else {\n                reg_save(&rp->rs_un.regsave, &backpos);\n                /* We continue and handle the result when done. */\n              }\n            }\n          }\n        }\n        break;\n\n        case BRACE_SIMPLE:\n        case STAR:\n        case PLUS:\n        {\n          regstar_T rst;\n\n          /*\n           * Lookahead to avoid useless match attempts when we know\n           * what character comes next.\n           */\n          if (OP(next) == EXACTLY) {\n            rst.nextb = *OPERAND(next);\n            if (rex.reg_ic) {\n              if (mb_isupper(rst.nextb)) {\n                rst.nextb_ic = mb_tolower(rst.nextb);\n              } else {\n                rst.nextb_ic = mb_toupper(rst.nextb);\n              }\n            } else {\n              rst.nextb_ic = rst.nextb;\n            }\n          } else {\n            rst.nextb = NUL;\n            rst.nextb_ic = NUL;\n          }\n          if (op != BRACE_SIMPLE) {\n            rst.minval = (op == STAR) ? 0 : 1;\n            rst.maxval = MAX_LIMIT;\n          } else {\n            rst.minval = bl_minval;\n            rst.maxval = bl_maxval;\n          }\n\n          /*\n           * When maxval > minval, try matching as much as possible, up\n           * to maxval.  When maxval < minval, try matching at least the\n           * minimal number (since the range is backwards, that's also\n           * maxval!).\n           */\n          rst.count = regrepeat(OPERAND(scan), rst.maxval);\n          if (got_int) {\n            status = RA_FAIL;\n            break;\n          }\n          if (rst.minval <= rst.maxval\n              ? rst.count >= rst.minval : rst.count >= rst.maxval) {\n            /* It could match.  Prepare for trying to match what\n             * follows.  The code is below.  Parameters are stored in\n             * a regstar_T on the regstack. */\n            if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) {\n              EMSG(_(e_maxmempat));\n              status = RA_FAIL;\n            } else {\n              ga_grow(&regstack, sizeof(regstar_T));\n              regstack.ga_len += sizeof(regstar_T);\n              rp = regstack_push(rst.minval <= rst.maxval\n                  ? RS_STAR_LONG : RS_STAR_SHORT, scan);\n              if (rp == NULL)\n                status = RA_FAIL;\n              else {\n                *(((regstar_T *)rp) - 1) = rst;\n                status = RA_BREAK;                  /* skip the restore bits */\n              }\n            }\n          } else\n            status = RA_NOMATCH;\n\n        }\n        break;\n\n        case NOMATCH:\n        case MATCH:\n        case SUBPAT:\n          rp = regstack_push(RS_NOMATCH, scan);\n          if (rp == NULL)\n            status = RA_FAIL;\n          else {\n            rp->rs_no = op;\n            reg_save(&rp->rs_un.regsave, &backpos);\n            next = OPERAND(scan);\n            /* We continue and handle the result when done. */\n          }\n          break;\n\n        case BEHIND:\n        case NOBEHIND:\n          /* Need a bit of room to store extra positions. */\n          if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) {\n            EMSG(_(e_maxmempat));\n            status = RA_FAIL;\n          } else {\n            ga_grow(&regstack, sizeof(regbehind_T));\n            regstack.ga_len += sizeof(regbehind_T);\n            rp = regstack_push(RS_BEHIND1, scan);\n            if (rp == NULL)\n              status = RA_FAIL;\n            else {\n              /* Need to save the subexpr to be able to restore them\n               * when there is a match but we don't use it. */\n              save_subexpr(((regbehind_T *)rp) - 1);\n\n              rp->rs_no = op;\n              reg_save(&rp->rs_un.regsave, &backpos);\n              /* First try if what follows matches.  If it does then we\n               * check the behind match by looping. */\n            }\n          }\n          break;\n\n        case BHPOS:\n          if (REG_MULTI) {\n            if (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n                || behind_pos.rs_u.pos.lnum != rex.lnum) {\n              status = RA_NOMATCH;\n            }\n          } else if (behind_pos.rs_u.ptr != rex.input) {\n            status = RA_NOMATCH;\n          }\n          break;\n\n        case NEWL:\n          if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n               || rex.reg_line_lbr) && (c != '\\n' || !rex.reg_line_lbr)) {\n            status = RA_NOMATCH;\n          } else if (rex.reg_line_lbr) {\n            ADVANCE_REGINPUT();\n          } else {\n            reg_nextline();\n          }\n          break;\n\n        case END:\n          status = RA_MATCH;    /* Success! */\n          break;\n\n        default:\n          IEMSG(_(e_re_corr));\n#ifdef REGEXP_DEBUG\n          printf(\"Illegal op code %d\\n\", op);\n#endif\n          status = RA_FAIL;\n          break;\n        }\n      }\n\n      /* If we can't continue sequentially, break the inner loop. */\n      if (status != RA_CONT)\n        break;\n\n      /* Continue in inner loop, advance to next item. */\n      scan = next;\n\n    } /* end of inner loop */\n\n    /*\n     * If there is something on the regstack execute the code for the state.\n     * If the state is popped then loop and use the older state.\n     */\n    while (!GA_EMPTY(&regstack) && status != RA_FAIL) {\n      rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n      switch (rp->rs_state) {\n      case RS_NOPEN:\n        /* Result is passed on as-is, simply pop the state. */\n        regstack_pop(&scan);\n        break;\n\n      case RS_MOPEN:\n        // Pop the state.  Restore pointers when there is no match.\n        if (status == RA_NOMATCH) {\n          restore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n                     &rex.reg_startp[rp->rs_no]);\n        }\n        regstack_pop(&scan);\n        break;\n\n      case RS_ZOPEN:\n        /* Pop the state.  Restore pointers when there is no match. */\n        if (status == RA_NOMATCH)\n          restore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n              &reg_startzp[rp->rs_no]);\n        regstack_pop(&scan);\n        break;\n\n      case RS_MCLOSE:\n        // Pop the state.  Restore pointers when there is no match.\n        if (status == RA_NOMATCH) {\n          restore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n                     &rex.reg_endp[rp->rs_no]);\n        }\n        regstack_pop(&scan);\n        break;\n\n      case RS_ZCLOSE:\n        /* Pop the state.  Restore pointers when there is no match. */\n        if (status == RA_NOMATCH)\n          restore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n              &reg_endzp[rp->rs_no]);\n        regstack_pop(&scan);\n        break;\n\n      case RS_BRANCH:\n        if (status == RA_MATCH)\n          /* this branch matched, use it */\n          regstack_pop(&scan);\n        else {\n          if (status != RA_BREAK) {\n            /* After a non-matching branch: try next one. */\n            reg_restore(&rp->rs_un.regsave, &backpos);\n            scan = rp->rs_scan;\n          }\n          if (scan == NULL || OP(scan) != BRANCH) {\n            /* no more branches, didn't find a match */\n            status = RA_NOMATCH;\n            regstack_pop(&scan);\n          } else {\n            /* Prepare to try a branch. */\n            rp->rs_scan = regnext(scan);\n            reg_save(&rp->rs_un.regsave, &backpos);\n            scan = OPERAND(scan);\n          }\n        }\n        break;\n\n      case RS_BRCPLX_MORE:\n        /* Pop the state.  Restore pointers when there is no match. */\n        if (status == RA_NOMATCH) {\n          reg_restore(&rp->rs_un.regsave, &backpos);\n          --brace_count[rp->rs_no];             /* decrement match count */\n        }\n        regstack_pop(&scan);\n        break;\n\n      case RS_BRCPLX_LONG:\n        /* Pop the state.  Restore pointers when there is no match. */\n        if (status == RA_NOMATCH) {\n          /* There was no match, but we did find enough matches. */\n          reg_restore(&rp->rs_un.regsave, &backpos);\n          --brace_count[rp->rs_no];\n          /* continue with the items after \"\\{}\" */\n          status = RA_CONT;\n        }\n        regstack_pop(&scan);\n        if (status == RA_CONT)\n          scan = regnext(scan);\n        break;\n\n      case RS_BRCPLX_SHORT:\n        /* Pop the state.  Restore pointers when there is no match. */\n        if (status == RA_NOMATCH)\n          /* There was no match, try to match one more item. */\n          reg_restore(&rp->rs_un.regsave, &backpos);\n        regstack_pop(&scan);\n        if (status == RA_NOMATCH) {\n          scan = OPERAND(scan);\n          status = RA_CONT;\n        }\n        break;\n\n      case RS_NOMATCH:\n        /* Pop the state.  If the operand matches for NOMATCH or\n        * doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,\n        * except for SUBPAT, and continue with the next item. */\n        if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n          status = RA_NOMATCH;\n        else {\n          status = RA_CONT;\n          if (rp->rs_no != SUBPAT)              /* zero-width */\n            reg_restore(&rp->rs_un.regsave, &backpos);\n        }\n        regstack_pop(&scan);\n        if (status == RA_CONT)\n          scan = regnext(scan);\n        break;\n\n      case RS_BEHIND1:\n        if (status == RA_NOMATCH) {\n          regstack_pop(&scan);\n          regstack.ga_len -= sizeof(regbehind_T);\n        } else {\n          /* The stuff after BEHIND/NOBEHIND matches.  Now try if\n           * the behind part does (not) match before the current\n           * position in the input.  This must be done at every\n           * position in the input and checking if the match ends at\n           * the current position. */\n\n          /* save the position after the found match for next */\n          reg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\n          /* Start looking for a match with operand at the current\n           * position.  Go back one character until we find the\n           * result, hitting the start of the line or the previous\n           * line (for multi-line matching).\n           * Set behind_pos to where the match should end, BHPOS\n           * will match it.  Save the current value. */\n          (((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n          behind_pos = rp->rs_un.regsave;\n\n          rp->rs_state = RS_BEHIND2;\n\n          reg_restore(&rp->rs_un.regsave, &backpos);\n          scan = OPERAND(rp->rs_scan) + 4;\n        }\n        break;\n\n      case RS_BEHIND2:\n        /*\n         * Looping for BEHIND / NOBEHIND match.\n         */\n        if (status == RA_MATCH && reg_save_equal(&behind_pos)) {\n          /* found a match that ends where \"next\" started */\n          behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n          if (rp->rs_no == BEHIND)\n            reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n                &backpos);\n          else {\n            /* But we didn't want a match.  Need to restore the\n             * subexpr, because what follows matched, so they have\n             * been set. */\n            status = RA_NOMATCH;\n            restore_subexpr(((regbehind_T *)rp) - 1);\n          }\n          regstack_pop(&scan);\n          regstack.ga_len -= sizeof(regbehind_T);\n        } else {\n          long limit;\n\n          /* No match or a match that doesn't end where we want it: Go\n           * back one character.  May go to previous line once. */\n          no = OK;\n          limit = OPERAND_MIN(rp->rs_scan);\n          if (REG_MULTI) {\n            if (limit > 0\n                && ((rp->rs_un.regsave.rs_u.pos.lnum\n                     < behind_pos.rs_u.pos.lnum\n                     ? (colnr_T)STRLEN(rex.line)\n                     : behind_pos.rs_u.pos.col)\n                    - rp->rs_un.regsave.rs_u.pos.col >= limit))\n              no = FAIL;\n            else if (rp->rs_un.regsave.rs_u.pos.col == 0) {\n              if (rp->rs_un.regsave.rs_u.pos.lnum\n                  < behind_pos.rs_u.pos.lnum\n                  || reg_getline(\n                      --rp->rs_un.regsave.rs_u.pos.lnum)\n                  == NULL)\n                no = FAIL;\n              else {\n                reg_restore(&rp->rs_un.regsave, &backpos);\n                rp->rs_un.regsave.rs_u.pos.col =\n                  (colnr_T)STRLEN(rex.line);\n              }\n            } else {\n              const char_u *const line =\n                  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\n              rp->rs_un.regsave.rs_u.pos.col -=\n                  utf_head_off(line,\n                               line + rp->rs_un.regsave.rs_u.pos.col - 1)\n                  + 1;\n            }\n          } else {\n            if (rp->rs_un.regsave.rs_u.ptr == rex.line) {\n              no = FAIL;\n            } else {\n              MB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n              if (limit > 0\n                  && (long)(behind_pos.rs_u.ptr\n                            - rp->rs_un.regsave.rs_u.ptr) > limit) {\n                no = FAIL;\n              }\n            }\n          }\n          if (no == OK) {\n            /* Advanced, prepare for finding match again. */\n            reg_restore(&rp->rs_un.regsave, &backpos);\n            scan = OPERAND(rp->rs_scan) + 4;\n            if (status == RA_MATCH) {\n              /* We did match, so subexpr may have been changed,\n               * need to restore them for the next try. */\n              status = RA_NOMATCH;\n              restore_subexpr(((regbehind_T *)rp) - 1);\n            }\n          } else {\n            /* Can't advance.  For NOBEHIND that's a match. */\n            behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n            if (rp->rs_no == NOBEHIND) {\n              reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n                  &backpos);\n              status = RA_MATCH;\n            } else {\n              /* We do want a proper match.  Need to restore the\n               * subexpr if we had a match, because they may have\n               * been set. */\n              if (status == RA_MATCH) {\n                status = RA_NOMATCH;\n                restore_subexpr(((regbehind_T *)rp) - 1);\n              }\n            }\n            regstack_pop(&scan);\n            regstack.ga_len -= sizeof(regbehind_T);\n          }\n        }\n        break;\n\n      case RS_STAR_LONG:\n      case RS_STAR_SHORT:\n      {\n        regstar_T           *rst = ((regstar_T *)rp) - 1;\n\n        if (status == RA_MATCH) {\n          regstack_pop(&scan);\n          regstack.ga_len -= sizeof(regstar_T);\n          break;\n        }\n\n        /* Tried once already, restore input pointers. */\n        if (status != RA_BREAK)\n          reg_restore(&rp->rs_un.regsave, &backpos);\n\n        /* Repeat until we found a position where it could match. */\n        for (;; ) {\n          if (status != RA_BREAK) {\n            /* Tried first position already, advance. */\n            if (rp->rs_state == RS_STAR_LONG) {\n              /* Trying for longest match, but couldn't or\n               * didn't match -- back up one char. */\n              if (--rst->count < rst->minval)\n                break;\n              if (rex.input == rex.line) {\n                // backup to last char of previous line\n                rex.lnum--;\n                rex.line = reg_getline(rex.lnum);\n                // Just in case regrepeat() didn't count right.\n                if (rex.line == NULL) {\n                  break;\n                }\n                rex.input = rex.line + STRLEN(rex.line);\n                fast_breakcheck();\n              } else {\n                MB_PTR_BACK(rex.line, rex.input);\n              }\n            } else {\n              /* Range is backwards, use shortest match first.\n               * Careful: maxval and minval are exchanged!\n               * Couldn't or didn't match: try advancing one\n               * char. */\n              if (rst->count == rst->minval\n                  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n                break;\n              ++rst->count;\n            }\n            if (got_int)\n              break;\n          } else\n            status = RA_NOMATCH;\n\n          // If it could match, try it.\n          if (rst->nextb == NUL || *rex.input == rst->nextb\n              || *rex.input == rst->nextb_ic) {\n            reg_save(&rp->rs_un.regsave, &backpos);\n            scan = regnext(rp->rs_scan);\n            status = RA_CONT;\n            break;\n          }\n        }\n        if (status != RA_CONT) {\n          /* Failed. */\n          regstack_pop(&scan);\n          regstack.ga_len -= sizeof(regstar_T);\n          status = RA_NOMATCH;\n        }\n      }\n      break;\n      }\n\n      /* If we want to continue the inner loop or didn't pop a state\n       * continue matching loop */\n      if (status == RA_CONT || rp == (regitem_T *)\n          ((char *)regstack.ga_data + regstack.ga_len) - 1)\n        break;\n    }\n\n    /* May need to continue with the inner loop, starting at \"scan\". */\n    if (status == RA_CONT)\n      continue;\n\n    /*\n     * If the regstack is empty or something failed we are done.\n     */\n    if (GA_EMPTY(&regstack) || status == RA_FAIL) {\n      if (scan == NULL) {\n        /*\n         * We get here only if there's trouble -- normally \"case END\" is\n         * the terminating point.\n         */\n        IEMSG(_(e_re_corr));\n#ifdef REGEXP_DEBUG\n        printf(\"Premature EOL\\n\");\n#endif\n      }\n      return status == RA_MATCH;\n    }\n\n  } /* End of loop until the regstack is empty. */\n\n  /* NOTREACHED */\n}\n\n/*\n * Push an item onto the regstack.\n * Returns pointer to new item.  Returns NULL when out of memory.\n */\nstatic regitem_T *regstack_push(regstate_T state, char_u *scan)\n{\n  regitem_T   *rp;\n\n  if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp) {\n    EMSG(_(e_maxmempat));\n    return NULL;\n  }\n  ga_grow(&regstack, sizeof(regitem_T));\n\n  rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len);\n  rp->rs_state = state;\n  rp->rs_scan = scan;\n\n  regstack.ga_len += sizeof(regitem_T);\n  return rp;\n}\n\n/*\n * Pop an item from the regstack.\n */\nstatic void regstack_pop(char_u **scan)\n{\n  regitem_T   *rp;\n\n  rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n  *scan = rp->rs_scan;\n\n  regstack.ga_len -= sizeof(regitem_T);\n}\n\n/*\n * regrepeat - repeatedly match something simple, return how many.\n * Advances rex.input (and rex.lnum) to just after the matched chars.\n */\nstatic int \nregrepeat (\n    char_u *p,\n    long maxcount              /* maximum number of matches allowed */\n)\n{\n  long count = 0;\n  char_u      *opnd;\n  int mask;\n  int testval = 0;\n\n  char_u *scan = rex.input;  // Make local copy of rex.input for speed.\n  opnd = OPERAND(p);\n  switch (OP(p)) {\n  case ANY:\n  case ANY + ADD_NL:\n    while (count < maxcount) {\n      /* Matching anything means we continue until end-of-line (or\n       * end-of-file for ANY + ADD_NL), only limited by maxcount. */\n      while (*scan != NUL && count < maxcount) {\n        count++;\n        MB_PTR_ADV(scan);\n      }\n      if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n          || rex.reg_line_lbr || count == maxcount) {\n        break;\n      }\n      count++;  // count the line-break\n      reg_nextline();\n      scan = rex.input;\n      if (got_int) {\n        break;\n      }\n    }\n    break;\n\n  case IDENT:\n  case IDENT + ADD_NL:\n    testval = 1;\n    FALLTHROUGH;\n  case SIDENT:\n  case SIDENT + ADD_NL:\n    while (count < maxcount) {\n      if (vim_isIDc(PTR2CHAR(scan)) && (testval || !ascii_isdigit(*scan))) {\n        MB_PTR_ADV(scan);\n      } else if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else {\n        break;\n      }\n      ++count;\n    }\n    break;\n\n  case KWORD:\n  case KWORD + ADD_NL:\n    testval = 1;\n    FALLTHROUGH;\n  case SKWORD:\n  case SKWORD + ADD_NL:\n    while (count < maxcount) {\n      if (vim_iswordp_buf(scan, rex.reg_buf)\n          && (testval || !ascii_isdigit(*scan))) {\n        MB_PTR_ADV(scan);\n      } else if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else {\n        break;\n      }\n      count++;\n    }\n    break;\n\n  case FNAME:\n  case FNAME + ADD_NL:\n    testval = 1;\n    FALLTHROUGH;\n  case SFNAME:\n  case SFNAME + ADD_NL:\n    while (count < maxcount) {\n      if (vim_isfilec(PTR2CHAR(scan)) && (testval || !ascii_isdigit(*scan))) {\n        MB_PTR_ADV(scan);\n      } else if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else {\n        break;\n      }\n      count++;\n    }\n    break;\n\n  case PRINT:\n  case PRINT + ADD_NL:\n    testval = 1;\n    FALLTHROUGH;\n  case SPRINT:\n  case SPRINT + ADD_NL:\n    while (count < maxcount) {\n      if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if (vim_isprintc(PTR2CHAR(scan)) == 1\n                 && (testval || !ascii_isdigit(*scan))) {\n        MB_PTR_ADV(scan);\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else {\n        break;\n      }\n      count++;\n    }\n    break;\n\n  case WHITE:\n  case WHITE + ADD_NL:\n    testval = mask = RI_WHITE;\ndo_class:\n    while (count < maxcount) {\n      int l;\n      if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if ((l = (*mb_ptr2len)(scan)) > 1) {\n        if (testval != 0) {\n          break;\n        }\n        scan += l;\n      } else if ((class_tab[*scan] & mask) == testval) {\n        scan++;\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else {\n        break;\n      }\n      ++count;\n    }\n    break;\n\n  case NWHITE:\n  case NWHITE + ADD_NL:\n    mask = RI_WHITE;\n    goto do_class;\n  case DIGIT:\n  case DIGIT + ADD_NL:\n    testval = mask = RI_DIGIT;\n    goto do_class;\n  case NDIGIT:\n  case NDIGIT + ADD_NL:\n    mask = RI_DIGIT;\n    goto do_class;\n  case HEX:\n  case HEX + ADD_NL:\n    testval = mask = RI_HEX;\n    goto do_class;\n  case NHEX:\n  case NHEX + ADD_NL:\n    mask = RI_HEX;\n    goto do_class;\n  case OCTAL:\n  case OCTAL + ADD_NL:\n    testval = mask = RI_OCTAL;\n    goto do_class;\n  case NOCTAL:\n  case NOCTAL + ADD_NL:\n    mask = RI_OCTAL;\n    goto do_class;\n  case WORD:\n  case WORD + ADD_NL:\n    testval = mask = RI_WORD;\n    goto do_class;\n  case NWORD:\n  case NWORD + ADD_NL:\n    mask = RI_WORD;\n    goto do_class;\n  case HEAD:\n  case HEAD + ADD_NL:\n    testval = mask = RI_HEAD;\n    goto do_class;\n  case NHEAD:\n  case NHEAD + ADD_NL:\n    mask = RI_HEAD;\n    goto do_class;\n  case ALPHA:\n  case ALPHA + ADD_NL:\n    testval = mask = RI_ALPHA;\n    goto do_class;\n  case NALPHA:\n  case NALPHA + ADD_NL:\n    mask = RI_ALPHA;\n    goto do_class;\n  case LOWER:\n  case LOWER + ADD_NL:\n    testval = mask = RI_LOWER;\n    goto do_class;\n  case NLOWER:\n  case NLOWER + ADD_NL:\n    mask = RI_LOWER;\n    goto do_class;\n  case UPPER:\n  case UPPER + ADD_NL:\n    testval = mask = RI_UPPER;\n    goto do_class;\n  case NUPPER:\n  case NUPPER + ADD_NL:\n    mask = RI_UPPER;\n    goto do_class;\n\n  case EXACTLY:\n  {\n    int cu, cl;\n\n    // This doesn't do a multi-byte character, because a MULTIBYTECODE\n    // would have been used for it.  It does handle single-byte\n    // characters, such as latin1.\n    if (rex.reg_ic) {\n      cu = mb_toupper(*opnd);\n      cl = mb_tolower(*opnd);\n      while (count < maxcount && (*scan == cu || *scan == cl)) {\n        count++;\n        scan++;\n      }\n    } else {\n      cu = *opnd;\n      while (count < maxcount && *scan == cu) {\n        count++;\n        scan++;\n      }\n    }\n    break;\n  }\n\n  case MULTIBYTECODE:\n  {\n    int i, len, cf = 0;\n\n    /* Safety check (just in case 'encoding' was changed since\n     * compiling the program). */\n    if ((len = (*mb_ptr2len)(opnd)) > 1) {\n      if (rex.reg_ic) {\n        cf = utf_fold(utf_ptr2char(opnd));\n      }\n      while (count < maxcount && (*mb_ptr2len)(scan) >= len) {\n        for (i = 0; i < len; ++i) {\n          if (opnd[i] != scan[i]) {\n            break;\n          }\n        }\n        if (i < len && (!rex.reg_ic\n                        || utf_fold(utf_ptr2char(scan)) != cf)) {\n          break;\n        }\n        scan += len;\n        ++count;\n      }\n    }\n  }\n  break;\n\n  case ANYOF:\n  case ANYOF + ADD_NL:\n    testval = 1;\n    FALLTHROUGH;\n\n  case ANYBUT:\n  case ANYBUT + ADD_NL:\n    while (count < maxcount) {\n      int len;\n      if (*scan == NUL) {\n        if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n            || rex.reg_line_lbr) {\n          break;\n        }\n        reg_nextline();\n        scan = rex.input;\n        if (got_int) {\n          break;\n        }\n      } else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p))) {\n        scan++;\n      } else if ((len = utfc_ptr2len(scan)) > 1) {\n        if ((cstrchr(opnd, utf_ptr2char(scan)) == NULL) == testval) {\n          break;\n        }\n        scan += len;\n      } else {\n        if ((cstrchr(opnd, *scan) == NULL) == testval)\n          break;\n        ++scan;\n      }\n      ++count;\n    }\n    break;\n\n  case NEWL:\n    while (count < maxcount\n           && ((*scan == NUL && rex.lnum <= rex.reg_maxline && !rex.reg_line_lbr\n                && REG_MULTI) || (*scan == '\\n' && rex.reg_line_lbr))) {\n      count++;\n      if (rex.reg_line_lbr) {\n        ADVANCE_REGINPUT();\n      } else {\n        reg_nextline();\n      }\n      scan = rex.input;\n      if (got_int) {\n        break;\n      }\n    }\n    break;\n\n  default:  // Oh dear.  Called inappropriately.\n    IEMSG(_(e_re_corr));\n#ifdef REGEXP_DEBUG\n    printf(\"Called regrepeat with op code %d\\n\", OP(p));\n#endif\n    break;\n  }\n\n  rex.input = scan;\n\n  return (int)count;\n}\n\n/*\n * regnext - dig the \"next\" pointer out of a node\n * Returns NULL when calculating size, when there is no next item and when\n * there is an error.\n */\nstatic char_u *regnext(char_u *p)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int offset;\n\n  if (p == JUST_CALC_SIZE || reg_toolong)\n    return NULL;\n\n  offset = NEXT(p);\n  if (offset == 0)\n    return NULL;\n\n  if (OP(p) == BACK)\n    return p - offset;\n  else\n    return p + offset;\n}\n\n/*\n * Check the regexp program for its magic number.\n * Return true if it's wrong.\n */\nstatic int prog_magic_wrong(void)\n{\n  regprog_T   *prog;\n\n  prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;\n  if (prog->engine == &nfa_regengine) {\n    // For NFA matcher we don't check the magic\n    return false;\n  }\n\n  if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC) {\n    EMSG(_(e_re_corr));\n    return true;\n  }\n  return false;\n}\n\n/*\n * Cleanup the subexpressions, if this wasn't done yet.\n * This construction is used to clear the subexpressions only when they are\n * used (to increase speed).\n */\nstatic void cleanup_subexpr(void)\n{\n  if (rex.need_clear_subexpr) {\n    if (REG_MULTI) {\n      // Use 0xff to set lnum to -1\n      memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n      memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n    } else {\n      memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);\n      memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);\n    }\n    rex.need_clear_subexpr = false;\n  }\n}\n\nstatic void cleanup_zsubexpr(void)\n{\n  if (rex.need_clear_zsubexpr) {\n    if (REG_MULTI) {\n      /* Use 0xff to set lnum to -1 */\n      memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n      memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n    } else {\n      memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);\n      memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);\n    }\n    rex.need_clear_zsubexpr = false;\n  }\n}\n\n// Save the current subexpr to \"bp\", so that they can be restored\n// later by restore_subexpr().\nstatic void save_subexpr(regbehind_T *bp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // When \"rex.need_clear_subexpr\" is set we don't need to save the values, only\n  // remember that this flag needs to be set again when restoring.\n  bp->save_need_clear_subexpr = rex.need_clear_subexpr;\n  if (!rex.need_clear_subexpr) {\n    for (int i = 0; i < NSUBEXP; i++) {\n      if (REG_MULTI) {\n        bp->save_start[i].se_u.pos = rex.reg_startpos[i];\n        bp->save_end[i].se_u.pos = rex.reg_endpos[i];\n      } else {\n        bp->save_start[i].se_u.ptr = rex.reg_startp[i];\n        bp->save_end[i].se_u.ptr = rex.reg_endp[i];\n      }\n    }\n  }\n}\n\n// Restore the subexpr from \"bp\".\nstatic void restore_subexpr(regbehind_T *bp)\n  FUNC_ATTR_NONNULL_ALL\n{\n  // Only need to restore saved values when they are not to be cleared.\n  rex.need_clear_subexpr = bp->save_need_clear_subexpr;\n  if (!rex.need_clear_subexpr) {\n    for (int i = 0; i < NSUBEXP; i++) {\n      if (REG_MULTI) {\n        rex.reg_startpos[i] = bp->save_start[i].se_u.pos;\n        rex.reg_endpos[i] = bp->save_end[i].se_u.pos;\n      } else {\n        rex.reg_startp[i] = bp->save_start[i].se_u.ptr;\n        rex.reg_endp[i] = bp->save_end[i].se_u.ptr;\n      }\n    }\n  }\n}\n\n// Advance rex.lnum, rex.line and rex.input to the next line.\nstatic void reg_nextline(void)\n{\n  rex.line = reg_getline(++rex.lnum);\n  rex.input = rex.line;\n  fast_breakcheck();\n}\n\n// Save the input line and position in a regsave_T.\nstatic void reg_save(regsave_T *save, garray_T *gap)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (REG_MULTI) {\n    save->rs_u.pos.col = (colnr_T)(rex.input - rex.line);\n    save->rs_u.pos.lnum = rex.lnum;\n  } else {\n    save->rs_u.ptr = rex.input;\n  }\n  save->rs_len = gap->ga_len;\n}\n\n// Restore the input line and position from a regsave_T.\nstatic void reg_restore(regsave_T *save, garray_T *gap)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (REG_MULTI) {\n    if (rex.lnum != save->rs_u.pos.lnum) {\n      // only call reg_getline() when the line number changed to save\n      // a bit of time\n      rex.lnum = save->rs_u.pos.lnum;\n      rex.line = reg_getline(rex.lnum);\n    }\n    rex.input = rex.line + save->rs_u.pos.col;\n  } else {\n    rex.input = save->rs_u.ptr;\n  }\n  gap->ga_len = save->rs_len;\n}\n\n// Return true if current position is equal to saved position.\nstatic bool reg_save_equal(const regsave_T *save)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (REG_MULTI) {\n    return rex.lnum == save->rs_u.pos.lnum\n           && rex.input == rex.line + save->rs_u.pos.col;\n  }\n  return rex.input == save->rs_u.ptr;\n}\n\n/*\n * Tentatively set the sub-expression start to the current position (after\n * calling regmatch() they will have changed).  Need to save the existing\n * values for when there is no match.\n * Use se_save() to use pointer (save_se_multi()) or position (save_se_one()),\n * depending on REG_MULTI.\n */\nstatic void save_se_multi(save_se_T *savep, lpos_T *posp)\n{\n  savep->se_u.pos = *posp;\n  posp->lnum = rex.lnum;\n  posp->col = (colnr_T)(rex.input - rex.line);\n}\n\nstatic void save_se_one(save_se_T *savep, char_u **pp)\n{\n  savep->se_u.ptr = *pp;\n  *pp = rex.input;\n}\n\n/*\n * Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL.\n */\nstatic int re_num_cmp(uint32_t val, char_u *scan)\n{\n  uint32_t n = (uint32_t)OPERAND_MIN(scan);\n\n  if (OPERAND_CMP(scan) == '>')\n    return val > n;\n  if (OPERAND_CMP(scan) == '<')\n    return val < n;\n  return val == n;\n}\n\n/*\n * Check whether a backreference matches.\n * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.\n * If \"bytelen\" is not NULL, it is set to the byte length of the match in the\n * last line.\n */\nstatic int match_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen)\n{\n  linenr_T clnum = start_lnum;\n  colnr_T ccol = start_col;\n  int len;\n  char_u      *p;\n\n  if (bytelen != NULL)\n    *bytelen = 0;\n  for (;; ) {\n    /* Since getting one line may invalidate the other, need to make copy.\n     * Slow! */\n    if (rex.line != reg_tofree) {\n      len = (int)STRLEN(rex.line);\n      if (reg_tofree == NULL || len >= (int)reg_tofreelen) {\n        len += 50;              /* get some extra */\n        xfree(reg_tofree);\n        reg_tofree = xmalloc(len);\n        reg_tofreelen = len;\n      }\n      STRCPY(reg_tofree, rex.line);\n      rex.input = reg_tofree + (rex.input - rex.line);\n      rex.line = reg_tofree;\n    }\n\n    /* Get the line to compare with. */\n    p = reg_getline(clnum);\n    assert(p);\n\n    if (clnum == end_lnum)\n      len = end_col - ccol;\n    else\n      len = (int)STRLEN(p + ccol);\n\n    if (cstrncmp(p + ccol, rex.input, &len) != 0) {\n      return RA_NOMATCH;  // doesn't match\n    }\n    if (bytelen != NULL) {\n      *bytelen += len;\n    }\n    if (clnum == end_lnum) {\n      break;  // match and at end!\n    }\n    if (rex.lnum >= rex.reg_maxline) {\n      return RA_NOMATCH;  // text too short\n    }\n\n    /* Advance to next line. */\n    reg_nextline();\n    if (bytelen != NULL)\n      *bytelen = 0;\n    ++clnum;\n    ccol = 0;\n    if (got_int)\n      return RA_FAIL;\n  }\n\n  // found a match!  Note that rex.line may now point to a copy of the line,\n  // that should not matter.\n  return RA_MATCH;\n}\n\n#ifdef BT_REGEXP_DUMP\n\n/*\n * regdump - dump a regexp onto stdout in vaguely comprehensible form\n */\nstatic void regdump(char_u *pattern, bt_regprog_T *r)\n{\n  char_u  *s;\n  int op = EXACTLY;             /* Arbitrary non-END op. */\n  char_u  *next;\n  char_u  *end = NULL;\n  FILE    *f;\n\n#ifdef BT_REGEXP_LOG\n  f = fopen(\"bt_regexp_log.log\", \"a\");\n#else\n  f = stdout;\n#endif\n  if (f == NULL)\n    return;\n  fprintf(f, \"-------------------------------------\\n\\r\\nregcomp(%s):\\r\\n\",\n      pattern);\n\n  s = r->program + 1;\n  /*\n   * Loop until we find the END that isn't before a referred next (an END\n   * can also appear in a NOMATCH operand).\n   */\n  while (op != END || s <= end) {\n    op = OP(s);\n    fprintf(f, \"%2d%s\", (int)(s - r->program), regprop(s));     /* Where, what. */\n    next = regnext(s);\n    if (next == NULL)           /* Next ptr. */\n      fprintf(f, \"(0)\");\n    else\n      fprintf(f, \"(%d)\", (int)((s - r->program) + (next - s)));\n    if (end < next)\n      end = next;\n    if (op == BRACE_LIMITS) {\n      /* Two ints */\n      fprintf(f, \" minval %\" PRId64 \", maxval %\" PRId64,\n              (int64_t)OPERAND_MIN(s), (int64_t)OPERAND_MAX(s));\n      s += 8;\n    } else if (op == BEHIND || op == NOBEHIND) {\n      /* one int */\n      fprintf(f, \" count %\" PRId64, (int64_t)OPERAND_MIN(s));\n      s += 4;\n    } else if (op == RE_LNUM || op == RE_COL || op == RE_VCOL) {\n      // one int plus comparator\n      fprintf(f, \" count %\" PRId64, (int64_t)OPERAND_MIN(s));\n      s += 5;\n    }\n    s += 3;\n    if (op == ANYOF || op == ANYOF + ADD_NL\n        || op == ANYBUT || op == ANYBUT + ADD_NL\n        || op == EXACTLY) {\n      /* Literal string, where present. */\n      fprintf(f, \"\\nxxxxxxxxx\\n\");\n      while (*s != NUL)\n        fprintf(f, \"%c\", *s++);\n      fprintf(f, \"\\nxxxxxxxxx\\n\");\n      s++;\n    }\n    fprintf(f, \"\\r\\n\");\n  }\n\n  /* Header fields of interest. */\n  if (r->regstart != NUL)\n    fprintf(f, \"start `%s' 0x%x; \", r->regstart < 256\n        ? (char *)transchar(r->regstart)\n        : \"multibyte\", r->regstart);\n  if (r->reganch)\n    fprintf(f, \"anchored; \");\n  if (r->regmust != NULL)\n    fprintf(f, \"must have \\\"%s\\\"\", r->regmust);\n  fprintf(f, \"\\r\\n\");\n\n#ifdef BT_REGEXP_LOG\n  fclose(f);\n#endif\n}\n#endif      /* BT_REGEXP_DUMP */\n\n#ifdef REGEXP_DEBUG\n/*\n * regprop - printable representation of opcode\n */\nstatic char_u *regprop(char_u *op)\n{\n  char            *p;\n  static char buf[50];\n\n  STRCPY(buf, \":\");\n\n  switch ((int) OP(op)) {\n  case BOL:\n    p = \"BOL\";\n    break;\n  case EOL:\n    p = \"EOL\";\n    break;\n  case RE_BOF:\n    p = \"BOF\";\n    break;\n  case RE_EOF:\n    p = \"EOF\";\n    break;\n  case CURSOR:\n    p = \"CURSOR\";\n    break;\n  case RE_VISUAL:\n    p = \"RE_VISUAL\";\n    break;\n  case RE_LNUM:\n    p = \"RE_LNUM\";\n    break;\n  case RE_MARK:\n    p = \"RE_MARK\";\n    break;\n  case RE_COL:\n    p = \"RE_COL\";\n    break;\n  case RE_VCOL:\n    p = \"RE_VCOL\";\n    break;\n  case BOW:\n    p = \"BOW\";\n    break;\n  case EOW:\n    p = \"EOW\";\n    break;\n  case ANY:\n    p = \"ANY\";\n    break;\n  case ANY + ADD_NL:\n    p = \"ANY+NL\";\n    break;\n  case ANYOF:\n    p = \"ANYOF\";\n    break;\n  case ANYOF + ADD_NL:\n    p = \"ANYOF+NL\";\n    break;\n  case ANYBUT:\n    p = \"ANYBUT\";\n    break;\n  case ANYBUT + ADD_NL:\n    p = \"ANYBUT+NL\";\n    break;\n  case IDENT:\n    p = \"IDENT\";\n    break;\n  case IDENT + ADD_NL:\n    p = \"IDENT+NL\";\n    break;\n  case SIDENT:\n    p = \"SIDENT\";\n    break;\n  case SIDENT + ADD_NL:\n    p = \"SIDENT+NL\";\n    break;\n  case KWORD:\n    p = \"KWORD\";\n    break;\n  case KWORD + ADD_NL:\n    p = \"KWORD+NL\";\n    break;\n  case SKWORD:\n    p = \"SKWORD\";\n    break;\n  case SKWORD + ADD_NL:\n    p = \"SKWORD+NL\";\n    break;\n  case FNAME:\n    p = \"FNAME\";\n    break;\n  case FNAME + ADD_NL:\n    p = \"FNAME+NL\";\n    break;\n  case SFNAME:\n    p = \"SFNAME\";\n    break;\n  case SFNAME + ADD_NL:\n    p = \"SFNAME+NL\";\n    break;\n  case PRINT:\n    p = \"PRINT\";\n    break;\n  case PRINT + ADD_NL:\n    p = \"PRINT+NL\";\n    break;\n  case SPRINT:\n    p = \"SPRINT\";\n    break;\n  case SPRINT + ADD_NL:\n    p = \"SPRINT+NL\";\n    break;\n  case WHITE:\n    p = \"WHITE\";\n    break;\n  case WHITE + ADD_NL:\n    p = \"WHITE+NL\";\n    break;\n  case NWHITE:\n    p = \"NWHITE\";\n    break;\n  case NWHITE + ADD_NL:\n    p = \"NWHITE+NL\";\n    break;\n  case DIGIT:\n    p = \"DIGIT\";\n    break;\n  case DIGIT + ADD_NL:\n    p = \"DIGIT+NL\";\n    break;\n  case NDIGIT:\n    p = \"NDIGIT\";\n    break;\n  case NDIGIT + ADD_NL:\n    p = \"NDIGIT+NL\";\n    break;\n  case HEX:\n    p = \"HEX\";\n    break;\n  case HEX + ADD_NL:\n    p = \"HEX+NL\";\n    break;\n  case NHEX:\n    p = \"NHEX\";\n    break;\n  case NHEX + ADD_NL:\n    p = \"NHEX+NL\";\n    break;\n  case OCTAL:\n    p = \"OCTAL\";\n    break;\n  case OCTAL + ADD_NL:\n    p = \"OCTAL+NL\";\n    break;\n  case NOCTAL:\n    p = \"NOCTAL\";\n    break;\n  case NOCTAL + ADD_NL:\n    p = \"NOCTAL+NL\";\n    break;\n  case WORD:\n    p = \"WORD\";\n    break;\n  case WORD + ADD_NL:\n    p = \"WORD+NL\";\n    break;\n  case NWORD:\n    p = \"NWORD\";\n    break;\n  case NWORD + ADD_NL:\n    p = \"NWORD+NL\";\n    break;\n  case HEAD:\n    p = \"HEAD\";\n    break;\n  case HEAD + ADD_NL:\n    p = \"HEAD+NL\";\n    break;\n  case NHEAD:\n    p = \"NHEAD\";\n    break;\n  case NHEAD + ADD_NL:\n    p = \"NHEAD+NL\";\n    break;\n  case ALPHA:\n    p = \"ALPHA\";\n    break;\n  case ALPHA + ADD_NL:\n    p = \"ALPHA+NL\";\n    break;\n  case NALPHA:\n    p = \"NALPHA\";\n    break;\n  case NALPHA + ADD_NL:\n    p = \"NALPHA+NL\";\n    break;\n  case LOWER:\n    p = \"LOWER\";\n    break;\n  case LOWER + ADD_NL:\n    p = \"LOWER+NL\";\n    break;\n  case NLOWER:\n    p = \"NLOWER\";\n    break;\n  case NLOWER + ADD_NL:\n    p = \"NLOWER+NL\";\n    break;\n  case UPPER:\n    p = \"UPPER\";\n    break;\n  case UPPER + ADD_NL:\n    p = \"UPPER+NL\";\n    break;\n  case NUPPER:\n    p = \"NUPPER\";\n    break;\n  case NUPPER + ADD_NL:\n    p = \"NUPPER+NL\";\n    break;\n  case BRANCH:\n    p = \"BRANCH\";\n    break;\n  case EXACTLY:\n    p = \"EXACTLY\";\n    break;\n  case NOTHING:\n    p = \"NOTHING\";\n    break;\n  case BACK:\n    p = \"BACK\";\n    break;\n  case END:\n    p = \"END\";\n    break;\n  case MOPEN + 0:\n    p = \"MATCH START\";\n    break;\n  case MOPEN + 1:\n  case MOPEN + 2:\n  case MOPEN + 3:\n  case MOPEN + 4:\n  case MOPEN + 5:\n  case MOPEN + 6:\n  case MOPEN + 7:\n  case MOPEN + 8:\n  case MOPEN + 9:\n    sprintf(buf + STRLEN(buf), \"MOPEN%d\", OP(op) - MOPEN);\n    p = NULL;\n    break;\n  case MCLOSE + 0:\n    p = \"MATCH END\";\n    break;\n  case MCLOSE + 1:\n  case MCLOSE + 2:\n  case MCLOSE + 3:\n  case MCLOSE + 4:\n  case MCLOSE + 5:\n  case MCLOSE + 6:\n  case MCLOSE + 7:\n  case MCLOSE + 8:\n  case MCLOSE + 9:\n    sprintf(buf + STRLEN(buf), \"MCLOSE%d\", OP(op) - MCLOSE);\n    p = NULL;\n    break;\n  case BACKREF + 1:\n  case BACKREF + 2:\n  case BACKREF + 3:\n  case BACKREF + 4:\n  case BACKREF + 5:\n  case BACKREF + 6:\n  case BACKREF + 7:\n  case BACKREF + 8:\n  case BACKREF + 9:\n    sprintf(buf + STRLEN(buf), \"BACKREF%d\", OP(op) - BACKREF);\n    p = NULL;\n    break;\n  case NOPEN:\n    p = \"NOPEN\";\n    break;\n  case NCLOSE:\n    p = \"NCLOSE\";\n    break;\n  case ZOPEN + 1:\n  case ZOPEN + 2:\n  case ZOPEN + 3:\n  case ZOPEN + 4:\n  case ZOPEN + 5:\n  case ZOPEN + 6:\n  case ZOPEN + 7:\n  case ZOPEN + 8:\n  case ZOPEN + 9:\n    sprintf(buf + STRLEN(buf), \"ZOPEN%d\", OP(op) - ZOPEN);\n    p = NULL;\n    break;\n  case ZCLOSE + 1:\n  case ZCLOSE + 2:\n  case ZCLOSE + 3:\n  case ZCLOSE + 4:\n  case ZCLOSE + 5:\n  case ZCLOSE + 6:\n  case ZCLOSE + 7:\n  case ZCLOSE + 8:\n  case ZCLOSE + 9:\n    sprintf(buf + STRLEN(buf), \"ZCLOSE%d\", OP(op) - ZCLOSE);\n    p = NULL;\n    break;\n  case ZREF + 1:\n  case ZREF + 2:\n  case ZREF + 3:\n  case ZREF + 4:\n  case ZREF + 5:\n  case ZREF + 6:\n  case ZREF + 7:\n  case ZREF + 8:\n  case ZREF + 9:\n    sprintf(buf + STRLEN(buf), \"ZREF%d\", OP(op) - ZREF);\n    p = NULL;\n    break;\n  case STAR:\n    p = \"STAR\";\n    break;\n  case PLUS:\n    p = \"PLUS\";\n    break;\n  case NOMATCH:\n    p = \"NOMATCH\";\n    break;\n  case MATCH:\n    p = \"MATCH\";\n    break;\n  case BEHIND:\n    p = \"BEHIND\";\n    break;\n  case NOBEHIND:\n    p = \"NOBEHIND\";\n    break;\n  case SUBPAT:\n    p = \"SUBPAT\";\n    break;\n  case BRACE_LIMITS:\n    p = \"BRACE_LIMITS\";\n    break;\n  case BRACE_SIMPLE:\n    p = \"BRACE_SIMPLE\";\n    break;\n  case BRACE_COMPLEX + 0:\n  case BRACE_COMPLEX + 1:\n  case BRACE_COMPLEX + 2:\n  case BRACE_COMPLEX + 3:\n  case BRACE_COMPLEX + 4:\n  case BRACE_COMPLEX + 5:\n  case BRACE_COMPLEX + 6:\n  case BRACE_COMPLEX + 7:\n  case BRACE_COMPLEX + 8:\n  case BRACE_COMPLEX + 9:\n    sprintf(buf + STRLEN(buf), \"BRACE_COMPLEX%d\", OP(op) - BRACE_COMPLEX);\n    p = NULL;\n    break;\n  case MULTIBYTECODE:\n    p = \"MULTIBYTECODE\";\n    break;\n  case NEWL:\n    p = \"NEWL\";\n    break;\n  default:\n    sprintf(buf + STRLEN(buf), \"corrupt %d\", OP(op));\n    p = NULL;\n    break;\n  }\n  if (p != NULL)\n    STRCAT(buf, p);\n  return (char_u *)buf;\n}\n#endif      /* REGEXP_DEBUG */\n\n\n\n/* 0xfb20 - 0xfb4f */\nstatic decomp_T decomp_table[0xfb4f-0xfb20+1] =\n{\n  {0x5e2,0,0},                  /* 0xfb20\talt ayin */\n  {0x5d0,0,0},                  /* 0xfb21\talt alef */\n  {0x5d3,0,0},                  /* 0xfb22\talt dalet */\n  {0x5d4,0,0},                  /* 0xfb23\talt he */\n  {0x5db,0,0},                  /* 0xfb24\talt kaf */\n  {0x5dc,0,0},                  /* 0xfb25\talt lamed */\n  {0x5dd,0,0},                  /* 0xfb26\talt mem-sofit */\n  {0x5e8,0,0},                  /* 0xfb27\talt resh */\n  {0x5ea,0,0},                  /* 0xfb28\talt tav */\n  {'+', 0, 0},                  /* 0xfb29\talt plus */\n  {0x5e9, 0x5c1, 0},            /* 0xfb2a\tshin+shin-dot */\n  {0x5e9, 0x5c2, 0},            /* 0xfb2b\tshin+sin-dot */\n  {0x5e9, 0x5c1, 0x5bc},        /* 0xfb2c\tshin+shin-dot+dagesh */\n  {0x5e9, 0x5c2, 0x5bc},        /* 0xfb2d\tshin+sin-dot+dagesh */\n  {0x5d0, 0x5b7, 0},            /* 0xfb2e\talef+patah */\n  {0x5d0, 0x5b8, 0},            /* 0xfb2f\talef+qamats */\n  {0x5d0, 0x5b4, 0},            /* 0xfb30\talef+hiriq */\n  {0x5d1, 0x5bc, 0},            /* 0xfb31\tbet+dagesh */\n  {0x5d2, 0x5bc, 0},            /* 0xfb32\tgimel+dagesh */\n  {0x5d3, 0x5bc, 0},            /* 0xfb33\tdalet+dagesh */\n  {0x5d4, 0x5bc, 0},            /* 0xfb34\the+dagesh */\n  {0x5d5, 0x5bc, 0},            /* 0xfb35\tvav+dagesh */\n  {0x5d6, 0x5bc, 0},            /* 0xfb36\tzayin+dagesh */\n  {0xfb37, 0, 0},               /* 0xfb37 -- */\n  {0x5d8, 0x5bc, 0},            /* 0xfb38\ttet+dagesh */\n  {0x5d9, 0x5bc, 0},            /* 0xfb39\tyud+dagesh */\n  {0x5da, 0x5bc, 0},            /* 0xfb3a\tkaf sofit+dagesh */\n  {0x5db, 0x5bc, 0},            /* 0xfb3b\tkaf+dagesh */\n  {0x5dc, 0x5bc, 0},            /* 0xfb3c\tlamed+dagesh */\n  {0xfb3d, 0, 0},               /* 0xfb3d -- */\n  {0x5de, 0x5bc, 0},            /* 0xfb3e\tmem+dagesh */\n  {0xfb3f, 0, 0},               /* 0xfb3f -- */\n  {0x5e0, 0x5bc, 0},            /* 0xfb40\tnun+dagesh */\n  {0x5e1, 0x5bc, 0},            /* 0xfb41\tsamech+dagesh */\n  {0xfb42, 0, 0},               /* 0xfb42 -- */\n  {0x5e3, 0x5bc, 0},            /* 0xfb43\tpe sofit+dagesh */\n  {0x5e4, 0x5bc,0},             /* 0xfb44\tpe+dagesh */\n  {0xfb45, 0, 0},               /* 0xfb45 -- */\n  {0x5e6, 0x5bc, 0},            /* 0xfb46\ttsadi+dagesh */\n  {0x5e7, 0x5bc, 0},            /* 0xfb47\tqof+dagesh */\n  {0x5e8, 0x5bc, 0},            /* 0xfb48\tresh+dagesh */\n  {0x5e9, 0x5bc, 0},            /* 0xfb49\tshin+dagesh */\n  {0x5ea, 0x5bc, 0},            /* 0xfb4a\ttav+dagesh */\n  {0x5d5, 0x5b9, 0},            /* 0xfb4b\tvav+holam */\n  {0x5d1, 0x5bf, 0},            /* 0xfb4c\tbet+rafe */\n  {0x5db, 0x5bf, 0},            /* 0xfb4d\tkaf+rafe */\n  {0x5e4, 0x5bf, 0},            /* 0xfb4e\tpe+rafe */\n  {0x5d0, 0x5dc, 0}             /* 0xfb4f\talef-lamed */\n};\n\nstatic void mb_decompose(int c, int *c1, int *c2, int *c3)\n{\n  decomp_T d;\n\n  if (c >= 0xfb20 && c <= 0xfb4f) {\n    d = decomp_table[c - 0xfb20];\n    *c1 = d.a;\n    *c2 = d.b;\n    *c3 = d.c;\n  } else {\n    *c1 = c;\n    *c2 = *c3 = 0;\n  }\n}\n\n// Compare two strings, ignore case if rex.reg_ic set.\n// Return 0 if strings match, non-zero otherwise.\n// Correct the length \"*n\" when composing characters are ignored.\nstatic int cstrncmp(char_u *s1, char_u *s2, int *n)\n{\n  int result;\n\n  if (!rex.reg_ic) {\n    result = STRNCMP(s1, s2, *n);\n  } else {\n    assert(*n >= 0);\n    result = mb_strnicmp(s1, s2, (size_t)*n);\n  }\n\n  // if it failed and it's utf8 and we want to combineignore:\n  if (result != 0 && rex.reg_icombine) {\n    char_u  *str1, *str2;\n    int c1, c2, c11, c12;\n    int junk;\n\n    /* we have to handle the strcmp ourselves, since it is necessary to\n     * deal with the composing characters by ignoring them: */\n    str1 = s1;\n    str2 = s2;\n    c1 = c2 = 0;\n    while ((int)(str1 - s1) < *n) {\n      c1 = mb_ptr2char_adv((const char_u **)&str1);\n      c2 = mb_ptr2char_adv((const char_u **)&str2);\n\n      /* decompose the character if necessary, into 'base' characters\n       * because I don't care about Arabic, I will hard-code the Hebrew\n       * which I *do* care about!  So sue me... */\n      if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2))) {\n        // decomposition necessary?\n        mb_decompose(c1, &c11, &junk, &junk);\n        mb_decompose(c2, &c12, &junk, &junk);\n        c1 = c11;\n        c2 = c12;\n        if (c11 != c12 && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12))) {\n          break;\n        }\n      }\n    }\n    result = c2 - c1;\n    if (result == 0)\n      *n = (int)(str2 - s2);\n  }\n\n  return result;\n}\n\n/***************************************************************\n*\t\t      regsub stuff\t\t\t       *\n***************************************************************/\n\n/* This stuff below really confuses cc on an SGI -- webb */\n\n\n\nstatic fptr_T do_upper(int *d, int c)\n{\n  *d = mb_toupper(c);\n\n  return (fptr_T)NULL;\n}\n\nstatic fptr_T do_Upper(int *d, int c)\n{\n  *d = mb_toupper(c);\n\n  return (fptr_T)do_Upper;\n}\n\nstatic fptr_T do_lower(int *d, int c)\n{\n  *d = mb_tolower(c);\n\n  return (fptr_T)NULL;\n}\n\nstatic fptr_T do_Lower(int *d, int c)\n{\n  *d = mb_tolower(c);\n\n  return (fptr_T)do_Lower;\n}\n\n/*\n * regtilde(): Replace tildes in the pattern by the old pattern.\n *\n * Short explanation of the tilde: It stands for the previous replacement\n * pattern.  If that previous pattern also contains a ~ we should go back a\n * step further...  But we insert the previous pattern into the current one\n * and remember that.\n * This still does not handle the case where \"magic\" changes.  So require the\n * user to keep his hands off of \"magic\".\n *\n * The tildes are parsed once before the first call to vim_regsub().\n */\nchar_u *regtilde(char_u *source, int magic)\n{\n  char_u      *newsub = source;\n  char_u      *tmpsub;\n  char_u      *p;\n  int len;\n  int prevlen;\n\n  for (p = newsub; *p; ++p) {\n    if ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic)) {\n      if (reg_prev_sub != NULL) {\n        /* length = len(newsub) - 1 + len(prev_sub) + 1 */\n        prevlen = (int)STRLEN(reg_prev_sub);\n        tmpsub = xmalloc(STRLEN(newsub) + prevlen);\n        /* copy prefix */\n        len = (int)(p - newsub);              /* not including ~ */\n        memmove(tmpsub, newsub, (size_t)len);\n        /* interpret tilde */\n        memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);\n        /* copy postfix */\n        if (!magic)\n          ++p;                                /* back off \\ */\n        STRCPY(tmpsub + len + prevlen, p + 1);\n\n        if (newsub != source)                 /* already allocated newsub */\n          xfree(newsub);\n        newsub = tmpsub;\n        p = newsub + len + prevlen;\n      } else if (magic)\n        STRMOVE(p, p + 1);              /* remove '~' */\n      else\n        STRMOVE(p, p + 2);              /* remove '\\~' */\n      --p;\n    } else {\n      if (*p == '\\\\' && p[1]) {         // skip escaped characters\n        p++;\n      }\n      p += (*mb_ptr2len)(p) - 1;\n    }\n  }\n\n  xfree(reg_prev_sub);\n  if (newsub != source)         /* newsub was allocated, just keep it */\n    reg_prev_sub = newsub;\n  else                          /* no ~ found, need to save newsub  */\n    reg_prev_sub = vim_strsave(newsub);\n  return newsub;\n}\n\nstatic bool can_f_submatch = false;  // true when submatch() can be used\n\n// These pointers are used for reg_submatch().  Needed for when the\n// substitution string is an expression that contains a call to substitute()\n// and submatch().\ntypedef struct {\n  regmatch_T *sm_match;\n  regmmatch_T *sm_mmatch;\n  linenr_T sm_firstlnum;\n  linenr_T sm_maxline;\n  int sm_line_lbr;\n} regsubmatch_T;\n\nstatic regsubmatch_T rsm;  // can only be used when can_f_submatch is true\n\n/// Put the submatches in \"argv[argskip]\" which is a list passed into\n/// call_func() by vim_regsub_both().\nstatic int fill_submatch_list(int argc FUNC_ATTR_UNUSED, typval_T *argv,\n                              int argskip, int argcount)\n  FUNC_ATTR_NONNULL_ALL\n{\n  typval_T *listarg = argv + argskip;\n\n  if (argcount == argskip) {\n    // called function doesn't take a submatches argument\n    return argskip;\n  }\n\n  // Relies on sl_list to be the first item in staticList10_T.\n  tv_list_init_static10((staticList10_T *)listarg->vval.v_list);\n\n  // There are always 10 list items in staticList10_T.\n  listitem_T *li = tv_list_first(listarg->vval.v_list);\n  for (int i = 0; i < 10; i++) {\n    char_u *s = rsm.sm_match->startp[i];\n    if (s == NULL || rsm.sm_match->endp[i] == NULL) {\n      s = NULL;\n    } else {\n      s = vim_strnsave(s, rsm.sm_match->endp[i] - s);\n    }\n    TV_LIST_ITEM_TV(li)->v_type = VAR_STRING;\n    TV_LIST_ITEM_TV(li)->vval.v_string = s;\n    li = TV_LIST_ITEM_NEXT(argv->vval.v_list, li);\n  }\n  return argskip + 1;\n}\n\nstatic void clear_submatch_list(staticList10_T *sl)\n{\n  TV_LIST_ITER(&sl->sl_list, li, {\n    xfree(TV_LIST_ITEM_TV(li)->vval.v_string);\n  });\n}\n\n/// vim_regsub() - perform substitutions after a vim_regexec() or\n/// vim_regexec_multi() match.\n///\n/// If \"copy\" is true really copy into \"dest\".\n/// If \"copy\" is false nothing is copied, this is just to find out the length\n/// of the result.\n///\n/// If \"backslash\" is true, a backslash will be removed later, need to double\n/// them to keep them, and insert a backslash before a CR to avoid it being\n/// replaced with a line break later.\n///\n/// Note: The matched text must not change between the call of\n/// vim_regexec()/vim_regexec_multi() and vim_regsub()!  It would make the back\n/// references invalid!\n///\n/// Returns the size of the replacement, including terminating NUL.\nint vim_regsub(regmatch_T *rmp, char_u *source, typval_T *expr, char_u *dest,\n               int copy, int magic, int backslash)\n{\n  regexec_T rex_save;\n  bool rex_in_use_save = rex_in_use;\n\n  if (rex_in_use) {\n    // Being called recursively, save the state.\n    rex_save = rex;\n  }\n  rex_in_use = true;\n\n  rex.reg_match = rmp;\n  rex.reg_mmatch = NULL;\n  rex.reg_maxline = 0;\n  rex.reg_buf = curbuf;\n  rex.reg_line_lbr = true;\n  int result = vim_regsub_both(source, expr, dest, copy, magic, backslash);\n\n  rex_in_use = rex_in_use_save;\n  if (rex_in_use) {\n    rex = rex_save;\n  }\n\n  return result;\n}\n\nint vim_regsub_multi(regmmatch_T *rmp, linenr_T lnum, char_u *source, char_u *dest, int copy, int magic, int backslash)\n{\n  regexec_T rex_save;\n  bool rex_in_use_save = rex_in_use;\n\n  if (rex_in_use) {\n    // Being called recursively, save the state.\n    rex_save = rex;\n  }\n  rex_in_use = true;\n\n  rex.reg_match = NULL;\n  rex.reg_mmatch = rmp;\n  rex.reg_buf = curbuf;  // always works on the current buffer!\n  rex.reg_firstlnum = lnum;\n  rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;\n  rex.reg_line_lbr = false;\n  int result = vim_regsub_both(source, NULL, dest, copy, magic, backslash);\n\n  rex_in_use = rex_in_use_save;\n  if (rex_in_use) {\n    rex = rex_save;\n  }\n\n  return result;\n}\n\nstatic int vim_regsub_both(char_u *source, typval_T *expr, char_u *dest,\n                           int copy, int magic, int backslash)\n{\n  char_u      *src;\n  char_u      *dst;\n  char_u      *s;\n  int c;\n  int cc;\n  int no = -1;\n  fptr_T func_all = (fptr_T)NULL;\n  fptr_T func_one = (fptr_T)NULL;\n  linenr_T clnum = 0;           /* init for GCC */\n  int len = 0;                  /* init for GCC */\n  static char_u *eval_result = NULL;\n\n  // We need to keep track of how many backslashes we escape, so that the byte\n  // counts for `extmark_splice` are correct.\n  int num_escaped = 0;\n\n  // Be paranoid...\n  if ((source == NULL && expr == NULL) || dest == NULL) {\n    EMSG(_(e_null));\n    return 0;\n  }\n  if (prog_magic_wrong())\n    return 0;\n  src = source;\n  dst = dest;\n\n  // When the substitute part starts with \"\\=\" evaluate it as an expression.\n  if (expr != NULL || (source[0] == '\\\\' && source[1] == '=')) {\n    // To make sure that the length doesn't change between checking the\n    // length and copying the string, and to speed up things, the\n    // resulting string is saved from the call with \"copy\" == false to the\n    // call with \"copy\" == true.\n    if (copy) {\n      if (eval_result != NULL) {\n        STRCPY(dest, eval_result);\n        dst += STRLEN(eval_result);\n        XFREE_CLEAR(eval_result);\n      }\n    } else {\n      const bool prev_can_f_submatch = can_f_submatch;\n      regsubmatch_T rsm_save;\n\n      xfree(eval_result);\n\n      // The expression may contain substitute(), which calls us\n      // recursively.  Make sure submatch() gets the text from the first\n      // level.\n      if (can_f_submatch) {\n        rsm_save = rsm;\n      }\n      can_f_submatch = true;\n      rsm.sm_match = rex.reg_match;\n      rsm.sm_mmatch = rex.reg_mmatch;\n      rsm.sm_firstlnum = rex.reg_firstlnum;\n      rsm.sm_maxline = rex.reg_maxline;\n      rsm.sm_line_lbr = rex.reg_line_lbr;\n\n      if (expr != NULL) {\n        typval_T argv[2];\n        typval_T rettv;\n        staticList10_T matchList = TV_LIST_STATIC10_INIT;\n        rettv.v_type = VAR_STRING;\n        rettv.vval.v_string = NULL;\n        argv[0].v_type = VAR_LIST;\n        argv[0].vval.v_list = &matchList.sl_list;\n        funcexe_T funcexe = FUNCEXE_INIT;\n        funcexe.argv_func = fill_submatch_list;\n        funcexe.evaluate = true;\n        if (expr->v_type == VAR_FUNC) {\n          s = expr->vval.v_string;\n          call_func(s, -1, &rettv, 1, argv, &funcexe);\n        } else if (expr->v_type == VAR_PARTIAL) {\n          partial_T *partial = expr->vval.v_partial;\n\n          s = partial_name(partial);\n          funcexe.partial = partial;\n          call_func(s, -1, &rettv, 1, argv, &funcexe);\n        }\n        if (tv_list_len(&matchList.sl_list) > 0) {\n          // fill_submatch_list() was called.\n          clear_submatch_list(&matchList);\n        }\n        if (rettv.v_type == VAR_UNKNOWN) {\n          // something failed, no need to report another error\n          eval_result = NULL;\n        } else {\n          char buf[NUMBUFLEN];\n          eval_result = (char_u *)tv_get_string_buf_chk(&rettv, buf);\n          if (eval_result != NULL) {\n            eval_result = vim_strsave(eval_result);\n          }\n        }\n        tv_clear(&rettv);\n      } else {\n        eval_result = eval_to_string(source + 2, NULL, true);\n      }\n\n      if (eval_result != NULL) {\n        int had_backslash = false;\n\n        for (s = eval_result; *s != NUL; MB_PTR_ADV(s)) {\n          // Change NL to CR, so that it becomes a line break,\n          // unless called from vim_regexec_nl().\n          // Skip over a backslashed character.\n          if (*s == NL && !rsm.sm_line_lbr) {\n            *s = CAR;\n          } else if (*s == '\\\\' && s[1] != NUL) {\n            s++;\n            /* Change NL to CR here too, so that this works:\n             * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:\n             *   abc\\\n             *   def\n             * Not when called from vim_regexec_nl().\n             */\n            if (*s == NL && !rsm.sm_line_lbr) {\n              *s = CAR;\n            }\n            had_backslash = true;\n          }\n        }\n        if (had_backslash && backslash) {\n          /* Backslashes will be consumed, need to double them. */\n          s = vim_strsave_escaped(eval_result, (char_u *)\"\\\\\");\n          xfree(eval_result);\n          eval_result = s;\n        }\n\n        dst += STRLEN(eval_result);\n      }\n\n      can_f_submatch = prev_can_f_submatch;\n      if (can_f_submatch) {\n        rsm = rsm_save;\n      }\n    }\n  } else\n    while ((c = *src++) != NUL) {\n      if (c == '&' && magic)\n        no = 0;\n      else if (c == '\\\\' && *src != NUL) {\n        if (*src == '&' && !magic) {\n          ++src;\n          no = 0;\n        } else if ('0' <= *src && *src <= '9') {\n          no = *src++ - '0';\n        } else if (vim_strchr((char_u *)\"uUlLeE\", *src)) {\n          switch (*src++) {\n          case 'u':   func_one = (fptr_T)do_upper;\n            continue;\n          case 'U':   func_all = (fptr_T)do_Upper;\n            continue;\n          case 'l':   func_one = (fptr_T)do_lower;\n            continue;\n          case 'L':   func_all = (fptr_T)do_Lower;\n            continue;\n          case 'e':\n          case 'E':   func_one = func_all = (fptr_T)NULL;\n            continue;\n          }\n        }\n      }\n      if (no < 0) {           /* Ordinary character. */\n        if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL) {\n          /* Copy a special key as-is. */\n          if (copy) {\n            *dst++ = c;\n            *dst++ = *src++;\n            *dst++ = *src++;\n          } else {\n            dst += 3;\n            src += 2;\n          }\n          continue;\n        }\n\n        if (c == '\\\\' && *src != NUL) {\n          // Check for abbreviations -- webb\n          switch (*src) {\n          case 'r':   c = CAR;        ++src;  break;\n          case 'n':   c = NL;         ++src;  break;\n          case 't':   c = TAB;        ++src;  break;\n          // Oh no!  \\e already has meaning in subst pat :-(\n          // case 'e':   c = ESC;        ++src;  break;\n          case 'b':   c = Ctrl_H;     ++src;  break;\n\n          // If \"backslash\" is true the backslash will be removed\n          // later.  Used to insert a literal CR.\n          default:\n            if (backslash) {\n              num_escaped += 1;\n              if (copy) {\n                *dst = '\\\\';\n              }\n              dst++;\n            }\n            c = *src++;\n          }\n        } else {\n          c = utf_ptr2char(src - 1);\n        }\n        // Write to buffer, if copy is set.\n        if (func_one != NULL) {\n          func_one = (fptr_T)(func_one(&cc, c));\n        } else if (func_all != NULL) {\n          func_all = (fptr_T)(func_all(&cc, c));\n        } else {\n          // just copy\n          cc = c;\n        }\n\n        int totlen = utfc_ptr2len(src - 1);\n\n        if (copy) {\n          utf_char2bytes(cc, dst);\n        }\n        dst += utf_char2len(cc) - 1;\n        int clen = utf_ptr2len(src - 1);\n\n        // If the character length is shorter than \"totlen\", there\n        // are composing characters; copy them as-is.\n        if (clen < totlen) {\n          if (copy) {\n            memmove(dst + 1, src - 1 + clen, (size_t)(totlen - clen));\n          }\n          dst += totlen - clen;\n        }\n        src += totlen - 1;\n        dst++;\n      } else {\n        if (REG_MULTI) {\n          clnum = rex.reg_mmatch->startpos[no].lnum;\n          if (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0) {\n            s = NULL;\n          } else {\n            s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;\n            if (rex.reg_mmatch->endpos[no].lnum == clnum) {\n              len = rex.reg_mmatch->endpos[no].col\n                    - rex.reg_mmatch->startpos[no].col;\n            } else {\n              len = (int)STRLEN(s);\n            }\n          }\n        } else {\n          s = rex.reg_match->startp[no];\n          if (rex.reg_match->endp[no] == NULL) {\n            s = NULL;\n          } else {\n            len = (int)(rex.reg_match->endp[no] - s);\n          }\n        }\n        if (s != NULL) {\n          for (;; ) {\n            if (len == 0) {\n              if (REG_MULTI) {\n                if (rex.reg_mmatch->endpos[no].lnum == clnum) {\n                  break;\n                }\n                if (copy) {\n                  *dst = CAR;\n                }\n                dst++;\n                s = reg_getline(++clnum);\n                if (rex.reg_mmatch->endpos[no].lnum == clnum) {\n                  len = rex.reg_mmatch->endpos[no].col;\n                } else {\n                  len = (int)STRLEN(s);\n                }\n              } else {\n                break;\n              }\n            } else if (*s == NUL) {  // we hit NUL.\n              if (copy) {\n                IEMSG(_(e_re_damg));\n              }\n              goto exit;\n            } else {\n              if (backslash && (*s == CAR || *s == '\\\\')) {\n                /*\n                 * Insert a backslash in front of a CR, otherwise\n                 * it will be replaced by a line break.\n                 * Number of backslashes will be halved later,\n                 * double them here.\n                 */\n                if (copy) {\n                  dst[0] = '\\\\';\n                  dst[1] = *s;\n                }\n                dst += 2;\n              } else {\n                c = utf_ptr2char(s);\n\n                if (func_one != (fptr_T)NULL)\n                  /* Turbo C complains without the typecast */\n                  func_one = (fptr_T)(func_one(&cc, c));\n                else if (func_all != (fptr_T)NULL)\n                  /* Turbo C complains without the typecast */\n                  func_all = (fptr_T)(func_all(&cc, c));\n                else             /* just copy */\n                  cc = c;\n\n                {\n                  int l;\n\n                  // Copy composing characters separately, one\n                  // at a time.\n                  l = utf_ptr2len(s) - 1;\n\n                  s += l;\n                  len -= l;\n                  if (copy) {\n                    utf_char2bytes(cc, dst);\n                  }\n                  dst += utf_char2len(cc) - 1;\n                }\n                dst++;\n              }\n\n              ++s;\n              --len;\n            }\n          }\n        }\n        no = -1;\n      }\n    }\n  if (copy)\n    *dst = NUL;\n\nexit:\n  return (int)((dst - dest) + 1 - num_escaped);\n}\n\n\n/*\n * Call reg_getline() with the line numbers from the submatch.  If a\n * substitute() was used the reg_maxline and other values have been\n * overwritten.\n */\nstatic char_u *reg_getline_submatch(linenr_T lnum)\n{\n  char_u *s;\n  linenr_T save_first = rex.reg_firstlnum;\n  linenr_T save_max = rex.reg_maxline;\n\n  rex.reg_firstlnum = rsm.sm_firstlnum;\n  rex.reg_maxline = rsm.sm_maxline;\n\n  s = reg_getline(lnum);\n\n  rex.reg_firstlnum = save_first;\n  rex.reg_maxline = save_max;\n  return s;\n}\n\n/*\n * Used for the submatch() function: get the string from the n'th submatch in\n * allocated memory.\n * Returns NULL when not in a \":s\" command and for a non-existing submatch.\n */\nchar_u *reg_submatch(int no)\n{\n  char_u      *retval = NULL;\n  char_u      *s;\n  int round;\n  linenr_T lnum;\n\n  if (!can_f_submatch || no < 0)\n    return NULL;\n\n  if (rsm.sm_match == NULL) {\n    ssize_t len;\n\n    /*\n     * First round: compute the length and allocate memory.\n     * Second round: copy the text.\n     */\n    for (round = 1; round <= 2; round++) {\n      lnum = rsm.sm_mmatch->startpos[no].lnum;\n      if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0) {\n        return NULL;\n      }\n\n      s = reg_getline_submatch(lnum);\n      if (s == NULL) {  // anti-crash check, cannot happen?\n        break;\n      }\n      s += rsm.sm_mmatch->startpos[no].col;\n      if (rsm.sm_mmatch->endpos[no].lnum == lnum) {\n        // Within one line: take form start to end col.\n        len = rsm.sm_mmatch->endpos[no].col - rsm.sm_mmatch->startpos[no].col;\n        if (round == 2) {\n          STRLCPY(retval, s, len + 1);\n        }\n        len++;\n      } else {\n        // Multiple lines: take start line from start col, middle\n        // lines completely and end line up to end col.\n        len = (ssize_t)STRLEN(s);\n        if (round == 2) {\n          STRCPY(retval, s);\n          retval[len] = '\\n';\n        }\n        len++;\n        lnum++;\n        while (lnum < rsm.sm_mmatch->endpos[no].lnum) {\n          s = reg_getline_submatch(lnum++);\n          if (round == 2)\n            STRCPY(retval + len, s);\n          len += STRLEN(s);\n          if (round == 2)\n            retval[len] = '\\n';\n          ++len;\n        }\n        if (round == 2) {\n          STRNCPY(retval + len, reg_getline_submatch(lnum),\n                  rsm.sm_mmatch->endpos[no].col);\n        }\n        len += rsm.sm_mmatch->endpos[no].col;\n        if (round == 2) {\n          retval[len] = NUL;  // -V595\n        }\n        len++;\n      }\n\n      if (retval == NULL) {\n        retval = xmalloc(len);\n      }\n    }\n  } else {\n    s = rsm.sm_match->startp[no];\n    if (s == NULL || rsm.sm_match->endp[no] == NULL) {\n      retval = NULL;\n    } else {\n      retval = vim_strnsave(s, rsm.sm_match->endp[no] - s);\n    }\n  }\n\n  return retval;\n}\n\n// Used for the submatch() function with the optional non-zero argument: get\n// the list of strings from the n'th submatch in allocated memory with NULs\n// represented in NLs.\n// Returns a list of allocated strings.  Returns NULL when not in a \":s\"\n// command, for a non-existing submatch and for any error.\nlist_T *reg_submatch_list(int no)\n{\n  if (!can_f_submatch || no < 0) {\n    return NULL;\n  }\n\n  linenr_T slnum;\n  linenr_T elnum;\n  list_T *list;\n  const char *s;\n\n  if (rsm.sm_match == NULL) {\n    slnum = rsm.sm_mmatch->startpos[no].lnum;\n    elnum = rsm.sm_mmatch->endpos[no].lnum;\n    if (slnum < 0 || elnum < 0) {\n      return NULL;\n    }\n\n    colnr_T scol = rsm.sm_mmatch->startpos[no].col;\n    colnr_T ecol = rsm.sm_mmatch->endpos[no].col;\n\n    list = tv_list_alloc(elnum - slnum + 1);\n\n    s = (const char *)reg_getline_submatch(slnum) + scol;\n    if (slnum == elnum) {\n      tv_list_append_string(list, s, ecol - scol);\n    } else {\n      tv_list_append_string(list, s, -1);\n      for (int i = 1; i < elnum - slnum; i++) {\n        s = (const char *)reg_getline_submatch(slnum + i);\n        tv_list_append_string(list, s, -1);\n      }\n      s = (const char *)reg_getline_submatch(elnum);\n      tv_list_append_string(list, s, ecol);\n    }\n  } else {\n    s = (const char *)rsm.sm_match->startp[no];\n    if (s == NULL || rsm.sm_match->endp[no] == NULL) {\n      return NULL;\n    }\n    list = tv_list_alloc(1);\n    tv_list_append_string(list, s, (const char *)rsm.sm_match->endp[no] - s);\n  }\n\n  tv_list_ref(list);\n  return list;\n}\n\nstatic regengine_T bt_regengine =\n{\n  bt_regcomp,\n  bt_regfree,\n  bt_regexec_nl,\n  bt_regexec_multi,\n  (char_u *)\"\"\n};\n\n\n// XXX Do not allow headers generator to catch definitions from regexp_nfa.c\n#ifndef DO_NOT_DEFINE_EMPTY_ATTRIBUTES\n# include \"nvim/regexp_nfa.c\"\n#endif\n\nstatic regengine_T nfa_regengine =\n{\n  nfa_regcomp,\n  nfa_regfree,\n  nfa_regexec_nl,\n  nfa_regexec_multi,\n  (char_u *)\"\"\n};\n\n/* Which regexp engine to use? Needed for vim_regcomp().\n * Must match with 'regexpengine'. */\nstatic int regexp_engine = 0;\n\n#ifdef REGEXP_DEBUG\nstatic char_u regname[][30] = {\n  \"AUTOMATIC Regexp Engine\",\n  \"BACKTRACKING Regexp Engine\",\n  \"NFA Regexp Engine\"\n};\n#endif\n\n/*\n * Compile a regular expression into internal code.\n * Returns the program in allocated memory.\n * Use vim_regfree() to free the memory.\n * Returns NULL for an error.\n */\nregprog_T *vim_regcomp(char_u *expr_arg, int re_flags)\n{\n  regprog_T   *prog = NULL;\n  char_u      *expr = expr_arg;\n  int          save_called_emsg;\n\n  regexp_engine = p_re;\n\n  /* Check for prefix \"\\%#=\", that sets the regexp engine */\n  if (STRNCMP(expr, \"\\\\%#=\", 4) == 0) {\n    int newengine = expr[4] - '0';\n\n    if (newengine == AUTOMATIC_ENGINE\n        || newengine == BACKTRACKING_ENGINE\n        || newengine == NFA_ENGINE) {\n      regexp_engine = expr[4] - '0';\n      expr += 5;\n#ifdef REGEXP_DEBUG\n      smsg(\"New regexp mode selected (%d): %s\",\n           regexp_engine,\n           regname[newengine]);\n#endif\n    } else {\n      EMSG(_(\n              \"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used \"));\n      regexp_engine = AUTOMATIC_ENGINE;\n    }\n  }\n#ifdef REGEXP_DEBUG\n  bt_regengine.expr = expr;\n  nfa_regengine.expr = expr;\n#endif\n  // reg_iswordc() uses rex.reg_buf\n  rex.reg_buf = curbuf;\n\n  //\n  // First try the NFA engine, unless backtracking was requested.\n  //\n  save_called_emsg = called_emsg;\n  called_emsg = false;\n  if (regexp_engine != BACKTRACKING_ENGINE) {\n    prog = nfa_regengine.regcomp(expr,\n        re_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n  } else {\n    prog = bt_regengine.regcomp(expr, re_flags);\n  }\n\n  // Check for error compiling regexp with initial engine.\n  if (prog == NULL) {\n#ifdef BT_REGEXP_DEBUG_LOG\n    // Debugging log for BT engine.\n    if (regexp_engine != BACKTRACKING_ENGINE) {\n      FILE *f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \"a\");\n      if (f) {\n        fprintf(f, \"Syntax error in \\\"%s\\\"\\n\", expr);\n        fclose(f);\n      } else\n        EMSG2(\"(NFA) Could not open \\\"%s\\\" to write !!!\",\n            BT_REGEXP_DEBUG_LOG_NAME);\n    }\n#endif\n    // If the NFA engine failed, try the backtracking engine. The NFA engine\n    // also fails for patterns that it can't handle well but are still valid\n    // patterns, thus a retry should work.\n    // But don't try if an error message was given.\n    if (regexp_engine == AUTOMATIC_ENGINE && !called_emsg) {\n      regexp_engine = BACKTRACKING_ENGINE;\n      report_re_switch(expr);\n      prog = bt_regengine.regcomp(expr, re_flags);\n    }\n  }\n  called_emsg |= save_called_emsg;\n\n  if (prog != NULL) {\n    // Store the info needed to call regcomp() again when the engine turns out\n    // to be very slow when executing it.\n    prog->re_engine = regexp_engine;\n    prog->re_flags = re_flags;\n  }\n\n  return prog;\n}\n\n/*\n * Free a compiled regexp program, returned by vim_regcomp().\n */\nvoid vim_regfree(regprog_T *prog)\n{\n  if (prog != NULL)\n    prog->engine->regfree(prog);\n}\n\nstatic void report_re_switch(char_u *pat)\n{\n  if (p_verbose > 0) {\n    verbose_enter();\n    MSG_PUTS(_(\"Switching to backtracking RE engine for pattern: \"));\n    MSG_PUTS(pat);\n    verbose_leave();\n  }\n}\n\n/// Matches a regexp against a string.\n/// \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n/// Note: \"rmp->regprog\" may be freed and changed.\n/// Uses curbuf for line count and 'iskeyword'.\n/// When \"nl\" is true consider a \"\\n\" in \"line\" to be a line break.\n///\n/// @param rmp\n/// @param line the string to match against\n/// @param col  the column to start looking for match\n/// @param nl\n///\n/// @return true if there is a match, false if not.\nstatic bool vim_regexec_string(regmatch_T *rmp, char_u *line, colnr_T col,\n                               bool nl)\n{\n  regexec_T rex_save;\n  bool rex_in_use_save = rex_in_use;\n\n  // Cannot use the same prog recursively, it contains state.\n  if (rmp->regprog->re_in_use) {\n    EMSG(_(e_recursive));\n    return false;\n  }\n  rmp->regprog->re_in_use = true;\n\n  if (rex_in_use) {\n    // Being called recursively, save the state.\n    rex_save = rex;\n  }\n  rex_in_use = true;\n\n  rex.reg_startp = NULL;\n  rex.reg_endp = NULL;\n  rex.reg_startpos = NULL;\n  rex.reg_endpos = NULL;\n\n  int result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n  rmp->regprog->re_in_use = false;\n\n  // NFA engine aborted because it's very slow, use backtracking engine instead.\n  if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n      && result == NFA_TOO_EXPENSIVE) {\n    int save_p_re = p_re;\n    int re_flags = rmp->regprog->re_flags;\n    char_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n    p_re = BACKTRACKING_ENGINE;\n    vim_regfree(rmp->regprog);\n    report_re_switch(pat);\n    rmp->regprog = vim_regcomp(pat, re_flags);\n    if (rmp->regprog != NULL) {\n      rmp->regprog->re_in_use = true;\n      result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n      rmp->regprog->re_in_use = false;\n    }\n\n    xfree(pat);\n    p_re = save_p_re;\n  }\n\n  rex_in_use = rex_in_use_save;\n  if (rex_in_use) {\n    rex = rex_save;\n  }\n\n  return result > 0;\n}\n\n// Note: \"*prog\" may be freed and changed.\n// Return true if there is a match, false if not.\nbool vim_regexec_prog(regprog_T **prog, bool ignore_case, char_u *line,\n                      colnr_T col)\n{\n  regmatch_T regmatch = { .regprog = *prog, .rm_ic = ignore_case };\n  bool r = vim_regexec_string(&regmatch, line, col, false);\n  *prog = regmatch.regprog;\n  return r;\n}\n\n// Note: \"rmp->regprog\" may be freed and changed.\n// Return true if there is a match, false if not.\nbool vim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n  return vim_regexec_string(rmp, line, col, false);\n}\n\n// Like vim_regexec(), but consider a \"\\n\" in \"line\" to be a line break.\n// Note: \"rmp->regprog\" may be freed and changed.\n// Return true if there is a match, false if not.\nbool vim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n  return vim_regexec_string(rmp, line, col, true);\n}\n\n/// Match a regexp against multiple lines.\n/// \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n/// Note: \"rmp->regprog\" may be freed and changed, even set to NULL.\n/// Uses curbuf for line count and 'iskeyword'.\n///\n/// Return zero if there is no match.  Return number of lines contained in the\n/// match otherwise.\nlong vim_regexec_multi(\n    regmmatch_T *rmp,\n    win_T       *win,               // window in which to search or NULL\n    buf_T       *buf,               // buffer in which to search\n    linenr_T lnum,                  // nr of line to start looking for match\n    colnr_T col,                    // column to start looking for match\n    proftime_T  *tm,                // timeout limit or NULL\n    int         *timed_out          // flag is set when timeout limit reached\n)\n  FUNC_ATTR_NONNULL_ARG(1)\n{\n  regexec_T rex_save;\n  bool rex_in_use_save = rex_in_use;\n\n  // Cannot use the same prog recursively, it contains state.\n  if (rmp->regprog->re_in_use) {\n    EMSG(_(e_recursive));\n    return false;\n  }\n  rmp->regprog->re_in_use = true;\n\n  if (rex_in_use) {\n    // Being called recursively, save the state.\n    rex_save = rex;\n  }\n  rex_in_use = true;\n\n  int result = rmp->regprog->engine->regexec_multi(rmp, win, buf, lnum, col,\n                                                   tm, timed_out);\n  rmp->regprog->re_in_use = false;\n\n  // NFA engine aborted because it's very slow, use backtracking engine instead.\n  if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n      && result == NFA_TOO_EXPENSIVE) {\n    int save_p_re = p_re;\n    int re_flags = rmp->regprog->re_flags;\n    char_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n    p_re = BACKTRACKING_ENGINE;\n    vim_regfree(rmp->regprog);\n    report_re_switch(pat);\n    // checking for \\z misuse was already done when compiling for NFA,\n    // allow all here\n    reg_do_extmatch = REX_ALL;\n    rmp->regprog = vim_regcomp(pat, re_flags);\n    reg_do_extmatch = 0;\n\n    if (rmp->regprog != NULL) {\n      rmp->regprog->re_in_use = true;\n      result = rmp->regprog->engine->regexec_multi(rmp, win, buf, lnum, col,\n                                                   tm, timed_out);\n      rmp->regprog->re_in_use = false;\n    }\n\n    xfree(pat);\n    p_re = save_p_re;\n  }\n\n  rex_in_use = rex_in_use_save;\n  if (rex_in_use) {\n    rex = rex_save;\n  }\n\n  return result <= 0 ? 0 : result;\n}\n"}, "1": {"id": 1, "path": "src/nvim/regexp_nfa.c", "content": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/*\n * NFA regular expression implementation.\n *\n * This file is included in \"regexp.c\".\n */\n\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#include \"nvim/ascii.h\"\n#include \"nvim/garray.h\"\n\n/*\n * Logging of NFA engine.\n *\n * The NFA engine can write four log files:\n * - Error log: Contains NFA engine's fatal errors.\n * - Dump log: Contains compiled NFA state machine's information.\n * - Run log: Contains information of matching procedure.\n * - Debug log: Contains detailed information of matching procedure. Can be\n *   disabled by undefining NFA_REGEXP_DEBUG_LOG.\n * The first one can also be used without debug mode.\n * The last three are enabled when compiled as debug mode and individually\n * disabled by commenting them out.\n * The log files can get quite big!\n * Do disable all of this when compiling Vim for debugging, undefine REGEXP_DEBUG in\n * regexp.c\n */\n#ifdef REGEXP_DEBUG\n# define NFA_REGEXP_ERROR_LOG   \"nfa_regexp_error.log\"\n# define NFA_REGEXP_DUMP_LOG    \"nfa_regexp_dump.log\"\n# define NFA_REGEXP_RUN_LOG     \"nfa_regexp_run.log\"\n# define NFA_REGEXP_DEBUG_LOG   \"nfa_regexp_debug.log\"\n#endif\n\n/* Added to NFA_ANY - NFA_NUPPER_IC to include a NL. */\n#define NFA_ADD_NL              31\n\nenum {\n  NFA_SPLIT = -1024,\n  NFA_MATCH,\n  NFA_EMPTY,                        /* matches 0-length */\n\n  NFA_START_COLL,                   /* [abc] start */\n  NFA_END_COLL,                     /* [abc] end */\n  NFA_START_NEG_COLL,               /* [^abc] start */\n  NFA_END_NEG_COLL,                 /* [^abc] end (postfix only) */\n  NFA_RANGE,                        /* range of the two previous items\n                                     * (postfix only) */\n  NFA_RANGE_MIN,                    /* low end of a range  */\n  NFA_RANGE_MAX,                    /* high end of a range  */\n\n  NFA_CONCAT,                       // concatenate two previous items (postfix\n                                    // only)\n  NFA_OR,                           // \\| (postfix only)\n  NFA_STAR,                         // greedy * (postfix only)\n  NFA_STAR_NONGREEDY,               // non-greedy * (postfix only)\n  NFA_QUEST,                        // greedy \\? (postfix only)\n  NFA_QUEST_NONGREEDY,              // non-greedy \\? (postfix only)\n\n  NFA_BOL,                          /* ^    Begin line */\n  NFA_EOL,                          /* $    End line */\n  NFA_BOW,                          /* \\<   Begin word */\n  NFA_EOW,                          /* \\>   End word */\n  NFA_BOF,                          /* \\%^  Begin file */\n  NFA_EOF,                          /* \\%$  End file */\n  NFA_NEWL,\n  NFA_ZSTART,                       /* Used for \\zs */\n  NFA_ZEND,                         /* Used for \\ze */\n  NFA_NOPEN,                        /* Start of subexpression marked with \\%( */\n  NFA_NCLOSE,                       /* End of subexpr. marked with \\%( ... \\) */\n  NFA_START_INVISIBLE,\n  NFA_START_INVISIBLE_FIRST,\n  NFA_START_INVISIBLE_NEG,\n  NFA_START_INVISIBLE_NEG_FIRST,\n  NFA_START_INVISIBLE_BEFORE,\n  NFA_START_INVISIBLE_BEFORE_FIRST,\n  NFA_START_INVISIBLE_BEFORE_NEG,\n  NFA_START_INVISIBLE_BEFORE_NEG_FIRST,\n  NFA_START_PATTERN,\n  NFA_END_INVISIBLE,\n  NFA_END_INVISIBLE_NEG,\n  NFA_END_PATTERN,\n  NFA_COMPOSING,                    /* Next nodes in NFA are part of the\n                                       composing multibyte char */\n  NFA_END_COMPOSING,                /* End of a composing char in the NFA */\n  NFA_ANY_COMPOSING,                // \\%C: Any composing characters.\n  NFA_OPT_CHARS,                    /* \\%[abc] */\n\n  /* The following are used only in the postfix form, not in the NFA */\n  NFA_PREV_ATOM_NO_WIDTH,           /* Used for \\@= */\n  NFA_PREV_ATOM_NO_WIDTH_NEG,       /* Used for \\@! */\n  NFA_PREV_ATOM_JUST_BEFORE,        /* Used for \\@<= */\n  NFA_PREV_ATOM_JUST_BEFORE_NEG,    /* Used for \\@<! */\n  NFA_PREV_ATOM_LIKE_PATTERN,       /* Used for \\@> */\n\n  NFA_BACKREF1,                     /* \\1 */\n  NFA_BACKREF2,                     /* \\2 */\n  NFA_BACKREF3,                     /* \\3 */\n  NFA_BACKREF4,                     /* \\4 */\n  NFA_BACKREF5,                     /* \\5 */\n  NFA_BACKREF6,                     /* \\6 */\n  NFA_BACKREF7,                     /* \\7 */\n  NFA_BACKREF8,                     /* \\8 */\n  NFA_BACKREF9,                     /* \\9 */\n  NFA_ZREF1,                        /* \\z1 */\n  NFA_ZREF2,                        /* \\z2 */\n  NFA_ZREF3,                        /* \\z3 */\n  NFA_ZREF4,                        /* \\z4 */\n  NFA_ZREF5,                        /* \\z5 */\n  NFA_ZREF6,                        /* \\z6 */\n  NFA_ZREF7,                        /* \\z7 */\n  NFA_ZREF8,                        /* \\z8 */\n  NFA_ZREF9,                        /* \\z9 */\n  NFA_SKIP,                         /* Skip characters */\n\n  NFA_MOPEN,\n  NFA_MOPEN1,\n  NFA_MOPEN2,\n  NFA_MOPEN3,\n  NFA_MOPEN4,\n  NFA_MOPEN5,\n  NFA_MOPEN6,\n  NFA_MOPEN7,\n  NFA_MOPEN8,\n  NFA_MOPEN9,\n\n  NFA_MCLOSE,\n  NFA_MCLOSE1,\n  NFA_MCLOSE2,\n  NFA_MCLOSE3,\n  NFA_MCLOSE4,\n  NFA_MCLOSE5,\n  NFA_MCLOSE6,\n  NFA_MCLOSE7,\n  NFA_MCLOSE8,\n  NFA_MCLOSE9,\n\n  NFA_ZOPEN,\n  NFA_ZOPEN1,\n  NFA_ZOPEN2,\n  NFA_ZOPEN3,\n  NFA_ZOPEN4,\n  NFA_ZOPEN5,\n  NFA_ZOPEN6,\n  NFA_ZOPEN7,\n  NFA_ZOPEN8,\n  NFA_ZOPEN9,\n\n  NFA_ZCLOSE,\n  NFA_ZCLOSE1,\n  NFA_ZCLOSE2,\n  NFA_ZCLOSE3,\n  NFA_ZCLOSE4,\n  NFA_ZCLOSE5,\n  NFA_ZCLOSE6,\n  NFA_ZCLOSE7,\n  NFA_ZCLOSE8,\n  NFA_ZCLOSE9,\n\n  /* NFA_FIRST_NL */\n  NFA_ANY,              /*\tMatch any one character. */\n  NFA_IDENT,            /*\tMatch identifier char */\n  NFA_SIDENT,           /*\tMatch identifier char but no digit */\n  NFA_KWORD,            /*\tMatch keyword char */\n  NFA_SKWORD,           /*\tMatch word char but no digit */\n  NFA_FNAME,            /*\tMatch file name char */\n  NFA_SFNAME,           /*\tMatch file name char but no digit */\n  NFA_PRINT,            /*\tMatch printable char */\n  NFA_SPRINT,           /*\tMatch printable char but no digit */\n  NFA_WHITE,            /*\tMatch whitespace char */\n  NFA_NWHITE,           /*\tMatch non-whitespace char */\n  NFA_DIGIT,            /*\tMatch digit char */\n  NFA_NDIGIT,           /*\tMatch non-digit char */\n  NFA_HEX,              /*\tMatch hex char */\n  NFA_NHEX,             /*\tMatch non-hex char */\n  NFA_OCTAL,            /*\tMatch octal char */\n  NFA_NOCTAL,           /*\tMatch non-octal char */\n  NFA_WORD,             /*\tMatch word char */\n  NFA_NWORD,            /*\tMatch non-word char */\n  NFA_HEAD,             /*\tMatch head char */\n  NFA_NHEAD,            /*\tMatch non-head char */\n  NFA_ALPHA,            /*\tMatch alpha char */\n  NFA_NALPHA,           /*\tMatch non-alpha char */\n  NFA_LOWER,            /*\tMatch lowercase char */\n  NFA_NLOWER,           /*\tMatch non-lowercase char */\n  NFA_UPPER,            /*\tMatch uppercase char */\n  NFA_NUPPER,           /*\tMatch non-uppercase char */\n  NFA_LOWER_IC,         /*\tMatch [a-z] */\n  NFA_NLOWER_IC,        /*\tMatch [^a-z] */\n  NFA_UPPER_IC,         /*\tMatch [A-Z] */\n  NFA_NUPPER_IC,        /*\tMatch [^A-Z] */\n\n  NFA_FIRST_NL = NFA_ANY + NFA_ADD_NL,\n  NFA_LAST_NL = NFA_NUPPER_IC + NFA_ADD_NL,\n\n  NFA_CURSOR,           /*\tMatch cursor pos */\n  NFA_LNUM,             /*\tMatch line number */\n  NFA_LNUM_GT,          /*\tMatch > line number */\n  NFA_LNUM_LT,          /*\tMatch < line number */\n  NFA_COL,              /*\tMatch cursor column */\n  NFA_COL_GT,           /*\tMatch > cursor column */\n  NFA_COL_LT,           /*\tMatch < cursor column */\n  NFA_VCOL,             /*\tMatch cursor virtual column */\n  NFA_VCOL_GT,          /*\tMatch > cursor virtual column */\n  NFA_VCOL_LT,          /*\tMatch < cursor virtual column */\n  NFA_MARK,             /*\tMatch mark */\n  NFA_MARK_GT,          /*\tMatch > mark */\n  NFA_MARK_LT,          /*\tMatch < mark */\n  NFA_VISUAL,           /*\tMatch Visual area */\n\n  /* Character classes [:alnum:] etc */\n  NFA_CLASS_ALNUM,\n  NFA_CLASS_ALPHA,\n  NFA_CLASS_BLANK,\n  NFA_CLASS_CNTRL,\n  NFA_CLASS_DIGIT,\n  NFA_CLASS_GRAPH,\n  NFA_CLASS_LOWER,\n  NFA_CLASS_PRINT,\n  NFA_CLASS_PUNCT,\n  NFA_CLASS_SPACE,\n  NFA_CLASS_UPPER,\n  NFA_CLASS_XDIGIT,\n  NFA_CLASS_TAB,\n  NFA_CLASS_RETURN,\n  NFA_CLASS_BACKSPACE,\n  NFA_CLASS_ESCAPE,\n  NFA_CLASS_IDENT,\n  NFA_CLASS_KEYWORD,\n  NFA_CLASS_FNAME,\n};\n\n/* Keep in sync with classchars. */\nstatic int nfa_classcodes[] = {\n  NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD,NFA_SKWORD,\n  NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,\n  NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,\n  NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,\n  NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,\n  NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,\n  NFA_UPPER, NFA_NUPPER\n};\n\nstatic char_u e_nul_found[] = N_(\n    \"E865: (NFA) Regexp end encountered prematurely\");\nstatic char_u e_misplaced[] = N_(\"E866: (NFA regexp) Misplaced %c\");\nstatic char_u e_ill_char_class[] = N_(\n    \"E877: (NFA regexp) Invalid character class: %\" PRId64);\nstatic char_u e_value_too_large[] = N_(\"E951: \\\\% value too large\");\n\n/* Since the out pointers in the list are always\n * uninitialized, we use the pointers themselves\n * as storage for the Ptrlists. */\ntypedef union Ptrlist Ptrlist;\nunion Ptrlist {\n  Ptrlist     *next;\n  nfa_state_T *s;\n};\n\nstruct Frag {\n  nfa_state_T *start;\n  Ptrlist     *out;\n};\ntypedef struct Frag Frag_T;\n\ntypedef struct {\n  int in_use;       ///< number of subexpr with useful info\n\n  // When REG_MULTI is true list.multi is used, otherwise list.line.\n  union {\n    struct multipos {\n      linenr_T  start_lnum;\n      linenr_T  end_lnum;\n      colnr_T start_col;\n      colnr_T end_col;\n    } multi[NSUBEXP];\n    struct linepos {\n      char_u      *start;\n      char_u      *end;\n    } line[NSUBEXP];\n  } list;\n} regsub_T;\n\ntypedef struct {\n  regsub_T norm;      /* \\( .. \\) matches */\n  regsub_T synt;      /* \\z( .. \\) matches */\n} regsubs_T;\n\n/* nfa_pim_T stores a Postponed Invisible Match. */\ntypedef struct nfa_pim_S nfa_pim_T;\nstruct nfa_pim_S {\n  int result;                   /* NFA_PIM_*, see below */\n  nfa_state_T *state;           /* the invisible match start state */\n  regsubs_T subs;               /* submatch info, only party used */\n  union {\n    lpos_T pos;\n    char_u  *ptr;\n  } end;                        /* where the match must end */\n};\n\n/* nfa_thread_T contains execution information of a NFA state */\ntypedef struct {\n  nfa_state_T *state;\n  int count;\n  nfa_pim_T pim;                /* if pim.result != NFA_PIM_UNUSED: postponed\n                                 * invisible match */\n  regsubs_T subs;               /* submatch info, only party used */\n} nfa_thread_T;\n\n// nfa_list_T contains the alternative NFA execution states.\ntypedef struct {\n  nfa_thread_T    *t;           ///< allocated array of states\n  int n;                        ///< nr of states currently in \"t\"\n  int len;                      ///< max nr of states in \"t\"\n  int id;                       ///< ID of the list\n  int has_pim;                  ///< true when any state has a PIM\n} nfa_list_T;\n\n// Variables only used in nfa_regcomp() and descendants.\nstatic int nfa_re_flags;  ///< re_flags passed to nfa_regcomp().\nstatic int *post_start;   ///< holds the postfix form of r.e.\nstatic int *post_end;\nstatic int *post_ptr;\n\n// Set when the pattern should use the NFA engine.\n// E.g. [[:upper:]] only allows 8bit characters for BT engine,\n// while NFA engine handles multibyte characters correctly.\nstatic bool wants_nfa;\n\nstatic int nstate;  ///< Number of states in the NFA. Also used when executing.\nstatic int istate;  ///< Index in the state vector, used in alloc_state()\n\n/* If not NULL match must end at this position */\nstatic save_se_T *nfa_endp = NULL;\n\n/* 0 for first call to nfa_regmatch(), 1 for recursive call. */\nstatic int nfa_ll_index = 0;\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"regexp_nfa.c.generated.h\"\n#endif\n\n// Helper functions used when doing re2post() ... regatom() parsing\n#define EMIT(c) \\\n    do { \\\n      if (post_ptr >= post_end) { \\\n        realloc_post_list(); \\\n      } \\\n      *post_ptr++ = c; \\\n    } while (0)\n\n/*\n * Initialize internal variables before NFA compilation.\n */\nstatic void\nnfa_regcomp_start (\n    char_u *expr,\n    int re_flags                       /* see vim_regcomp() */\n)\n{\n  size_t postfix_size;\n  size_t nstate_max;\n\n  nstate = 0;\n  istate = 0;\n  /* A reasonable estimation for maximum size */\n  nstate_max = (STRLEN(expr) + 1) * 25;\n\n  /* Some items blow up in size, such as [A-z].  Add more space for that.\n   * When it is still not enough realloc_post_list() will be used. */\n  nstate_max += 1000;\n\n  /* Size for postfix representation of expr. */\n  postfix_size = sizeof(int) * nstate_max;\n\n  post_start = (int *)xmalloc(postfix_size);\n  post_ptr = post_start;\n  post_end = post_start + nstate_max;\n  wants_nfa = false;\n  rex.nfa_has_zend = false;\n  rex.nfa_has_backref = false;\n\n  /* shared with BT engine */\n  regcomp_start(expr, re_flags);\n}\n\n/*\n * Figure out if the NFA state list starts with an anchor, must match at start\n * of the line.\n */\nstatic int nfa_get_reganch(nfa_state_T *start, int depth)\n{\n  nfa_state_T *p = start;\n\n  if (depth > 4)\n    return 0;\n\n  while (p != NULL) {\n    switch (p->c) {\n    case NFA_BOL:\n    case NFA_BOF:\n      return 1;           /* yes! */\n\n    case NFA_ZSTART:\n    case NFA_ZEND:\n    case NFA_CURSOR:\n    case NFA_VISUAL:\n\n    case NFA_MOPEN:\n    case NFA_MOPEN1:\n    case NFA_MOPEN2:\n    case NFA_MOPEN3:\n    case NFA_MOPEN4:\n    case NFA_MOPEN5:\n    case NFA_MOPEN6:\n    case NFA_MOPEN7:\n    case NFA_MOPEN8:\n    case NFA_MOPEN9:\n    case NFA_NOPEN:\n    case NFA_ZOPEN:\n    case NFA_ZOPEN1:\n    case NFA_ZOPEN2:\n    case NFA_ZOPEN3:\n    case NFA_ZOPEN4:\n    case NFA_ZOPEN5:\n    case NFA_ZOPEN6:\n    case NFA_ZOPEN7:\n    case NFA_ZOPEN8:\n    case NFA_ZOPEN9:\n      p = p->out;\n      break;\n\n    case NFA_SPLIT:\n      return nfa_get_reganch(p->out, depth + 1)\n             && nfa_get_reganch(p->out1, depth + 1);\n\n    default:\n      return 0;           /* noooo */\n    }\n  }\n  return 0;\n}\n\n/*\n * Figure out if the NFA state list starts with a character which must match\n * at start of the match.\n */\nstatic int nfa_get_regstart(nfa_state_T *start, int depth)\n{\n  nfa_state_T *p = start;\n\n  if (depth > 4)\n    return 0;\n\n  while (p != NULL) {\n    switch (p->c) {\n    /* all kinds of zero-width matches */\n    case NFA_BOL:\n    case NFA_BOF:\n    case NFA_BOW:\n    case NFA_EOW:\n    case NFA_ZSTART:\n    case NFA_ZEND:\n    case NFA_CURSOR:\n    case NFA_VISUAL:\n    case NFA_LNUM:\n    case NFA_LNUM_GT:\n    case NFA_LNUM_LT:\n    case NFA_COL:\n    case NFA_COL_GT:\n    case NFA_COL_LT:\n    case NFA_VCOL:\n    case NFA_VCOL_GT:\n    case NFA_VCOL_LT:\n    case NFA_MARK:\n    case NFA_MARK_GT:\n    case NFA_MARK_LT:\n\n    case NFA_MOPEN:\n    case NFA_MOPEN1:\n    case NFA_MOPEN2:\n    case NFA_MOPEN3:\n    case NFA_MOPEN4:\n    case NFA_MOPEN5:\n    case NFA_MOPEN6:\n    case NFA_MOPEN7:\n    case NFA_MOPEN8:\n    case NFA_MOPEN9:\n    case NFA_NOPEN:\n    case NFA_ZOPEN:\n    case NFA_ZOPEN1:\n    case NFA_ZOPEN2:\n    case NFA_ZOPEN3:\n    case NFA_ZOPEN4:\n    case NFA_ZOPEN5:\n    case NFA_ZOPEN6:\n    case NFA_ZOPEN7:\n    case NFA_ZOPEN8:\n    case NFA_ZOPEN9:\n      p = p->out;\n      break;\n\n    case NFA_SPLIT:\n    {\n      int c1 = nfa_get_regstart(p->out, depth + 1);\n      int c2 = nfa_get_regstart(p->out1, depth + 1);\n\n      if (c1 == c2)\n        return c1;             /* yes! */\n      return 0;\n    }\n\n    default:\n      if (p->c > 0)\n        return p->c;             /* yes! */\n      return 0;\n    }\n  }\n  return 0;\n}\n\n/*\n * Figure out if the NFA state list contains just literal text and nothing\n * else.  If so return a string in allocated memory with what must match after\n * regstart.  Otherwise return NULL.\n */\nstatic char_u *nfa_get_match_text(nfa_state_T *start)\n{\n  nfa_state_T *p = start;\n  int len = 0;\n  char_u      *ret;\n  char_u      *s;\n\n  if (p->c != NFA_MOPEN)\n    return NULL;     /* just in case */\n  p = p->out;\n  while (p->c > 0) {\n    len += MB_CHAR2LEN(p->c);\n    p = p->out;\n  }\n  if (p->c != NFA_MCLOSE || p->out->c != NFA_MATCH)\n    return NULL;\n\n  ret = xmalloc(len);\n  p = start->out->out;     /* skip first char, it goes into regstart */\n  s = ret;\n  while (p->c > 0) {\n    s += utf_char2bytes(p->c, s);\n    p = p->out;\n  }\n  *s = NUL;\n\n  return ret;\n}\n\n/*\n * Allocate more space for post_start.  Called when\n * running above the estimated number of states.\n */\nstatic void realloc_post_list(void)\n{\n  // For weird patterns the number of states can be very high. Increasing by\n  // 50% seems a reasonable compromise between memory use and speed.\n  const size_t new_max = (post_end - post_start) * 3 / 2;\n  int *new_start = xrealloc(post_start, new_max * sizeof(int));\n  post_ptr = new_start + (post_ptr - post_start);\n  post_end = new_start + new_max;\n  post_start = new_start;\n}\n\n/*\n * Search between \"start\" and \"end\" and try to recognize a\n * character class in expanded form. For example [0-9].\n * On success, return the id the character class to be emitted.\n * On failure, return 0 (=FAIL)\n * Start points to the first char of the range, while end should point\n * to the closing brace.\n * Keep in mind that 'ignorecase' applies at execution time, thus [a-z] may\n * need to be interpreted as [a-zA-Z].\n */\nstatic int nfa_recognize_char_class(char_u *start, char_u *end, int extra_newl)\n{\n#   define CLASS_not            0x80\n#   define CLASS_af             0x40\n#   define CLASS_AF             0x20\n#   define CLASS_az             0x10\n#   define CLASS_AZ             0x08\n#   define CLASS_o7             0x04\n#   define CLASS_o9             0x02\n#   define CLASS_underscore     0x01\n\n  char_u      *p;\n  int config = 0;\n\n  bool newl = extra_newl == true;\n\n  if (*end != ']')\n    return FAIL;\n  p = start;\n  if (*p == '^') {\n    config |= CLASS_not;\n    p++;\n  }\n\n  while (p < end) {\n    if (p + 2 < end && *(p + 1) == '-') {\n      switch (*p) {\n      case '0':\n        if (*(p + 2) == '9') {\n          config |= CLASS_o9;\n          break;\n        } else if (*(p + 2) == '7') {\n          config |= CLASS_o7;\n          break;\n        }\n        return FAIL;\n      case 'a':\n        if (*(p + 2) == 'z') {\n          config |= CLASS_az;\n          break;\n        } else if (*(p + 2) == 'f') {\n          config |= CLASS_af;\n          break;\n        }\n        return FAIL;\n      case 'A':\n        if (*(p + 2) == 'Z') {\n          config |= CLASS_AZ;\n          break;\n        } else if (*(p + 2) == 'F') {\n          config |= CLASS_AF;\n          break;\n        }\n        return FAIL;\n      default:\n        return FAIL;\n      }\n      p += 3;\n    } else if (p + 1 < end && *p == '\\\\' && *(p + 1) == 'n') {\n      newl = true;\n      p += 2;\n    } else if (*p == '_') {\n      config |= CLASS_underscore;\n      p++;\n    } else if (*p == '\\n') {\n      newl = true;\n      p++;\n    } else\n      return FAIL;\n  }   /* while (p < end) */\n\n  if (p != end)\n    return FAIL;\n\n  if (newl == true) {\n    extra_newl = NFA_ADD_NL;\n  }\n\n  switch (config) {\n  case CLASS_o9:\n    return extra_newl + NFA_DIGIT;\n  case CLASS_not |  CLASS_o9:\n    return extra_newl + NFA_NDIGIT;\n  case CLASS_af | CLASS_AF | CLASS_o9:\n    return extra_newl + NFA_HEX;\n  case CLASS_not | CLASS_af | CLASS_AF | CLASS_o9:\n    return extra_newl + NFA_NHEX;\n  case CLASS_o7:\n    return extra_newl + NFA_OCTAL;\n  case CLASS_not | CLASS_o7:\n    return extra_newl + NFA_NOCTAL;\n  case CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:\n    return extra_newl + NFA_WORD;\n  case CLASS_not | CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:\n    return extra_newl + NFA_NWORD;\n  case CLASS_az | CLASS_AZ | CLASS_underscore:\n    return extra_newl + NFA_HEAD;\n  case CLASS_not | CLASS_az | CLASS_AZ | CLASS_underscore:\n    return extra_newl + NFA_NHEAD;\n  case CLASS_az | CLASS_AZ:\n    return extra_newl + NFA_ALPHA;\n  case CLASS_not | CLASS_az | CLASS_AZ:\n    return extra_newl + NFA_NALPHA;\n  case CLASS_az:\n    return extra_newl + NFA_LOWER_IC;\n  case CLASS_not | CLASS_az:\n    return extra_newl + NFA_NLOWER_IC;\n  case CLASS_AZ:\n    return extra_newl + NFA_UPPER_IC;\n  case CLASS_not | CLASS_AZ:\n    return extra_newl + NFA_NUPPER_IC;\n  }\n  return FAIL;\n}\n\n/*\n * Produce the bytes for equivalence class \"c\".\n * Currently only handles latin1, latin9 and utf-8.\n * Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is\n * equivalent to 'a OR b OR c'\n *\n * NOTE! When changing this function, also update reg_equi_class()\n */\nstatic void nfa_emit_equi_class(int c)\n{\n#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);\n#define EMITMBC(c) EMIT(c); EMIT(NFA_CONCAT);\n\n  {\n#define A_grave 0xc0\n#define A_acute 0xc1\n#define A_circumflex 0xc2\n#define A_virguilla 0xc3\n#define A_diaeresis 0xc4\n#define A_ring 0xc5\n#define C_cedilla 0xc7\n#define E_grave 0xc8\n#define E_acute 0xc9\n#define E_circumflex 0xca\n#define E_diaeresis 0xcb\n#define I_grave 0xcc\n#define I_acute 0xcd\n#define I_circumflex 0xce\n#define I_diaeresis 0xcf\n#define N_virguilla 0xd1\n#define O_grave 0xd2\n#define O_acute 0xd3\n#define O_circumflex 0xd4\n#define O_virguilla 0xd5\n#define O_diaeresis 0xd6\n#define O_slash 0xd8\n#define U_grave 0xd9\n#define U_acute 0xda\n#define U_circumflex 0xdb\n#define U_diaeresis 0xdc\n#define Y_acute 0xdd\n#define a_grave 0xe0\n#define a_acute 0xe1\n#define a_circumflex 0xe2\n#define a_virguilla 0xe3\n#define a_diaeresis 0xe4\n#define a_ring 0xe5\n#define c_cedilla 0xe7\n#define e_grave 0xe8\n#define e_acute 0xe9\n#define e_circumflex 0xea\n#define e_diaeresis 0xeb\n#define i_grave 0xec\n#define i_acute 0xed\n#define i_circumflex 0xee\n#define i_diaeresis 0xef\n#define n_virguilla 0xf1\n#define o_grave 0xf2\n#define o_acute 0xf3\n#define o_circumflex 0xf4\n#define o_virguilla 0xf5\n#define o_diaeresis 0xf6\n#define o_slash 0xf8\n#define u_grave 0xf9\n#define u_acute 0xfa\n#define u_circumflex 0xfb\n#define u_diaeresis 0xfc\n#define y_acute 0xfd\n#define y_diaeresis 0xff\n    switch (c) {\n    case 'A': case A_grave: case A_acute: case A_circumflex:\n              case A_virguilla: case A_diaeresis: case A_ring:\n              CASEMBC(0x100) CASEMBC(0x102) CASEMBC(0x104)\n              CASEMBC(0x1cd) CASEMBC(0x1de) CASEMBC(0x1e0)\n              CASEMBC(0x1ea2)\n      EMIT2('A'); EMIT2(A_grave); EMIT2(A_acute);\n      EMIT2(A_circumflex); EMIT2(A_virguilla);\n      EMIT2(A_diaeresis); EMIT2(A_ring);\n      EMITMBC(0x100) EMITMBC(0x102) EMITMBC(0x104)\n      EMITMBC(0x1cd) EMITMBC(0x1de) EMITMBC(0x1e0)\n      EMITMBC(0x1ea2)\n      return;\n\n    case 'B': CASEMBC(0x1e02) CASEMBC(0x1e06)\n      EMIT2('B'); EMITMBC(0x1e02) EMITMBC(0x1e06)\n      return;\n\n    case 'C': case C_cedilla: CASEMBC(0x106) CASEMBC(0x108) CASEMBC(0x10a)\n              CASEMBC(0x10c)\n      EMIT2('C'); EMIT2(C_cedilla); EMITMBC(0x106) EMITMBC(0x108)\n      EMITMBC(0x10a) EMITMBC(0x10c)\n      return;\n\n    case 'D': CASEMBC(0x10e) CASEMBC(0x110) CASEMBC(0x1e0a)\n              CASEMBC(0x1e0e) CASEMBC(0x1e10)\n      EMIT2('D'); EMITMBC(0x10e) EMITMBC(0x110) EMITMBC(0x1e0a)\n      EMITMBC(0x1e0e) EMITMBC(0x1e10)\n      return;\n\n    case 'E': case E_grave: case E_acute: case E_circumflex:\n              case E_diaeresis: CASEMBC(0x112) CASEMBC(0x114)\n              CASEMBC(0x116) CASEMBC(0x118) CASEMBC(0x11a)\n              CASEMBC(0x1eba) CASEMBC(0x1ebc)\n      EMIT2('E'); EMIT2(E_grave); EMIT2(E_acute);\n      EMIT2(E_circumflex); EMIT2(E_diaeresis);\n      EMITMBC(0x112) EMITMBC(0x114) EMITMBC(0x116)\n      EMITMBC(0x118) EMITMBC(0x11a) EMITMBC(0x1eba)\n      EMITMBC(0x1ebc)\n      return;\n\n    case 'F': CASEMBC(0x1e1e)\n      EMIT2('F'); EMITMBC(0x1e1e)\n      return;\n\n    case 'G': CASEMBC(0x11c) CASEMBC(0x11e) CASEMBC(0x120)\n              CASEMBC(0x122) CASEMBC(0x1e4) CASEMBC(0x1e6)\n              CASEMBC(0x1f4) CASEMBC(0x1e20)\n      EMIT2('G'); EMITMBC(0x11c) EMITMBC(0x11e) EMITMBC(0x120)\n      EMITMBC(0x122) EMITMBC(0x1e4) EMITMBC(0x1e6)\n      EMITMBC(0x1f4) EMITMBC(0x1e20)\n      return;\n\n    case 'H': CASEMBC(0x124) CASEMBC(0x126) CASEMBC(0x1e22)\n              CASEMBC(0x1e26) CASEMBC(0x1e28)\n      EMIT2('H'); EMITMBC(0x124) EMITMBC(0x126) EMITMBC(0x1e22)\n      EMITMBC(0x1e26) EMITMBC(0x1e28)\n      return;\n\n    case 'I': case I_grave: case I_acute: case I_circumflex:\n              case I_diaeresis: CASEMBC(0x128) CASEMBC(0x12a)\n              CASEMBC(0x12c) CASEMBC(0x12e) CASEMBC(0x130)\n              CASEMBC(0x1cf) CASEMBC(0x1ec8)\n      EMIT2('I'); EMIT2(I_grave); EMIT2(I_acute);\n      EMIT2(I_circumflex); EMIT2(I_diaeresis);\n      EMITMBC(0x128) EMITMBC(0x12a)\n      EMITMBC(0x12c) EMITMBC(0x12e) EMITMBC(0x130)\n      EMITMBC(0x1cf) EMITMBC(0x1ec8)\n      return;\n\n    case 'J': CASEMBC(0x134)\n      EMIT2('J'); EMITMBC(0x134)\n      return;\n\n    case 'K': CASEMBC(0x136) CASEMBC(0x1e8) CASEMBC(0x1e30)\n              CASEMBC(0x1e34)\n      EMIT2('K'); EMITMBC(0x136) EMITMBC(0x1e8) EMITMBC(0x1e30)\n      EMITMBC(0x1e34)\n      return;\n\n    case 'L': CASEMBC(0x139) CASEMBC(0x13b) CASEMBC(0x13d)\n              CASEMBC(0x13f) CASEMBC(0x141) CASEMBC(0x1e3a)\n      EMIT2('L'); EMITMBC(0x139) EMITMBC(0x13b) EMITMBC(0x13d)\n      EMITMBC(0x13f) EMITMBC(0x141) EMITMBC(0x1e3a)\n      return;\n\n    case 'M': CASEMBC(0x1e3e) CASEMBC(0x1e40)\n      EMIT2('M'); EMITMBC(0x1e3e) EMITMBC(0x1e40)\n      return;\n\n    case 'N': case N_virguilla: CASEMBC(0x143) CASEMBC(0x145)\n              CASEMBC(0x147) CASEMBC(0x1e44) CASEMBC(0x1e48)\n      EMIT2('N'); EMIT2(N_virguilla);\n      EMITMBC(0x143) EMITMBC(0x145)\n      EMITMBC(0x147) EMITMBC(0x1e44) EMITMBC(0x1e48)\n      return;\n\n    case 'O': case O_grave: case O_acute: case O_circumflex:\n              case O_virguilla: case O_diaeresis: case O_slash:\n              CASEMBC(0x14c) CASEMBC(0x14e) CASEMBC(0x150)\n              CASEMBC(0x1a0) CASEMBC(0x1d1) CASEMBC(0x1ea)\n              CASEMBC(0x1ec) CASEMBC(0x1ece)\n      EMIT2('O'); EMIT2(O_grave); EMIT2(O_acute);\n      EMIT2(O_circumflex); EMIT2(O_virguilla);\n      EMIT2(O_diaeresis); EMIT2(O_slash);\n      EMITMBC(0x14c) EMITMBC(0x14e) EMITMBC(0x150)\n      EMITMBC(0x1a0) EMITMBC(0x1d1) EMITMBC(0x1ea)\n      EMITMBC(0x1ec) EMITMBC(0x1ece)\n      return;\n\n    case 'P': case 0x1e54: case 0x1e56:\n      EMIT2('P'); EMITMBC(0x1e54) EMITMBC(0x1e56)\n      return;\n\n    case 'R': CASEMBC(0x154) CASEMBC(0x156) CASEMBC(0x158)\n              CASEMBC(0x1e58) CASEMBC(0x1e5e)\n      EMIT2('R'); EMITMBC(0x154) EMITMBC(0x156) EMITMBC(0x158)\n      EMITMBC(0x1e58) EMITMBC(0x1e5e)\n      return;\n\n    case 'S': CASEMBC(0x15a) CASEMBC(0x15c) CASEMBC(0x15e)\n              CASEMBC(0x160) CASEMBC(0x1e60)\n      EMIT2('S'); EMITMBC(0x15a) EMITMBC(0x15c) EMITMBC(0x15e)\n      EMITMBC(0x160) EMITMBC(0x1e60)\n      return;\n\n    case 'T': CASEMBC(0x162) CASEMBC(0x164) CASEMBC(0x166)\n              CASEMBC(0x1e6a) CASEMBC(0x1e6e)\n      EMIT2('T'); EMITMBC(0x162) EMITMBC(0x164) EMITMBC(0x166)\n      EMITMBC(0x1e6a) EMITMBC(0x1e6e)\n      return;\n\n    case 'U': case U_grave: case U_acute: case U_diaeresis:\n              case U_circumflex: CASEMBC(0x168) CASEMBC(0x16a)\n              CASEMBC(0x16c) CASEMBC(0x16e) CASEMBC(0x170)\n              CASEMBC(0x172) CASEMBC(0x1af) CASEMBC(0x1d3)\n              CASEMBC(0x1ee6)\n      EMIT2('U'); EMIT2(U_grave); EMIT2(U_acute);\n      EMIT2(U_diaeresis); EMIT2(U_circumflex);\n      EMITMBC(0x168) EMITMBC(0x16a)\n      EMITMBC(0x16c) EMITMBC(0x16e) EMITMBC(0x170)\n      EMITMBC(0x172) EMITMBC(0x1af) EMITMBC(0x1d3)\n      EMITMBC(0x1ee6)\n      return;\n\n    case 'V': CASEMBC(0x1e7c)\n      EMIT2('V'); EMITMBC(0x1e7c)\n      return;\n\n    case 'W': CASEMBC(0x174) CASEMBC(0x1e80) CASEMBC(0x1e82)\n              CASEMBC(0x1e84) CASEMBC(0x1e86)\n      EMIT2('W'); EMITMBC(0x174) EMITMBC(0x1e80) EMITMBC(0x1e82)\n      EMITMBC(0x1e84) EMITMBC(0x1e86)\n      return;\n\n    case 'X': CASEMBC(0x1e8a) CASEMBC(0x1e8c)\n      EMIT2('X'); EMITMBC(0x1e8a) EMITMBC(0x1e8c)\n      return;\n\n    case 'Y': case Y_acute: CASEMBC(0x176) CASEMBC(0x178)\n              CASEMBC(0x1e8e) CASEMBC(0x1ef2) CASEMBC(0x1ef6)\n              CASEMBC(0x1ef8)\n      EMIT2('Y'); EMIT2(Y_acute);\n      EMITMBC(0x176) EMITMBC(0x178)\n      EMITMBC(0x1e8e) EMITMBC(0x1ef2) EMITMBC(0x1ef6)\n      EMITMBC(0x1ef8)\n      return;\n\n    case 'Z': CASEMBC(0x179) CASEMBC(0x17b) CASEMBC(0x17d)\n              CASEMBC(0x1b5) CASEMBC(0x1e90) CASEMBC(0x1e94)\n      EMIT2('Z'); EMITMBC(0x179) EMITMBC(0x17b) EMITMBC(0x17d)\n      EMITMBC(0x1b5) EMITMBC(0x1e90) EMITMBC(0x1e94)\n      return;\n\n    case 'a': case a_grave: case a_acute: case a_circumflex:\n              case a_virguilla: case a_diaeresis: case a_ring:\n              CASEMBC(0x101) CASEMBC(0x103) CASEMBC(0x105)\n              CASEMBC(0x1ce) CASEMBC(0x1df) CASEMBC(0x1e1)\n              CASEMBC(0x1ea3)\n      EMIT2('a'); EMIT2(a_grave); EMIT2(a_acute);\n      EMIT2(a_circumflex); EMIT2(a_virguilla);\n      EMIT2(a_diaeresis); EMIT2(a_ring);\n      EMITMBC(0x101) EMITMBC(0x103) EMITMBC(0x105)\n      EMITMBC(0x1ce) EMITMBC(0x1df) EMITMBC(0x1e1)\n      EMITMBC(0x1ea3)\n      return;\n\n    case 'b': CASEMBC(0x1e03) CASEMBC(0x1e07)\n      EMIT2('b'); EMITMBC(0x1e03) EMITMBC(0x1e07)\n      return;\n\n    case 'c': case c_cedilla: CASEMBC(0x107) CASEMBC(0x109)\n              CASEMBC(0x10b) CASEMBC(0x10d)\n      EMIT2('c'); EMIT2(c_cedilla);\n      EMITMBC(0x107) EMITMBC(0x109)\n      EMITMBC(0x10b) EMITMBC(0x10d)\n      return;\n\n    case 'd': CASEMBC(0x10f) CASEMBC(0x111) CASEMBC(0x1e0b)\n              CASEMBC(0x1e0f) CASEMBC(0x1e11)\n      EMIT2('d'); EMITMBC(0x10f) EMITMBC(0x111) EMITMBC(0x1e0b)\n      EMITMBC(0x1e0f) EMITMBC(0x1e11)\n      return;\n\n    case 'e': case e_grave: case e_acute: case e_circumflex:\n              case e_diaeresis: CASEMBC(0x113) CASEMBC(0x115)\n              CASEMBC(0x117) CASEMBC(0x119) CASEMBC(0x11b)\n              CASEMBC(0x1ebb) CASEMBC(0x1ebd)\n      EMIT2('e'); EMIT2(e_grave); EMIT2(e_acute);\n      EMIT2(e_circumflex); EMIT2(e_diaeresis);\n      EMITMBC(0x113) EMITMBC(0x115)\n      EMITMBC(0x117) EMITMBC(0x119) EMITMBC(0x11b)\n      EMITMBC(0x1ebb) EMITMBC(0x1ebd)\n      return;\n\n    case 'f': CASEMBC(0x1e1f)\n      EMIT2('f'); EMITMBC(0x1e1f)\n      return;\n\n    case 'g': CASEMBC(0x11d) CASEMBC(0x11f) CASEMBC(0x121)\n              CASEMBC(0x123) CASEMBC(0x1e5) CASEMBC(0x1e7)\n              CASEMBC(0x1f5) CASEMBC(0x1e21)\n      EMIT2('g'); EMITMBC(0x11d) EMITMBC(0x11f) EMITMBC(0x121)\n      EMITMBC(0x123) EMITMBC(0x1e5) EMITMBC(0x1e7)\n      EMITMBC(0x1f5) EMITMBC(0x1e21)\n      return;\n\n    case 'h': CASEMBC(0x125) CASEMBC(0x127) CASEMBC(0x1e23)\n              CASEMBC(0x1e27) CASEMBC(0x1e29) CASEMBC(0x1e96)\n      EMIT2('h'); EMITMBC(0x125) EMITMBC(0x127) EMITMBC(0x1e23)\n      EMITMBC(0x1e27) EMITMBC(0x1e29) EMITMBC(0x1e96)\n      return;\n\n    case 'i': case i_grave: case i_acute: case i_circumflex:\n              case i_diaeresis: CASEMBC(0x129) CASEMBC(0x12b)\n              CASEMBC(0x12d) CASEMBC(0x12f) CASEMBC(0x1d0)\n              CASEMBC(0x1ec9)\n      EMIT2('i'); EMIT2(i_grave); EMIT2(i_acute);\n      EMIT2(i_circumflex); EMIT2(i_diaeresis);\n      EMITMBC(0x129) EMITMBC(0x12b)\n      EMITMBC(0x12d) EMITMBC(0x12f) EMITMBC(0x1d0)\n      EMITMBC(0x1ec9)\n      return;\n\n    case 'j': CASEMBC(0x135) CASEMBC(0x1f0)\n      EMIT2('j'); EMITMBC(0x135) EMITMBC(0x1f0)\n      return;\n\n    case 'k': CASEMBC(0x137) CASEMBC(0x1e9) CASEMBC(0x1e31)\n              CASEMBC(0x1e35)\n      EMIT2('k'); EMITMBC(0x137) EMITMBC(0x1e9) EMITMBC(0x1e31)\n      EMITMBC(0x1e35)\n      return;\n\n    case 'l': CASEMBC(0x13a) CASEMBC(0x13c) CASEMBC(0x13e)\n              CASEMBC(0x140) CASEMBC(0x142) CASEMBC(0x1e3b)\n      EMIT2('l'); EMITMBC(0x13a) EMITMBC(0x13c) EMITMBC(0x13e)\n      EMITMBC(0x140) EMITMBC(0x142) EMITMBC(0x1e3b)\n      return;\n\n    case 'm': CASEMBC(0x1e3f) CASEMBC(0x1e41)\n      EMIT2('m'); EMITMBC(0x1e3f) EMITMBC(0x1e41)\n      return;\n\n    case 'n': case n_virguilla: CASEMBC(0x144) CASEMBC(0x146)\n              CASEMBC(0x148) CASEMBC(0x149) CASEMBC(0x1e45)\n              CASEMBC(0x1e49)\n      EMIT2('n'); EMIT2(n_virguilla);\n      EMITMBC(0x144) EMITMBC(0x146)\n      EMITMBC(0x148) EMITMBC(0x149) EMITMBC(0x1e45)\n      EMITMBC(0x1e49)\n      return;\n\n    case 'o': case o_grave: case o_acute: case o_circumflex:\n              case o_virguilla: case o_diaeresis: case o_slash:\n              CASEMBC(0x14d) CASEMBC(0x14f) CASEMBC(0x151)\n              CASEMBC(0x1a1) CASEMBC(0x1d2) CASEMBC(0x1eb)\n              CASEMBC(0x1ed) CASEMBC(0x1ecf)\n      EMIT2('o'); EMIT2(o_grave); EMIT2(o_acute);\n      EMIT2(o_circumflex); EMIT2(o_virguilla);\n      EMIT2(o_diaeresis); EMIT2(o_slash);\n      EMITMBC(0x14d) EMITMBC(0x14f) EMITMBC(0x151)\n      EMITMBC(0x1a1) EMITMBC(0x1d2) EMITMBC(0x1eb)\n      EMITMBC(0x1ed) EMITMBC(0x1ecf)\n      return;\n\n    case 'p': CASEMBC(0x1e55) CASEMBC(0x1e57)\n      EMIT2('p'); EMITMBC(0x1e55) EMITMBC(0x1e57)\n      return;\n\n    case 'r': CASEMBC(0x155) CASEMBC(0x157) CASEMBC(0x159)\n              CASEMBC(0x1e59) CASEMBC(0x1e5f)\n      EMIT2('r'); EMITMBC(0x155) EMITMBC(0x157) EMITMBC(0x159)\n      EMITMBC(0x1e59) EMITMBC(0x1e5f)\n      return;\n\n    case 's': CASEMBC(0x15b) CASEMBC(0x15d) CASEMBC(0x15f)\n              CASEMBC(0x161) CASEMBC(0x1e61)\n      EMIT2('s'); EMITMBC(0x15b) EMITMBC(0x15d) EMITMBC(0x15f)\n      EMITMBC(0x161) EMITMBC(0x1e61)\n      return;\n\n    case 't': CASEMBC(0x163) CASEMBC(0x165) CASEMBC(0x167)\n              CASEMBC(0x1e6b) CASEMBC(0x1e6f) CASEMBC(0x1e97)\n      EMIT2('t'); EMITMBC(0x163) EMITMBC(0x165) EMITMBC(0x167)\n      EMITMBC(0x1e6b) EMITMBC(0x1e6f) EMITMBC(0x1e97)\n      return;\n\n    case 'u': case u_grave: case u_acute: case u_circumflex:\n              case u_diaeresis: CASEMBC(0x169) CASEMBC(0x16b)\n              CASEMBC(0x16d) CASEMBC(0x16f) CASEMBC(0x171)\n              CASEMBC(0x173) CASEMBC(0x1b0) CASEMBC(0x1d4)\n              CASEMBC(0x1ee7)\n      EMIT2('u'); EMIT2(u_grave); EMIT2(u_acute);\n      EMIT2(u_circumflex); EMIT2(u_diaeresis);\n      EMITMBC(0x169) EMITMBC(0x16b)\n      EMITMBC(0x16d) EMITMBC(0x16f) EMITMBC(0x171)\n      EMITMBC(0x173) EMITMBC(0x1b0) EMITMBC(0x1d4)\n      EMITMBC(0x1ee7)\n      return;\n\n    case 'v': CASEMBC(0x1e7d)\n      EMIT2('v'); EMITMBC(0x1e7d)\n      return;\n\n    case 'w': CASEMBC(0x175) CASEMBC(0x1e81) CASEMBC(0x1e83)\n              CASEMBC(0x1e85) CASEMBC(0x1e87) CASEMBC(0x1e98)\n      EMIT2('w'); EMITMBC(0x175) EMITMBC(0x1e81) EMITMBC(0x1e83)\n      EMITMBC(0x1e85) EMITMBC(0x1e87) EMITMBC(0x1e98)\n      return;\n\n    case 'x': CASEMBC(0x1e8b) CASEMBC(0x1e8d)\n      EMIT2('x'); EMITMBC(0x1e8b) EMITMBC(0x1e8d)\n      return;\n\n    case 'y': case y_acute: case y_diaeresis: CASEMBC(0x177)\n              CASEMBC(0x1e8f) CASEMBC(0x1e99) CASEMBC(0x1ef3)\n              CASEMBC(0x1ef7) CASEMBC(0x1ef9)\n      EMIT2('y'); EMIT2(y_acute); EMIT2(y_diaeresis);\n      EMITMBC(0x177)\n      EMITMBC(0x1e8f) EMITMBC(0x1e99) EMITMBC(0x1ef3)\n      EMITMBC(0x1ef7) EMITMBC(0x1ef9)\n      return;\n\n    case 'z': CASEMBC(0x17a) CASEMBC(0x17c) CASEMBC(0x17e)\n              CASEMBC(0x1b6) CASEMBC(0x1e91) CASEMBC(0x1e95)\n      EMIT2('z'); EMITMBC(0x17a) EMITMBC(0x17c) EMITMBC(0x17e)\n      EMITMBC(0x1b6) EMITMBC(0x1e91) EMITMBC(0x1e95)\n      return;\n\n      /* default: character itself */\n    }\n  }\n\n  EMIT2(c);\n#undef EMIT2\n#undef EMITMBC\n}\n\n/*\n * Code to parse regular expression.\n *\n * We try to reuse parsing functions in regexp.c to\n * minimize surprise and keep the syntax consistent.\n */\n\n/*\n * Parse the lowest level.\n *\n * An atom can be one of a long list of items.  Many atoms match one character\n * in the text.  It is often an ordinary character or a character class.\n * Braces can be used to make a pattern into an atom.  The \"\\z(\\)\" construct\n * is only for syntax highlighting.\n *\n * atom    ::=     ordinary-atom\n *     or  \\( pattern \\)\n *     or  \\%( pattern \\)\n *     or  \\z( pattern \\)\n */\nstatic int nfa_regatom(void)\n{\n  int c;\n  int charclass;\n  int equiclass;\n  int collclass;\n  int got_coll_char;\n  char_u      *p;\n  char_u      *endp;\n  char_u      *old_regparse = regparse;\n  int extra = 0;\n  int emit_range;\n  int negated;\n  int startc = -1;\n  int save_prev_at_start = prev_at_start;\n\n  c = getchr();\n  switch (c) {\n  case NUL:\n    EMSG_RET_FAIL(_(e_nul_found));\n\n  case Magic('^'):\n    EMIT(NFA_BOL);\n    break;\n\n  case Magic('$'):\n    EMIT(NFA_EOL);\n    had_eol = true;\n    break;\n\n  case Magic('<'):\n    EMIT(NFA_BOW);\n    break;\n\n  case Magic('>'):\n    EMIT(NFA_EOW);\n    break;\n\n  case Magic('_'):\n    c = no_Magic(getchr());\n    if (c == NUL)\n      EMSG_RET_FAIL(_(e_nul_found));\n\n    if (c == '^') {             /* \"\\_^\" is start-of-line */\n      EMIT(NFA_BOL);\n      break;\n    }\n    if (c == '$') {             /* \"\\_$\" is end-of-line */\n      EMIT(NFA_EOL);\n      had_eol = true;\n      break;\n    }\n\n    extra = NFA_ADD_NL;\n\n    /* \"\\_[\" is collection plus newline */\n    if (c == '[')\n      goto collection;\n\n  // \"\\_x\" is character class plus newline\n  FALLTHROUGH;\n\n  /*\n   * Character classes.\n   */\n  case Magic('.'):\n  case Magic('i'):\n  case Magic('I'):\n  case Magic('k'):\n  case Magic('K'):\n  case Magic('f'):\n  case Magic('F'):\n  case Magic('p'):\n  case Magic('P'):\n  case Magic('s'):\n  case Magic('S'):\n  case Magic('d'):\n  case Magic('D'):\n  case Magic('x'):\n  case Magic('X'):\n  case Magic('o'):\n  case Magic('O'):\n  case Magic('w'):\n  case Magic('W'):\n  case Magic('h'):\n  case Magic('H'):\n  case Magic('a'):\n  case Magic('A'):\n  case Magic('l'):\n  case Magic('L'):\n  case Magic('u'):\n  case Magic('U'):\n    p = vim_strchr(classchars, no_Magic(c));\n    if (p == NULL) {\n      if (extra == NFA_ADD_NL) {\n        EMSGN(_(e_ill_char_class), c);\n        rc_did_emsg = true;\n        return FAIL;\n      }\n      IEMSGN(\"INTERNAL: Unknown character class char: %\" PRId64, c);\n      return FAIL;\n    }\n    // When '.' is followed by a composing char ignore the dot, so that\n    // the composing char is matched here.\n    if (c == Magic('.') && utf_iscomposing(peekchr())) {\n      old_regparse = regparse;\n      c = getchr();\n      goto nfa_do_multibyte;\n    }\n    EMIT(nfa_classcodes[p - classchars]);\n    if (extra == NFA_ADD_NL) {\n      EMIT(NFA_NEWL);\n      EMIT(NFA_OR);\n      regflags |= RF_HASNL;\n    }\n    break;\n\n  case Magic('n'):\n    if (reg_string) {\n      // In a string \"\\n\" matches a newline character.\n      EMIT(NL);\n    } else {\n      // In buffer text \"\\n\" matches the end of a line.\n      EMIT(NFA_NEWL);\n      regflags |= RF_HASNL;\n    }\n    break;\n\n  case Magic('('):\n    if (nfa_reg(REG_PAREN) == FAIL) {\n      return FAIL;                  // cascaded error\n    }\n    break;\n\n  case Magic('|'):\n  case Magic('&'):\n  case Magic(')'):\n    EMSGN(_(e_misplaced), no_Magic(c));  // -V1037\n    return FAIL;\n\n  case Magic('='):\n  case Magic('?'):\n  case Magic('+'):\n  case Magic('@'):\n  case Magic('*'):\n  case Magic('{'):\n    // these should follow an atom, not form an atom\n    EMSGN(_(e_misplaced), no_Magic(c));\n    return FAIL;\n\n  case Magic('~'):\n  {\n    char_u      *lp;\n\n    // Previous substitute pattern.\n    // Generated as \"\\%(pattern\\)\".\n    if (reg_prev_sub == NULL) {\n      EMSG(_(e_nopresub));\n      return FAIL;\n    }\n    for (lp = reg_prev_sub; *lp != NUL; MB_CPTR_ADV(lp)) {\n      EMIT(PTR2CHAR(lp));\n      if (lp != reg_prev_sub)\n        EMIT(NFA_CONCAT);\n    }\n    EMIT(NFA_NOPEN);\n    break;\n  }\n\n  case Magic('1'):\n  case Magic('2'):\n  case Magic('3'):\n  case Magic('4'):\n  case Magic('5'):\n  case Magic('6'):\n  case Magic('7'):\n  case Magic('8'):\n  case Magic('9'):\n    {\n      int refnum = no_Magic(c) - '1';\n\n      if (!seen_endbrace(refnum + 1)) {\n          return FAIL;\n      }\n      EMIT(NFA_BACKREF1 + refnum);\n      rex.nfa_has_backref = true;\n    }\n    break;\n\n  case Magic('z'):\n    c = no_Magic(getchr());\n    switch (c) {\n    case 's':\n      EMIT(NFA_ZSTART);\n      if (!re_mult_next(\"\\\\zs\")) {\n        return false;\n      }\n      break;\n    case 'e':\n      EMIT(NFA_ZEND);\n      rex.nfa_has_zend = true;\n      if (!re_mult_next(\"\\\\zs\")) {\n        return false;\n      }\n      break;\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n      // \\z1...\\z9\n      if ((reg_do_extmatch & REX_USE) == 0) {\n        EMSG_RET_FAIL(_(e_z1_not_allowed));\n      }\n      EMIT(NFA_ZREF1 + (no_Magic(c) - '1'));\n      // No need to set rex.nfa_has_backref, the sub-matches don't\n      // change when \\z1 .. \\z9 matches or not.\n      re_has_z = REX_USE;\n      break;\n    case '(':\n      // \\z(\n      if (reg_do_extmatch != REX_SET) {\n        EMSG_RET_FAIL(_(e_z_not_allowed));\n      }\n      if (nfa_reg(REG_ZPAREN) == FAIL) {\n        return FAIL;                        // cascaded error\n      }\n      re_has_z = REX_SET;\n      break;\n    default:\n      emsgf(_(\"E867: (NFA) Unknown operator '\\\\z%c'\"),\n            no_Magic(c));\n      return FAIL;\n    }\n    break;\n\n  case Magic('%'):\n    c = no_Magic(getchr());\n    switch (c) {\n    /* () without a back reference */\n    case '(':\n      if (nfa_reg(REG_NPAREN) == FAIL)\n        return FAIL;\n      EMIT(NFA_NOPEN);\n      break;\n\n    case 'd':               /* %d123 decimal */\n    case 'o':               /* %o123 octal */\n    case 'x':               /* %xab hex 2 */\n    case 'u':               /* %uabcd hex 4 */\n    case 'U':               /* %U1234abcd hex 8 */\n    {\n      int64_t nr;\n\n      switch (c) {\n      case 'd': nr = getdecchrs(); break;\n      case 'o': nr = getoctchrs(); break;\n      case 'x': nr = gethexchrs(2); break;\n      case 'u': nr = gethexchrs(4); break;\n      case 'U': nr = gethexchrs(8); break;\n      default:  nr = -1; break;\n      }\n\n      if (nr < 0 || nr > INT_MAX) {\n        EMSG2_RET_FAIL(_(\"E678: Invalid character after %s%%[dxouU]\"),\n                       reg_magic == MAGIC_ALL);\n      }\n      // A NUL is stored in the text as NL\n      // TODO(vim): what if a composing character follows?\n      EMIT(nr == 0 ? 0x0a : nr);\n    }\n    break;\n\n    /* Catch \\%^ and \\%$ regardless of where they appear in the\n     * pattern -- regardless of whether or not it makes sense. */\n    case '^':\n      EMIT(NFA_BOF);\n      break;\n\n    case '$':\n      EMIT(NFA_EOF);\n      break;\n\n    case '#':\n      EMIT(NFA_CURSOR);\n      break;\n\n    case 'V':\n      EMIT(NFA_VISUAL);\n      break;\n\n    case 'C':\n      EMIT(NFA_ANY_COMPOSING);\n      break;\n\n    case '[':\n    {\n      int n;\n\n      /* \\%[abc] */\n      for (n = 0; (c = peekchr()) != ']'; ++n) {\n        if (c == NUL)\n          EMSG2_RET_FAIL(_(e_missing_sb),\n              reg_magic == MAGIC_ALL);\n        /* recursive call! */\n        if (nfa_regatom() == FAIL)\n          return FAIL;\n      }\n      (void)getchr();  // get the ]\n      if (n == 0) {\n        EMSG2_RET_FAIL(_(e_empty_sb), reg_magic == MAGIC_ALL);\n      }\n      EMIT(NFA_OPT_CHARS);\n      EMIT(n);\n\n      /* Emit as \"\\%(\\%[abc]\\)\" to be able to handle\n       * \"\\%[abc]*\" which would cause the empty string to be\n       * matched an unlimited number of times. NFA_NOPEN is\n       * added only once at a position, while NFA_SPLIT is\n       * added multiple times.  This is more efficient than\n       * not allowing NFA_SPLIT multiple times, it is used\n       * a lot. */\n      EMIT(NFA_NOPEN);\n      break;\n    }\n\n    default:\n    {\n      int64_t n = 0;\n      const int cmp = c;\n\n      if (c == '<' || c == '>')\n        c = getchr();\n      while (ascii_isdigit(c)) {\n        if (n > (INT32_MAX - (c - '0')) / 10) {\n          // overflow.\n          EMSG(_(e_value_too_large));\n          return FAIL;\n        }\n        n = n * 10 + (c - '0');\n        c = getchr();\n      }\n      if (c == 'l' || c == 'c' || c == 'v') {\n        int32_t limit = INT32_MAX;\n\n        if (c == 'l') {\n          // \\%{n}l  \\%{n}<l  \\%{n}>l\n          EMIT(cmp == '<' ? NFA_LNUM_LT :\n               cmp == '>' ? NFA_LNUM_GT : NFA_LNUM);\n          if (save_prev_at_start) {\n            at_start = true;\n          }\n        } else if (c == 'c') {\n          // \\%{n}c  \\%{n}<c  \\%{n}>c\n          EMIT(cmp == '<' ? NFA_COL_LT :\n               cmp == '>' ? NFA_COL_GT : NFA_COL);\n        } else {\n          // \\%{n}v  \\%{n}<v  \\%{n}>v\n          EMIT(cmp == '<' ? NFA_VCOL_LT :\n               cmp == '>' ? NFA_VCOL_GT : NFA_VCOL);\n          limit = INT32_MAX / MB_MAXBYTES;\n        }\n        if (n >= limit) {\n          EMSG(_(e_value_too_large));\n          return FAIL;\n        }\n        EMIT((int)n);\n        break;\n      } else if (c == '\\'' && n == 0) {\n        /* \\%'m  \\%<'m  \\%>'m  */\n        EMIT(cmp == '<' ? NFA_MARK_LT :\n            cmp == '>' ? NFA_MARK_GT : NFA_MARK);\n        EMIT(getchr());\n        break;\n      }\n    }\n      emsgf(_(\"E867: (NFA) Unknown operator '\\\\%%%c'\"),\n            no_Magic(c));\n      return FAIL;\n    }\n    break;\n\n  case Magic('['):\ncollection:\n    /*\n     * [abc]  uses NFA_START_COLL - NFA_END_COLL\n     * [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL\n     * Each character is produced as a regular state, using\n     * NFA_CONCAT to bind them together.\n     * Besides normal characters there can be:\n     * - character classes  NFA_CLASS_*\n     * - ranges, two characters followed by NFA_RANGE.\n     */\n\n    p = regparse;\n    endp = skip_anyof(p);\n    if (*endp == ']') {\n      /*\n       * Try to reverse engineer character classes. For example,\n       * recognize that [0-9] stands for \\d and [A-Za-z_] for \\h,\n       * and perform the necessary substitutions in the NFA.\n       */\n      int result = nfa_recognize_char_class(regparse, endp,\n                                            extra == NFA_ADD_NL);\n      if (result != FAIL) {\n        if (result >= NFA_FIRST_NL && result <= NFA_LAST_NL) {\n          EMIT(result - NFA_ADD_NL);\n          EMIT(NFA_NEWL);\n          EMIT(NFA_OR);\n        } else\n          EMIT(result);\n        regparse = endp;\n        MB_PTR_ADV(regparse);\n        return OK;\n      }\n      /*\n       * Failed to recognize a character class. Use the simple\n       * version that turns [abc] into 'a' OR 'b' OR 'c'\n       */\n      startc = -1;\n      negated = false;\n      if (*regparse == '^') {                           // negated range\n        negated = true;\n        MB_PTR_ADV(regparse);\n        EMIT(NFA_START_NEG_COLL);\n      } else\n        EMIT(NFA_START_COLL);\n      if (*regparse == '-') {\n        startc = '-';\n        EMIT(startc);\n        EMIT(NFA_CONCAT);\n        MB_PTR_ADV(regparse);\n      }\n      // Emit the OR branches for each character in the []\n      emit_range = false;\n      while (regparse < endp) {\n        int oldstartc = startc;\n        startc = -1;\n        got_coll_char = false;\n        if (*regparse == '[') {\n          /* Check for [: :], [= =], [. .] */\n          equiclass = collclass = 0;\n          charclass = get_char_class(&regparse);\n          if (charclass == CLASS_NONE) {\n            equiclass = get_equi_class(&regparse);\n            if (equiclass == 0)\n              collclass = get_coll_element(&regparse);\n          }\n\n          /* Character class like [:alpha:]  */\n          if (charclass != CLASS_NONE) {\n            switch (charclass) {\n            case CLASS_ALNUM:\n              EMIT(NFA_CLASS_ALNUM);\n              break;\n            case CLASS_ALPHA:\n              EMIT(NFA_CLASS_ALPHA);\n              break;\n            case CLASS_BLANK:\n              EMIT(NFA_CLASS_BLANK);\n              break;\n            case CLASS_CNTRL:\n              EMIT(NFA_CLASS_CNTRL);\n              break;\n            case CLASS_DIGIT:\n              EMIT(NFA_CLASS_DIGIT);\n              break;\n            case CLASS_GRAPH:\n              EMIT(NFA_CLASS_GRAPH);\n              break;\n            case CLASS_LOWER:\n              wants_nfa = true;\n              EMIT(NFA_CLASS_LOWER);\n              break;\n            case CLASS_PRINT:\n              EMIT(NFA_CLASS_PRINT);\n              break;\n            case CLASS_PUNCT:\n              EMIT(NFA_CLASS_PUNCT);\n              break;\n            case CLASS_SPACE:\n              EMIT(NFA_CLASS_SPACE);\n              break;\n            case CLASS_UPPER:\n              wants_nfa = true;\n              EMIT(NFA_CLASS_UPPER);\n              break;\n            case CLASS_XDIGIT:\n              EMIT(NFA_CLASS_XDIGIT);\n              break;\n            case CLASS_TAB:\n              EMIT(NFA_CLASS_TAB);\n              break;\n            case CLASS_RETURN:\n              EMIT(NFA_CLASS_RETURN);\n              break;\n            case CLASS_BACKSPACE:\n              EMIT(NFA_CLASS_BACKSPACE);\n              break;\n            case CLASS_ESCAPE:\n              EMIT(NFA_CLASS_ESCAPE);\n              break;\n            case CLASS_IDENT:\n              EMIT(NFA_CLASS_IDENT);\n              break;\n            case CLASS_KEYWORD:\n              EMIT(NFA_CLASS_KEYWORD);\n              break;\n            case CLASS_FNAME:\n              EMIT(NFA_CLASS_FNAME);\n              break;\n            }\n            EMIT(NFA_CONCAT);\n            continue;\n          }\n          /* Try equivalence class [=a=] and the like */\n          if (equiclass != 0) {\n            nfa_emit_equi_class(equiclass);\n            continue;\n          }\n          /* Try collating class like [. .]  */\n          if (collclass != 0) {\n            startc = collclass;                  /* allow [.a.]-x as a range */\n            /* Will emit the proper atom at the end of the\n             * while loop. */\n          }\n        }\n        /* Try a range like 'a-x' or '\\t-z'. Also allows '-' as a\n         * start character. */\n        if (*regparse == '-' && oldstartc != -1) {\n          emit_range = true;\n          startc = oldstartc;\n          MB_PTR_ADV(regparse);\n          continue;                         // reading the end of the range\n        }\n\n        /* Now handle simple and escaped characters.\n         * Only \"\\]\", \"\\^\", \"\\]\" and \"\\\\\" are special in Vi.  Vim\n         * accepts \"\\t\", \"\\e\", etc., but only when the 'l' flag in\n         * 'cpoptions' is not included.\n         */\n        if (*regparse == '\\\\'\n            && regparse + 1 <= endp\n            && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL\n                || (!reg_cpo_lit\n                    && vim_strchr(REGEXP_ABBR, regparse[1])\n                    != NULL)\n                )\n            ) {\n          MB_PTR_ADV(regparse);\n\n          if (*regparse == 'n') {\n            startc = (reg_string || emit_range || regparse[1] == '-')\n              ? NL : NFA_NEWL;\n          } else if  (*regparse == 'd'\n                      || *regparse == 'o'\n                      || *regparse == 'x'\n                      || *regparse == 'u'\n                      || *regparse == 'U'\n                      ) {\n            // TODO(RE): This needs more testing\n            startc = coll_get_char();\n            got_coll_char = true;\n            MB_PTR_BACK(old_regparse, regparse);\n          } else {\n            /* \\r,\\t,\\e,\\b */\n            startc = backslash_trans(*regparse);\n          }\n        }\n\n        /* Normal printable char */\n        if (startc == -1)\n          startc = PTR2CHAR(regparse);\n\n        /* Previous char was '-', so this char is end of range. */\n        if (emit_range) {\n          int endc = startc;\n          startc = oldstartc;\n          if (startc > endc) {\n            EMSG_RET_FAIL(_(e_reverse_range));\n          }\n\n          if (endc > startc + 2) {\n            /* Emit a range instead of the sequence of\n             * individual characters. */\n            if (startc == 0)\n              /* \\x00 is translated to \\x0a, start at \\x01. */\n              EMIT(1);\n            else\n              --post_ptr;                   /* remove NFA_CONCAT */\n            EMIT(endc);\n            EMIT(NFA_RANGE);\n            EMIT(NFA_CONCAT);\n          } else if ((*mb_char2len)(startc) > 1\n                     || (*mb_char2len)(endc) > 1) {\n            // Emit the characters in the range.\n            // \"startc\" was already emitted, so skip it.\n            for (c = startc + 1; c <= endc; c++) {\n              EMIT(c);\n              EMIT(NFA_CONCAT);\n            }\n          } else {\n            /* Emit the range. \"startc\" was already emitted, so\n             * skip it. */\n            for (c = startc + 1; c <= endc; c++) {\n              EMIT(c);\n              EMIT(NFA_CONCAT);\n            }\n          }\n          emit_range = false;\n          startc = -1;\n        } else {\n          /* This char (startc) is not part of a range. Just\n           * emit it.\n           * Normally, simply emit startc. But if we get char\n           * code=0 from a collating char, then replace it with\n           * 0x0a.\n           * This is needed to completely mimic the behaviour of\n           * the backtracking engine. */\n          if (startc == NFA_NEWL) {\n            /* Line break can't be matched as part of the\n             * collection, add an OR below. But not for negated\n             * range. */\n            if (!negated)\n              extra = NFA_ADD_NL;\n          } else {\n            if (got_coll_char == true && startc == 0) {\n              EMIT(0x0a);\n            } else {\n              EMIT(startc);\n            }\n            EMIT(NFA_CONCAT);\n          }\n        }\n\n        MB_PTR_ADV(regparse);\n      }           // while (p < endp)\n\n      MB_PTR_BACK(old_regparse, regparse);\n      if (*regparse == '-') {               // if last, '-' is just a char\n        EMIT('-');\n        EMIT(NFA_CONCAT);\n      }\n\n      /* skip the trailing ] */\n      regparse = endp;\n      MB_PTR_ADV(regparse);\n\n      // Mark end of the collection.\n      if (negated == true) {\n        EMIT(NFA_END_NEG_COLL);\n      } else {\n        EMIT(NFA_END_COLL);\n      }\n\n      // \\_[] also matches \\n but it's not negated\n      if (extra == NFA_ADD_NL) {\n        EMIT(reg_string ? NL : NFA_NEWL);\n        EMIT(NFA_OR);\n      }\n\n      return OK;\n    }         /* if exists closing ] */\n\n    if (reg_strict)\n      EMSG_RET_FAIL(_(e_missingbracket));\n    FALLTHROUGH;\n\n  default:\n  {\n    int plen;\n\nnfa_do_multibyte:\n    // plen is length of current char with composing chars\n    if ((*mb_char2len)(c) != (plen = utfc_ptr2len(old_regparse))\n        || utf_iscomposing(c)) {\n      int i = 0;\n\n      /* A base character plus composing characters, or just one\n       * or more composing characters.\n       * This requires creating a separate atom as if enclosing\n       * the characters in (), where NFA_COMPOSING is the ( and\n       * NFA_END_COMPOSING is the ). Note that right now we are\n       * building the postfix form, not the NFA itself;\n       * a composing char could be: a, b, c, NFA_COMPOSING\n       * where 'b' and 'c' are chars with codes > 256. */\n      for (;; ) {\n        EMIT(c);\n        if (i > 0)\n          EMIT(NFA_CONCAT);\n        if ((i += utf_char2len(c)) >= plen)\n          break;\n        c = utf_ptr2char(old_regparse + i);\n      }\n      EMIT(NFA_COMPOSING);\n      regparse = old_regparse + plen;\n    } else {\n      c = no_Magic(c);\n      EMIT(c);\n    }\n    return OK;\n  }\n  }\n\n  return OK;\n}\n\n/*\n * Parse something followed by possible [*+=].\n *\n * A piece is an atom, possibly followed by a multi, an indication of how many\n * times the atom can be matched.  Example: \"a*\" matches any sequence of \"a\"\n * characters: \"\", \"a\", \"aa\", etc.\n *\n * piece   ::=\t    atom\n *\tor  atom  multi\n */\nstatic int nfa_regpiece(void)\n{\n  int i;\n  int op;\n  int ret;\n  long minval, maxval;\n  bool greedy = true;  // Braces are prefixed with '-' ?\n  parse_state_T old_state;\n  parse_state_T new_state;\n  int64_t c2;\n  int old_post_pos;\n  int my_post_start;\n  int quest;\n\n  /* Save the current parse state, so that we can use it if <atom>{m,n} is\n   * next. */\n  save_parse_state(&old_state);\n\n  /* store current pos in the postfix form, for \\{m,n} involving 0s */\n  my_post_start = (int)(post_ptr - post_start);\n\n  ret = nfa_regatom();\n  if (ret == FAIL)\n    return FAIL;            /* cascaded error */\n\n  op = peekchr();\n  if (re_multi_type(op) == NOT_MULTI)\n    return OK;\n\n  skipchr();\n  switch (op) {\n  case Magic('*'):\n    EMIT(NFA_STAR);\n    break;\n\n  case Magic('+'):\n    /*\n     * Trick: Normally, (a*)\\+ would match the whole input \"aaa\".  The\n     * first and only submatch would be \"aaa\". But the backtracking\n     * engine interprets the plus as \"try matching one more time\", and\n     * a* matches a second time at the end of the input, the empty\n     * string.\n     * The submatch will be the empty string.\n     *\n     * In order to be consistent with the old engine, we replace\n     * <atom>+ with <atom><atom>*\n     */\n    restore_parse_state(&old_state);\n    curchr = -1;\n    if (nfa_regatom() == FAIL)\n      return FAIL;\n    EMIT(NFA_STAR);\n    EMIT(NFA_CONCAT);\n    skipchr();                  /* skip the \\+\t*/\n    break;\n\n  case Magic('@'):\n    c2 = getdecchrs();\n    op = no_Magic(getchr());\n    i = 0;\n    switch(op) {\n    case '=':\n      /* \\@= */\n      i = NFA_PREV_ATOM_NO_WIDTH;\n      break;\n    case '!':\n      /* \\@! */\n      i = NFA_PREV_ATOM_NO_WIDTH_NEG;\n      break;\n    case '<':\n      op = no_Magic(getchr());\n      if (op == '=')\n        /* \\@<= */\n        i = NFA_PREV_ATOM_JUST_BEFORE;\n      else if (op == '!')\n        /* \\@<! */\n        i = NFA_PREV_ATOM_JUST_BEFORE_NEG;\n      break;\n    case '>':\n      /* \\@>  */\n      i = NFA_PREV_ATOM_LIKE_PATTERN;\n      break;\n    }\n    if (i == 0) {\n      emsgf(_(\"E869: (NFA) Unknown operator '\\\\@%c'\"), op);\n      return FAIL;\n    }\n    EMIT(i);\n    if (i == NFA_PREV_ATOM_JUST_BEFORE\n        || i == NFA_PREV_ATOM_JUST_BEFORE_NEG)\n      EMIT(c2);\n    break;\n\n  case Magic('?'):\n  case Magic('='):\n    EMIT(NFA_QUEST);\n    break;\n\n  case Magic('{'):\n    /* a{2,5} will expand to 'aaa?a?a?'\n     * a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy\n     * version of '?'\n     * \\v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the\n     * parenthesis have the same id\n     */\n\n    greedy = true;\n    c2 = peekchr();\n    if (c2 == '-' || c2 == Magic('-')) {\n      skipchr();\n      greedy = false;\n    }\n    if (!read_limits(&minval, &maxval))\n      EMSG_RET_FAIL(_(\"E870: (NFA regexp) Error reading repetition limits\"));\n\n    /*  <atom>{0,inf}, <atom>{0,} and <atom>{}  are equivalent to\n     *  <atom>*  */\n    if (minval == 0 && maxval == MAX_LIMIT) {\n      if (greedy)\n        /* \\{}, \\{0,} */\n        EMIT(NFA_STAR);\n      else\n        /* \\{-}, \\{-0,} */\n        EMIT(NFA_STAR_NONGREEDY);\n      break;\n    }\n\n    /* Special case: x{0} or x{-0} */\n    if (maxval == 0) {\n      /* Ignore result of previous call to nfa_regatom() */\n      post_ptr = post_start + my_post_start;\n      /* NFA_EMPTY is 0-length and works everywhere */\n      EMIT(NFA_EMPTY);\n      return OK;\n    }\n\n    // The engine is very inefficient (uses too many states) when the\n    // maximum is much larger than the minimum and when the maximum is\n    // large.  However, when maxval is MAX_LIMIT, it is okay, as this\n    // will emit NFA_STAR.\n    // Bail out if we can use the other engine, but only, when the\n    // pattern does not need the NFA engine like (e.g. [[:upper:]]\\{2,\\}\n    // does not work with with characters > 8 bit with the BT engine)\n    if ((nfa_re_flags & RE_AUTO)\n        && (maxval > 500 || maxval > minval + 200)\n        && (maxval != MAX_LIMIT && minval < 200)\n        && !wants_nfa) {\n      return FAIL;\n    }\n\n    /* Ignore previous call to nfa_regatom() */\n    post_ptr = post_start + my_post_start;\n    /* Save parse state after the repeated atom and the \\{} */\n    save_parse_state(&new_state);\n\n    quest = (greedy == true ? NFA_QUEST : NFA_QUEST_NONGREEDY);\n    for (i = 0; i < maxval; i++) {\n      /* Goto beginning of the repeated atom */\n      restore_parse_state(&old_state);\n      old_post_pos = (int)(post_ptr - post_start);\n      if (nfa_regatom() == FAIL)\n        return FAIL;\n      /* after \"minval\" times, atoms are optional */\n      if (i + 1 > minval) {\n        if (maxval == MAX_LIMIT) {\n          if (greedy)\n            EMIT(NFA_STAR);\n          else\n            EMIT(NFA_STAR_NONGREEDY);\n        } else\n          EMIT(quest);\n      }\n      if (old_post_pos != my_post_start)\n        EMIT(NFA_CONCAT);\n      if (i + 1 > minval && maxval == MAX_LIMIT)\n        break;\n    }\n\n    /* Go to just after the repeated atom and the \\{} */\n    restore_parse_state(&new_state);\n    curchr = -1;\n\n    break;\n\n\n  default:\n    break;\n  }     /* end switch */\n\n  if (re_multi_type(peekchr()) != NOT_MULTI) {\n    // Can't have a multi follow a multi.\n    EMSG_RET_FAIL(_(\"E871: (NFA regexp) Can't have a multi follow a multi\"));\n  }\n\n  return OK;\n}\n\n/*\n * Parse one or more pieces, concatenated.  It matches a match for the\n * first piece, followed by a match for the second piece, etc.  Example:\n * \"f[0-9]b\", first matches \"f\", then a digit and then \"b\".\n *\n * concat  ::=\t    piece\n *\tor  piece piece\n *\tor  piece piece piece\n *\tetc.\n */\nstatic int nfa_regconcat(void)\n{\n  bool cont = true;\n  bool first = true;\n\n  while (cont) {\n    switch (peekchr()) {\n    case NUL:\n    case Magic('|'):\n    case Magic('&'):\n    case Magic(')'):\n      cont = false;\n      break;\n\n    case Magic('Z'):\n      regflags |= RF_ICOMBINE;\n      skipchr_keepstart();\n      break;\n    case Magic('c'):\n      regflags |= RF_ICASE;\n      skipchr_keepstart();\n      break;\n    case Magic('C'):\n      regflags |= RF_NOICASE;\n      skipchr_keepstart();\n      break;\n    case Magic('v'):\n      reg_magic = MAGIC_ALL;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n    case Magic('m'):\n      reg_magic = MAGIC_ON;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n    case Magic('M'):\n      reg_magic = MAGIC_OFF;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n    case Magic('V'):\n      reg_magic = MAGIC_NONE;\n      skipchr_keepstart();\n      curchr = -1;\n      break;\n\n    default:\n      if (nfa_regpiece() == FAIL) {\n        return FAIL;\n      }\n      if (first == false) {\n        EMIT(NFA_CONCAT);\n      } else {\n        first = false;\n      }\n      break;\n    }\n  }\n\n  return OK;\n}\n\n/*\n * Parse a branch, one or more concats, separated by \"\\&\".  It matches the\n * last concat, but only if all the preceding concats also match at the same\n * position.  Examples:\n *      \"foobeep\\&...\" matches \"foo\" in \"foobeep\".\n *      \".*Peter\\&.*Bob\" matches in a line containing both \"Peter\" and \"Bob\"\n *\n * branch ::=\t    concat\n *\t\tor  concat \\& concat\n *\t\tor  concat \\& concat \\& concat\n *\t\tetc.\n */\nstatic int nfa_regbranch(void)\n{\n  int old_post_pos;\n\n  old_post_pos = (int)(post_ptr - post_start);\n\n  /* First branch, possibly the only one */\n  if (nfa_regconcat() == FAIL)\n    return FAIL;\n\n  // Try next concats\n  while (peekchr() == Magic('&')) {\n    skipchr();\n    // if concat is empty do emit a node\n    if (old_post_pos == (int)(post_ptr - post_start)) {\n      EMIT(NFA_EMPTY);\n    }\n    EMIT(NFA_NOPEN);\n    EMIT(NFA_PREV_ATOM_NO_WIDTH);\n    old_post_pos = (int)(post_ptr - post_start);\n    if (nfa_regconcat() == FAIL)\n      return FAIL;\n    /* if concat is empty do emit a node */\n    if (old_post_pos == (int)(post_ptr - post_start))\n      EMIT(NFA_EMPTY);\n    EMIT(NFA_CONCAT);\n  }\n\n  /* if a branch is empty, emit one node for it */\n  if (old_post_pos == (int)(post_ptr - post_start))\n    EMIT(NFA_EMPTY);\n\n  return OK;\n}\n\n/*\n *  Parse a pattern, one or more branches, separated by \"\\|\".  It matches\n *  anything that matches one of the branches.  Example: \"foo\\|beep\" matches\n *  \"foo\" and matches \"beep\".  If more than one branch matches, the first one\n *  is used.\n *\n *  pattern ::=\t    branch\n *\tor  branch \\| branch\n *\tor  branch \\| branch \\| branch\n *\tetc.\n */\nstatic int \nnfa_reg (\n    int paren              /* REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN */\n)\n{\n  int parno = 0;\n\n  if (paren == REG_PAREN) {\n    if (regnpar >= NSUBEXP)     /* Too many `(' */\n      EMSG_RET_FAIL(_(\"E872: (NFA regexp) Too many '('\"));\n    parno = regnpar++;\n  } else if (paren == REG_ZPAREN) {\n    /* Make a ZOPEN node. */\n    if (regnzpar >= NSUBEXP)\n      EMSG_RET_FAIL(_(\"E879: (NFA regexp) Too many \\\\z(\"));\n    parno = regnzpar++;\n  }\n\n  if (nfa_regbranch() == FAIL)\n    return FAIL;            /* cascaded error */\n\n  while (peekchr() == Magic('|')) {\n    skipchr();\n    if (nfa_regbranch() == FAIL)\n      return FAIL;          /* cascaded error */\n    EMIT(NFA_OR);\n  }\n\n  /* Check for proper termination. */\n  if (paren != REG_NOPAREN && getchr() != Magic(')')) {\n    if (paren == REG_NPAREN)\n      EMSG2_RET_FAIL(_(e_unmatchedpp), reg_magic == MAGIC_ALL);\n    else\n      EMSG2_RET_FAIL(_(e_unmatchedp), reg_magic == MAGIC_ALL);\n  } else if (paren == REG_NOPAREN && peekchr() != NUL) {\n    if (peekchr() == Magic(')'))\n      EMSG2_RET_FAIL(_(e_unmatchedpar), reg_magic == MAGIC_ALL);\n    else\n      EMSG_RET_FAIL(_(\"E873: (NFA regexp) proper termination error\"));\n  }\n  // Here we set the flag allowing back references to this set of\n  // parentheses.\n  if (paren == REG_PAREN) {\n    had_endbrace[parno] = true;  // have seen the close paren\n    EMIT(NFA_MOPEN + parno);\n  } else if (paren == REG_ZPAREN) {\n    EMIT(NFA_ZOPEN + parno);\n  }\n\n  return OK;\n}\n\n#ifdef REGEXP_DEBUG\nstatic char_u code[50];\n\nstatic void nfa_set_code(int c)\n{\n  int addnl = false;\n\n  if (c >= NFA_FIRST_NL && c <= NFA_LAST_NL) {\n    addnl = true;\n    c -= NFA_ADD_NL;\n  }\n\n  STRCPY(code, \"\");\n  switch (c) {\n  case NFA_MATCH:     STRCPY(code, \"NFA_MATCH \"); break;\n  case NFA_SPLIT:     STRCPY(code, \"NFA_SPLIT \"); break;\n  case NFA_CONCAT:    STRCPY(code, \"NFA_CONCAT \"); break;\n  case NFA_NEWL:      STRCPY(code, \"NFA_NEWL \"); break;\n  case NFA_ZSTART:    STRCPY(code, \"NFA_ZSTART\"); break;\n  case NFA_ZEND:      STRCPY(code, \"NFA_ZEND\"); break;\n\n  case NFA_BACKREF1:  STRCPY(code, \"NFA_BACKREF1\"); break;\n  case NFA_BACKREF2:  STRCPY(code, \"NFA_BACKREF2\"); break;\n  case NFA_BACKREF3:  STRCPY(code, \"NFA_BACKREF3\"); break;\n  case NFA_BACKREF4:  STRCPY(code, \"NFA_BACKREF4\"); break;\n  case NFA_BACKREF5:  STRCPY(code, \"NFA_BACKREF5\"); break;\n  case NFA_BACKREF6:  STRCPY(code, \"NFA_BACKREF6\"); break;\n  case NFA_BACKREF7:  STRCPY(code, \"NFA_BACKREF7\"); break;\n  case NFA_BACKREF8:  STRCPY(code, \"NFA_BACKREF8\"); break;\n  case NFA_BACKREF9:  STRCPY(code, \"NFA_BACKREF9\"); break;\n  case NFA_ZREF1:     STRCPY(code, \"NFA_ZREF1\"); break;\n  case NFA_ZREF2:     STRCPY(code, \"NFA_ZREF2\"); break;\n  case NFA_ZREF3:     STRCPY(code, \"NFA_ZREF3\"); break;\n  case NFA_ZREF4:     STRCPY(code, \"NFA_ZREF4\"); break;\n  case NFA_ZREF5:     STRCPY(code, \"NFA_ZREF5\"); break;\n  case NFA_ZREF6:     STRCPY(code, \"NFA_ZREF6\"); break;\n  case NFA_ZREF7:     STRCPY(code, \"NFA_ZREF7\"); break;\n  case NFA_ZREF8:     STRCPY(code, \"NFA_ZREF8\"); break;\n  case NFA_ZREF9:     STRCPY(code, \"NFA_ZREF9\"); break;\n  case NFA_SKIP:      STRCPY(code, \"NFA_SKIP\"); break;\n\n  case NFA_PREV_ATOM_NO_WIDTH:\n    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH\"); break;\n  case NFA_PREV_ATOM_NO_WIDTH_NEG:\n    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH_NEG\"); break;\n  case NFA_PREV_ATOM_JUST_BEFORE:\n    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE\"); break;\n  case NFA_PREV_ATOM_JUST_BEFORE_NEG:\n    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE_NEG\"); break;\n  case NFA_PREV_ATOM_LIKE_PATTERN:\n    STRCPY(code, \"NFA_PREV_ATOM_LIKE_PATTERN\"); break;\n\n  case NFA_NOPEN:             STRCPY(code, \"NFA_NOPEN\"); break;\n  case NFA_NCLOSE:            STRCPY(code, \"NFA_NCLOSE\"); break;\n  case NFA_START_INVISIBLE:   STRCPY(code, \"NFA_START_INVISIBLE\"); break;\n  case NFA_START_INVISIBLE_FIRST:\n    STRCPY(code, \"NFA_START_INVISIBLE_FIRST\"); break;\n  case NFA_START_INVISIBLE_NEG:\n    STRCPY(code, \"NFA_START_INVISIBLE_NEG\"); break;\n  case NFA_START_INVISIBLE_NEG_FIRST:\n    STRCPY(code, \"NFA_START_INVISIBLE_NEG_FIRST\"); break;\n  case NFA_START_INVISIBLE_BEFORE:\n    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE\"); break;\n  case NFA_START_INVISIBLE_BEFORE_FIRST:\n    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_FIRST\"); break;\n  case NFA_START_INVISIBLE_BEFORE_NEG:\n    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG\"); break;\n  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG_FIRST\"); break;\n  case NFA_START_PATTERN:   STRCPY(code, \"NFA_START_PATTERN\"); break;\n  case NFA_END_INVISIBLE:     STRCPY(code, \"NFA_END_INVISIBLE\"); break;\n  case NFA_END_INVISIBLE_NEG: STRCPY(code, \"NFA_END_INVISIBLE_NEG\"); break;\n  case NFA_END_PATTERN:       STRCPY(code, \"NFA_END_PATTERN\"); break;\n\n  case NFA_COMPOSING:         STRCPY(code, \"NFA_COMPOSING\"); break;\n  case NFA_END_COMPOSING:     STRCPY(code, \"NFA_END_COMPOSING\"); break;\n  case NFA_OPT_CHARS:         STRCPY(code, \"NFA_OPT_CHARS\"); break;\n\n  case NFA_MOPEN:\n  case NFA_MOPEN1:\n  case NFA_MOPEN2:\n  case NFA_MOPEN3:\n  case NFA_MOPEN4:\n  case NFA_MOPEN5:\n  case NFA_MOPEN6:\n  case NFA_MOPEN7:\n  case NFA_MOPEN8:\n  case NFA_MOPEN9:\n    STRCPY(code, \"NFA_MOPEN(x)\");\n    code[10] = c - NFA_MOPEN + '0';\n    break;\n  case NFA_MCLOSE:\n  case NFA_MCLOSE1:\n  case NFA_MCLOSE2:\n  case NFA_MCLOSE3:\n  case NFA_MCLOSE4:\n  case NFA_MCLOSE5:\n  case NFA_MCLOSE6:\n  case NFA_MCLOSE7:\n  case NFA_MCLOSE8:\n  case NFA_MCLOSE9:\n    STRCPY(code, \"NFA_MCLOSE(x)\");\n    code[11] = c - NFA_MCLOSE + '0';\n    break;\n  case NFA_ZOPEN:\n  case NFA_ZOPEN1:\n  case NFA_ZOPEN2:\n  case NFA_ZOPEN3:\n  case NFA_ZOPEN4:\n  case NFA_ZOPEN5:\n  case NFA_ZOPEN6:\n  case NFA_ZOPEN7:\n  case NFA_ZOPEN8:\n  case NFA_ZOPEN9:\n    STRCPY(code, \"NFA_ZOPEN(x)\");\n    code[10] = c - NFA_ZOPEN + '0';\n    break;\n  case NFA_ZCLOSE:\n  case NFA_ZCLOSE1:\n  case NFA_ZCLOSE2:\n  case NFA_ZCLOSE3:\n  case NFA_ZCLOSE4:\n  case NFA_ZCLOSE5:\n  case NFA_ZCLOSE6:\n  case NFA_ZCLOSE7:\n  case NFA_ZCLOSE8:\n  case NFA_ZCLOSE9:\n    STRCPY(code, \"NFA_ZCLOSE(x)\");\n    code[11] = c - NFA_ZCLOSE + '0';\n    break;\n  case NFA_EOL:           STRCPY(code, \"NFA_EOL \"); break;\n  case NFA_BOL:           STRCPY(code, \"NFA_BOL \"); break;\n  case NFA_EOW:           STRCPY(code, \"NFA_EOW \"); break;\n  case NFA_BOW:           STRCPY(code, \"NFA_BOW \"); break;\n  case NFA_EOF:           STRCPY(code, \"NFA_EOF \"); break;\n  case NFA_BOF:           STRCPY(code, \"NFA_BOF \"); break;\n  case NFA_LNUM:          STRCPY(code, \"NFA_LNUM \"); break;\n  case NFA_LNUM_GT:       STRCPY(code, \"NFA_LNUM_GT \"); break;\n  case NFA_LNUM_LT:       STRCPY(code, \"NFA_LNUM_LT \"); break;\n  case NFA_COL:           STRCPY(code, \"NFA_COL \"); break;\n  case NFA_COL_GT:        STRCPY(code, \"NFA_COL_GT \"); break;\n  case NFA_COL_LT:        STRCPY(code, \"NFA_COL_LT \"); break;\n  case NFA_VCOL:          STRCPY(code, \"NFA_VCOL \"); break;\n  case NFA_VCOL_GT:       STRCPY(code, \"NFA_VCOL_GT \"); break;\n  case NFA_VCOL_LT:       STRCPY(code, \"NFA_VCOL_LT \"); break;\n  case NFA_MARK:          STRCPY(code, \"NFA_MARK \"); break;\n  case NFA_MARK_GT:       STRCPY(code, \"NFA_MARK_GT \"); break;\n  case NFA_MARK_LT:       STRCPY(code, \"NFA_MARK_LT \"); break;\n  case NFA_CURSOR:        STRCPY(code, \"NFA_CURSOR \"); break;\n  case NFA_VISUAL:        STRCPY(code, \"NFA_VISUAL \"); break;\n  case NFA_ANY_COMPOSING: STRCPY(code, \"NFA_ANY_COMPOSING \"); break;\n\n  case NFA_STAR:          STRCPY(code, \"NFA_STAR \"); break;\n  case NFA_STAR_NONGREEDY: STRCPY(code, \"NFA_STAR_NONGREEDY \"); break;\n  case NFA_QUEST:         STRCPY(code, \"NFA_QUEST\"); break;\n  case NFA_QUEST_NONGREEDY: STRCPY(code, \"NFA_QUEST_NON_GREEDY\"); break;\n  case NFA_EMPTY:         STRCPY(code, \"NFA_EMPTY\"); break;\n  case NFA_OR:            STRCPY(code, \"NFA_OR\"); break;\n\n  case NFA_START_COLL:    STRCPY(code, \"NFA_START_COLL\"); break;\n  case NFA_END_COLL:      STRCPY(code, \"NFA_END_COLL\"); break;\n  case NFA_START_NEG_COLL: STRCPY(code, \"NFA_START_NEG_COLL\"); break;\n  case NFA_END_NEG_COLL:  STRCPY(code, \"NFA_END_NEG_COLL\"); break;\n  case NFA_RANGE:         STRCPY(code, \"NFA_RANGE\"); break;\n  case NFA_RANGE_MIN:     STRCPY(code, \"NFA_RANGE_MIN\"); break;\n  case NFA_RANGE_MAX:     STRCPY(code, \"NFA_RANGE_MAX\"); break;\n\n  case NFA_CLASS_ALNUM:   STRCPY(code, \"NFA_CLASS_ALNUM\"); break;\n  case NFA_CLASS_ALPHA:   STRCPY(code, \"NFA_CLASS_ALPHA\"); break;\n  case NFA_CLASS_BLANK:   STRCPY(code, \"NFA_CLASS_BLANK\"); break;\n  case NFA_CLASS_CNTRL:   STRCPY(code, \"NFA_CLASS_CNTRL\"); break;\n  case NFA_CLASS_DIGIT:   STRCPY(code, \"NFA_CLASS_DIGIT\"); break;\n  case NFA_CLASS_GRAPH:   STRCPY(code, \"NFA_CLASS_GRAPH\"); break;\n  case NFA_CLASS_LOWER:   STRCPY(code, \"NFA_CLASS_LOWER\"); break;\n  case NFA_CLASS_PRINT:   STRCPY(code, \"NFA_CLASS_PRINT\"); break;\n  case NFA_CLASS_PUNCT:   STRCPY(code, \"NFA_CLASS_PUNCT\"); break;\n  case NFA_CLASS_SPACE:   STRCPY(code, \"NFA_CLASS_SPACE\"); break;\n  case NFA_CLASS_UPPER:   STRCPY(code, \"NFA_CLASS_UPPER\"); break;\n  case NFA_CLASS_XDIGIT:  STRCPY(code, \"NFA_CLASS_XDIGIT\"); break;\n  case NFA_CLASS_TAB:     STRCPY(code, \"NFA_CLASS_TAB\"); break;\n  case NFA_CLASS_RETURN:  STRCPY(code, \"NFA_CLASS_RETURN\"); break;\n  case NFA_CLASS_BACKSPACE:   STRCPY(code, \"NFA_CLASS_BACKSPACE\"); break;\n  case NFA_CLASS_ESCAPE:  STRCPY(code, \"NFA_CLASS_ESCAPE\"); break;\n  case NFA_CLASS_IDENT:   STRCPY(code, \"NFA_CLASS_IDENT\"); break;\n  case NFA_CLASS_KEYWORD: STRCPY(code, \"NFA_CLASS_KEYWORD\"); break;\n  case NFA_CLASS_FNAME:   STRCPY(code, \"NFA_CLASS_FNAME\"); break;\n\n  case NFA_ANY:   STRCPY(code, \"NFA_ANY\"); break;\n  case NFA_IDENT: STRCPY(code, \"NFA_IDENT\"); break;\n  case NFA_SIDENT: STRCPY(code, \"NFA_SIDENT\"); break;\n  case NFA_KWORD: STRCPY(code, \"NFA_KWORD\"); break;\n  case NFA_SKWORD: STRCPY(code, \"NFA_SKWORD\"); break;\n  case NFA_FNAME: STRCPY(code, \"NFA_FNAME\"); break;\n  case NFA_SFNAME: STRCPY(code, \"NFA_SFNAME\"); break;\n  case NFA_PRINT: STRCPY(code, \"NFA_PRINT\"); break;\n  case NFA_SPRINT: STRCPY(code, \"NFA_SPRINT\"); break;\n  case NFA_WHITE: STRCPY(code, \"NFA_WHITE\"); break;\n  case NFA_NWHITE: STRCPY(code, \"NFA_NWHITE\"); break;\n  case NFA_DIGIT: STRCPY(code, \"NFA_DIGIT\"); break;\n  case NFA_NDIGIT: STRCPY(code, \"NFA_NDIGIT\"); break;\n  case NFA_HEX:   STRCPY(code, \"NFA_HEX\"); break;\n  case NFA_NHEX:  STRCPY(code, \"NFA_NHEX\"); break;\n  case NFA_OCTAL: STRCPY(code, \"NFA_OCTAL\"); break;\n  case NFA_NOCTAL: STRCPY(code, \"NFA_NOCTAL\"); break;\n  case NFA_WORD:  STRCPY(code, \"NFA_WORD\"); break;\n  case NFA_NWORD: STRCPY(code, \"NFA_NWORD\"); break;\n  case NFA_HEAD:  STRCPY(code, \"NFA_HEAD\"); break;\n  case NFA_NHEAD: STRCPY(code, \"NFA_NHEAD\"); break;\n  case NFA_ALPHA: STRCPY(code, \"NFA_ALPHA\"); break;\n  case NFA_NALPHA: STRCPY(code, \"NFA_NALPHA\"); break;\n  case NFA_LOWER: STRCPY(code, \"NFA_LOWER\"); break;\n  case NFA_NLOWER: STRCPY(code, \"NFA_NLOWER\"); break;\n  case NFA_UPPER: STRCPY(code, \"NFA_UPPER\"); break;\n  case NFA_NUPPER: STRCPY(code, \"NFA_NUPPER\"); break;\n  case NFA_LOWER_IC:  STRCPY(code, \"NFA_LOWER_IC\"); break;\n  case NFA_NLOWER_IC: STRCPY(code, \"NFA_NLOWER_IC\"); break;\n  case NFA_UPPER_IC:  STRCPY(code, \"NFA_UPPER_IC\"); break;\n  case NFA_NUPPER_IC: STRCPY(code, \"NFA_NUPPER_IC\"); break;\n\n  default:\n    STRCPY(code, \"CHAR(x)\");\n    code[5] = c;\n  }\n\n  if (addnl == true) {\n    STRCAT(code, \" + NEWLINE \");\n  }\n}\n\nstatic FILE *log_fd;\nstatic char_u e_log_open_failed[] = N_(\n    \"Could not open temporary log file for writing, displaying on stderr... \");\n\n/*\n * Print the postfix notation of the current regexp.\n */\nstatic void nfa_postfix_dump(char_u *expr, int retval)\n{\n  int *p;\n  FILE *f;\n\n  f = fopen(NFA_REGEXP_DUMP_LOG, \"a\");\n  if (f != NULL) {\n    fprintf(f, \"\\n-------------------------\\n\");\n    if (retval == FAIL) {\n      fprintf(f, \">>> NFA engine failed... \\n\");\n    } else if (retval == OK) {\n      fprintf(f, \">>> NFA engine succeeded !\\n\");\n    }\n    fprintf(f, \"Regexp: \\\"%s\\\"\\nPostfix notation (char): \\\"\", expr);\n    for (p = post_start; *p && p < post_ptr; p++) {\n      nfa_set_code(*p);\n      fprintf(f, \"%s, \", code);\n    }\n    fprintf(f, \"\\\"\\nPostfix notation (int): \");\n    for (p = post_start; *p && p < post_ptr; p++)\n      fprintf(f, \"%d \", *p);\n    fprintf(f, \"\\n\\n\");\n    fclose(f);\n  }\n}\n\n/*\n * Print the NFA starting with a root node \"state\".\n */\nstatic void nfa_print_state(FILE *debugf, nfa_state_T *state)\n{\n  garray_T indent;\n\n  ga_init(&indent, 1, 64);\n  ga_append(&indent, '\\0');\n  nfa_print_state2(debugf, state, &indent);\n  ga_clear(&indent);\n}\n\nstatic void nfa_print_state2(FILE *debugf, nfa_state_T *state, garray_T *indent)\n{\n  char_u  *p;\n\n  if (state == NULL)\n    return;\n\n  fprintf(debugf, \"(%2d)\", abs(state->id));\n\n  /* Output indent */\n  p = (char_u *)indent->ga_data;\n  if (indent->ga_len >= 3) {\n    int last = indent->ga_len - 3;\n    char_u save[2];\n\n    STRNCPY(save, &p[last], 2);\n    STRNCPY(&p[last], \"+-\", 2);\n    fprintf(debugf, \" %s\", p);\n    STRNCPY(&p[last], save, 2);\n  } else\n    fprintf(debugf, \" %s\", p);\n\n  nfa_set_code(state->c);\n  fprintf(debugf, \"%s (%d) (id=%d) val=%d\\n\",\n      code,\n      state->c,\n      abs(state->id),\n      state->val);\n  if (state->id < 0)\n    return;\n\n  state->id = abs(state->id) * -1;\n\n  /* grow indent for state->out */\n  indent->ga_len -= 1;\n  if (state->out1)\n    ga_concat(indent, (char_u *)\"| \");\n  else\n    ga_concat(indent, (char_u *)\"  \");\n  ga_append(indent, '\\0');\n\n  nfa_print_state2(debugf, state->out, indent);\n\n  /* replace last part of indent for state->out1 */\n  indent->ga_len -= 3;\n  ga_concat(indent, (char_u *)\"  \");\n  ga_append(indent, '\\0');\n\n  nfa_print_state2(debugf, state->out1, indent);\n\n  /* shrink indent */\n  indent->ga_len -= 3;\n  ga_append(indent, '\\0');\n}\n\n/*\n * Print the NFA state machine.\n */\nstatic void nfa_dump(nfa_regprog_T *prog)\n{\n  FILE *debugf = fopen(NFA_REGEXP_DUMP_LOG, \"a\");\n\n  if (debugf != NULL) {\n    nfa_print_state(debugf, prog->start);\n\n    if (prog->reganch)\n      fprintf(debugf, \"reganch: %d\\n\", prog->reganch);\n    if (prog->regstart != NUL)\n      fprintf(debugf, \"regstart: %c (decimal: %d)\\n\",\n          prog->regstart, prog->regstart);\n    if (prog->match_text != NULL)\n      fprintf(debugf, \"match_text: \\\"%s\\\"\\n\", prog->match_text);\n\n    fclose(debugf);\n  }\n}\n#endif      /* REGEXP_DEBUG */\n\n/*\n * Parse r.e. @expr and convert it into postfix form.\n * Return the postfix string on success, NULL otherwise.\n */\nstatic int *re2post(void)\n{\n  if (nfa_reg(REG_NOPAREN) == FAIL)\n    return NULL;\n  EMIT(NFA_MOPEN);\n  return post_start;\n}\n\n/* NB. Some of the code below is inspired by Russ's. */\n\n/*\n * Represents an NFA state plus zero or one or two arrows exiting.\n * if c == MATCH, no arrows out; matching state.\n * If c == SPLIT, unlabeled arrows to out and out1 (if != NULL).\n * If c < 256, labeled arrow with character c to out.\n */\n\nstatic nfa_state_T      *state_ptr; /* points to nfa_prog->state */\n\n/*\n * Allocate and initialize nfa_state_T.\n */\nstatic nfa_state_T *alloc_state(int c, nfa_state_T *out, nfa_state_T *out1)\n{\n  nfa_state_T *s;\n\n  if (istate >= nstate)\n    return NULL;\n\n  s = &state_ptr[istate++];\n\n  s->c    = c;\n  s->out  = out;\n  s->out1 = out1;\n  s->val  = 0;\n\n  s->id   = istate;\n  s->lastlist[0] = 0;\n  s->lastlist[1] = 0;\n\n  return s;\n}\n\n/*\n * A partially built NFA without the matching state filled in.\n * Frag_T.start points at the start state.\n * Frag_T.out is a list of places that need to be set to the\n * next state for this fragment.\n */\n\n\n/*\n * Initialize a Frag_T struct and return it.\n */\nstatic Frag_T frag(nfa_state_T *start, Ptrlist *out)\n{\n  Frag_T n;\n\n  n.start = start;\n  n.out = out;\n  return n;\n}\n\n/*\n * Create singleton list containing just outp.\n */\nstatic Ptrlist *list1(nfa_state_T **outp)\n{\n  Ptrlist *l;\n\n  l = (Ptrlist *)outp;\n  l->next = NULL;\n  return l;\n}\n\n/*\n * Patch the list of states at out to point to start.\n */\nstatic void patch(Ptrlist *l, nfa_state_T *s)\n{\n  Ptrlist *next;\n\n  for (; l; l = next) {\n    next = l->next;\n    l->s = s;\n  }\n}\n\n\n/*\n * Join the two lists l1 and l2, returning the combination.\n */\nstatic Ptrlist *append(Ptrlist *l1, Ptrlist *l2)\n{\n  Ptrlist *oldl1;\n\n  oldl1 = l1;\n  while (l1->next)\n    l1 = l1->next;\n  l1->next = l2;\n  return oldl1;\n}\n\n/*\n * Stack used for transforming postfix form into NFA.\n */\nstatic Frag_T empty;\n\nstatic void st_error(int *postfix, int *end, int *p)\n{\n#ifdef NFA_REGEXP_ERROR_LOG\n  FILE *df;\n  int *p2;\n\n  df = fopen(NFA_REGEXP_ERROR_LOG, \"a\");\n  if (df) {\n    fprintf(df, \"Error popping the stack!\\n\");\n#ifdef REGEXP_DEBUG\n    fprintf(df, \"Current regexp is \\\"%s\\\"\\n\", nfa_regengine.expr);\n#endif\n    fprintf(df, \"Postfix form is: \");\n#ifdef REGEXP_DEBUG\n    for (p2 = postfix; p2 < end; p2++) {\n      nfa_set_code(*p2);\n      fprintf(df, \"%s, \", code);\n    }\n    nfa_set_code(*p);\n    fprintf(df, \"\\nCurrent position is: \");\n    for (p2 = postfix; p2 <= p; p2++) {\n      nfa_set_code(*p2);\n      fprintf(df, \"%s, \", code);\n    }\n#else\n    for (p2 = postfix; p2 < end; p2++) {\n      fprintf(df, \"%d, \", *p2);\n    }\n    fprintf(df, \"\\nCurrent position is: \");\n    for (p2 = postfix; p2 <= p; p2++) {\n      fprintf(df, \"%d, \", *p2);\n    }\n#endif\n    fprintf(df, \"\\n--------------------------\\n\");\n    fclose(df);\n  }\n#endif\n  EMSG(_(\"E874: (NFA) Could not pop the stack!\"));\n}\n\n/*\n * Push an item onto the stack.\n */\nstatic void st_push(Frag_T s, Frag_T **p, Frag_T *stack_end)\n{\n  Frag_T *stackp = *p;\n\n  if (stackp >= stack_end)\n    return;\n  *stackp = s;\n  *p = *p + 1;\n}\n\n/*\n * Pop an item from the stack.\n */\nstatic Frag_T st_pop(Frag_T **p, Frag_T *stack)\n{\n  Frag_T *stackp;\n\n  *p = *p - 1;\n  stackp = *p;\n  if (stackp < stack)\n    return empty;\n  return **p;\n}\n\n/*\n * Estimate the maximum byte length of anything matching \"state\".\n * When unknown or unlimited return -1.\n */\nstatic int nfa_max_width(nfa_state_T *startstate, int depth)\n{\n  int l, r;\n  nfa_state_T     *state = startstate;\n  int len = 0;\n\n  /* detect looping in a NFA_SPLIT */\n  if (depth > 4)\n    return -1;\n\n  while (state != NULL) {\n    switch (state->c) {\n    case NFA_END_INVISIBLE:\n    case NFA_END_INVISIBLE_NEG:\n      /* the end, return what we have */\n      return len;\n\n    case NFA_SPLIT:\n      /* two alternatives, use the maximum */\n      l = nfa_max_width(state->out, depth + 1);\n      r = nfa_max_width(state->out1, depth + 1);\n      if (l < 0 || r < 0)\n        return -1;\n      return len + (l > r ? l : r);\n\n    case NFA_ANY:\n    case NFA_START_COLL:\n    case NFA_START_NEG_COLL:\n      // Matches some character, including composing chars.\n      len += MB_MAXBYTES;\n      if (state->c != NFA_ANY) {\n        // Skip over the characters.\n        state = state->out1->out;\n        continue;\n      }\n      break;\n\n    case NFA_DIGIT:\n    case NFA_WHITE:\n    case NFA_HEX:\n    case NFA_OCTAL:\n      /* ascii */\n      ++len;\n      break;\n\n    case NFA_IDENT:\n    case NFA_SIDENT:\n    case NFA_KWORD:\n    case NFA_SKWORD:\n    case NFA_FNAME:\n    case NFA_SFNAME:\n    case NFA_PRINT:\n    case NFA_SPRINT:\n    case NFA_NWHITE:\n    case NFA_NDIGIT:\n    case NFA_NHEX:\n    case NFA_NOCTAL:\n    case NFA_WORD:\n    case NFA_NWORD:\n    case NFA_HEAD:\n    case NFA_NHEAD:\n    case NFA_ALPHA:\n    case NFA_NALPHA:\n    case NFA_LOWER:\n    case NFA_NLOWER:\n    case NFA_UPPER:\n    case NFA_NUPPER:\n    case NFA_LOWER_IC:\n    case NFA_NLOWER_IC:\n    case NFA_UPPER_IC:\n    case NFA_NUPPER_IC:\n    case NFA_ANY_COMPOSING:\n      // possibly non-ascii\n      len += 3;\n      break;\n\n    case NFA_START_INVISIBLE:\n    case NFA_START_INVISIBLE_NEG:\n    case NFA_START_INVISIBLE_BEFORE:\n    case NFA_START_INVISIBLE_BEFORE_NEG:\n      /* zero-width, out1 points to the END state */\n      state = state->out1->out;\n      continue;\n\n    case NFA_BACKREF1:\n    case NFA_BACKREF2:\n    case NFA_BACKREF3:\n    case NFA_BACKREF4:\n    case NFA_BACKREF5:\n    case NFA_BACKREF6:\n    case NFA_BACKREF7:\n    case NFA_BACKREF8:\n    case NFA_BACKREF9:\n    case NFA_ZREF1:\n    case NFA_ZREF2:\n    case NFA_ZREF3:\n    case NFA_ZREF4:\n    case NFA_ZREF5:\n    case NFA_ZREF6:\n    case NFA_ZREF7:\n    case NFA_ZREF8:\n    case NFA_ZREF9:\n    case NFA_NEWL:\n    case NFA_SKIP:\n      /* unknown width */\n      return -1;\n\n    case NFA_BOL:\n    case NFA_EOL:\n    case NFA_BOF:\n    case NFA_EOF:\n    case NFA_BOW:\n    case NFA_EOW:\n    case NFA_MOPEN:\n    case NFA_MOPEN1:\n    case NFA_MOPEN2:\n    case NFA_MOPEN3:\n    case NFA_MOPEN4:\n    case NFA_MOPEN5:\n    case NFA_MOPEN6:\n    case NFA_MOPEN7:\n    case NFA_MOPEN8:\n    case NFA_MOPEN9:\n    case NFA_ZOPEN:\n    case NFA_ZOPEN1:\n    case NFA_ZOPEN2:\n    case NFA_ZOPEN3:\n    case NFA_ZOPEN4:\n    case NFA_ZOPEN5:\n    case NFA_ZOPEN6:\n    case NFA_ZOPEN7:\n    case NFA_ZOPEN8:\n    case NFA_ZOPEN9:\n    case NFA_ZCLOSE:\n    case NFA_ZCLOSE1:\n    case NFA_ZCLOSE2:\n    case NFA_ZCLOSE3:\n    case NFA_ZCLOSE4:\n    case NFA_ZCLOSE5:\n    case NFA_ZCLOSE6:\n    case NFA_ZCLOSE7:\n    case NFA_ZCLOSE8:\n    case NFA_ZCLOSE9:\n    case NFA_MCLOSE:\n    case NFA_MCLOSE1:\n    case NFA_MCLOSE2:\n    case NFA_MCLOSE3:\n    case NFA_MCLOSE4:\n    case NFA_MCLOSE5:\n    case NFA_MCLOSE6:\n    case NFA_MCLOSE7:\n    case NFA_MCLOSE8:\n    case NFA_MCLOSE9:\n    case NFA_NOPEN:\n    case NFA_NCLOSE:\n\n    case NFA_LNUM_GT:\n    case NFA_LNUM_LT:\n    case NFA_COL_GT:\n    case NFA_COL_LT:\n    case NFA_VCOL_GT:\n    case NFA_VCOL_LT:\n    case NFA_MARK_GT:\n    case NFA_MARK_LT:\n    case NFA_VISUAL:\n    case NFA_LNUM:\n    case NFA_CURSOR:\n    case NFA_COL:\n    case NFA_VCOL:\n    case NFA_MARK:\n\n    case NFA_ZSTART:\n    case NFA_ZEND:\n    case NFA_OPT_CHARS:\n    case NFA_EMPTY:\n    case NFA_START_PATTERN:\n    case NFA_END_PATTERN:\n    case NFA_COMPOSING:\n    case NFA_END_COMPOSING:\n      /* zero-width */\n      break;\n\n    default:\n      if (state->c < 0)\n        /* don't know what this is */\n        return -1;\n      /* normal character */\n      len += MB_CHAR2LEN(state->c);\n      break;\n    }\n\n    /* normal way to continue */\n    state = state->out;\n  }\n\n  /* unrecognized, \"cannot happen\" */\n  return -1;\n}\n\n/*\n * Convert a postfix form into its equivalent NFA.\n * Return the NFA start state on success, NULL otherwise.\n */\nstatic nfa_state_T *post2nfa(int *postfix, int *end, int nfa_calc_size)\n{\n  int         *p;\n  int mopen;\n  int mclose;\n  Frag_T      *stack = NULL;\n  Frag_T      *stackp = NULL;\n  Frag_T      *stack_end = NULL;\n  Frag_T e1;\n  Frag_T e2;\n  Frag_T e;\n  nfa_state_T *s;\n  nfa_state_T *s1;\n  nfa_state_T *matchstate;\n  nfa_state_T *ret = NULL;\n\n  if (postfix == NULL)\n    return NULL;\n\n#define PUSH(s)     st_push((s), &stackp, stack_end)\n#define POP()       st_pop(&stackp, stack); \\\n  if (stackp < stack) { \\\n    st_error(postfix, end, p); \\\n    xfree(stack); \\\n    return NULL; \\\n  }\n\n  if (nfa_calc_size == false) {\n    // Allocate space for the stack. Max states on the stack: \"nstate\".\n    stack = xmalloc((nstate + 1) * sizeof(Frag_T));\n    stackp = stack;\n    stack_end = stack + (nstate + 1);\n  }\n\n  for (p = postfix; p < end; ++p) {\n    switch (*p) {\n    case NFA_CONCAT:\n      // Concatenation.\n      // Pay attention: this operator does not exist in the r.e. itself\n      // (it is implicit, really).  It is added when r.e. is translated\n      // to postfix form in re2post().\n      if (nfa_calc_size == true) {\n        // nstate += 0;\n        break;\n      }\n      e2 = POP();\n      e1 = POP();\n      patch(e1.out, e2.start);\n      PUSH(frag(e1.start, e2.out));\n      break;\n\n    case NFA_OR:\n      // Alternation\n      if (nfa_calc_size == true) {\n        nstate++;\n        break;\n      }\n      e2 = POP();\n      e1 = POP();\n      s = alloc_state(NFA_SPLIT, e1.start, e2.start);\n      if (s == NULL)\n        goto theend;\n      PUSH(frag(s, append(e1.out, e2.out)));\n      break;\n\n    case NFA_STAR:\n      // Zero or more, prefer more\n      if (nfa_calc_size == true) {\n        nstate++;\n        break;\n      }\n      e = POP();\n      s = alloc_state(NFA_SPLIT, e.start, NULL);\n      if (s == NULL)\n        goto theend;\n      patch(e.out, s);\n      PUSH(frag(s, list1(&s->out1)));\n      break;\n\n    case NFA_STAR_NONGREEDY:\n      // Zero or more, prefer zero\n      if (nfa_calc_size == true) {\n        nstate++;\n        break;\n      }\n      e = POP();\n      s = alloc_state(NFA_SPLIT, NULL, e.start);\n      if (s == NULL)\n        goto theend;\n      patch(e.out, s);\n      PUSH(frag(s, list1(&s->out)));\n      break;\n\n    case NFA_QUEST:\n      // one or zero atoms=> greedy match\n      if (nfa_calc_size == true) {\n        nstate++;\n        break;\n      }\n      e = POP();\n      s = alloc_state(NFA_SPLIT, e.start, NULL);\n      if (s == NULL)\n        goto theend;\n      PUSH(frag(s, append(e.out, list1(&s->out1))));\n      break;\n\n    case NFA_QUEST_NONGREEDY:\n      // zero or one atoms => non-greedy match\n      if (nfa_calc_size == true) {\n        nstate++;\n        break;\n      }\n      e = POP();\n      s = alloc_state(NFA_SPLIT, NULL, e.start);\n      if (s == NULL)\n        goto theend;\n      PUSH(frag(s, append(e.out, list1(&s->out))));\n      break;\n\n    case NFA_END_COLL:\n    case NFA_END_NEG_COLL:\n      /* On the stack is the sequence starting with NFA_START_COLL or\n       * NFA_START_NEG_COLL and all possible characters. Patch it to\n       * add the output to the start. */\n      if (nfa_calc_size == true) {\n        nstate++;\n        break;\n      }\n      e = POP();\n      s = alloc_state(NFA_END_COLL, NULL, NULL);\n      if (s == NULL)\n        goto theend;\n      patch(e.out, s);\n      e.start->out1 = s;\n      PUSH(frag(e.start, list1(&s->out)));\n      break;\n\n    case NFA_RANGE:\n      // Before this are two characters, the low and high end of a\n      // range.  Turn them into two states with MIN and MAX.\n      if (nfa_calc_size == true) {\n        // nstate += 0;\n        break;\n      }\n      e2 = POP();\n      e1 = POP();\n      e2.start->val = e2.start->c;\n      e2.start->c = NFA_RANGE_MAX;\n      e1.start->val = e1.start->c;\n      e1.start->c = NFA_RANGE_MIN;\n      patch(e1.out, e2.start);\n      PUSH(frag(e1.start, e2.out));\n      break;\n\n    case NFA_EMPTY:\n      // 0-length, used in a repetition with max/min count of 0\n      if (nfa_calc_size == true) {\n        nstate++;\n        break;\n      }\n      s = alloc_state(NFA_EMPTY, NULL, NULL);\n      if (s == NULL)\n        goto theend;\n      PUSH(frag(s, list1(&s->out)));\n      break;\n\n    case NFA_OPT_CHARS:\n    {\n      int n;\n\n      // \\%[abc] implemented as:\n      //    NFA_SPLIT\n      //    +-CHAR(a)\n      //    | +-NFA_SPLIT\n      //    |   +-CHAR(b)\n      //    |   | +-NFA_SPLIT\n      //    |   |   +-CHAR(c)\n      //    |   |   | +-next\n      //    |   |   +- next\n      //    |   +- next\n      //    +- next\n      n = *++p;  // get number of characters\n      if (nfa_calc_size == true) {\n        nstate += n;\n        break;\n      }\n      s = NULL;       /* avoid compiler warning */\n      e1.out = NULL;       /* stores list with out1's */\n      s1 = NULL;       /* previous NFA_SPLIT to connect to */\n      while (n-- > 0) {\n        e = POP();         /* get character */\n        s = alloc_state(NFA_SPLIT, e.start, NULL);\n        if (s == NULL)\n          goto theend;\n        if (e1.out == NULL)\n          e1 = e;\n        patch(e.out, s1);\n        append(e1.out, list1(&s->out1));\n        s1 = s;\n      }\n      PUSH(frag(s, e1.out));\n      break;\n    }\n\n    case NFA_PREV_ATOM_NO_WIDTH:\n    case NFA_PREV_ATOM_NO_WIDTH_NEG:\n    case NFA_PREV_ATOM_JUST_BEFORE:\n    case NFA_PREV_ATOM_JUST_BEFORE_NEG:\n    case NFA_PREV_ATOM_LIKE_PATTERN:\n    {\n      int before = (*p == NFA_PREV_ATOM_JUST_BEFORE\n                    || *p == NFA_PREV_ATOM_JUST_BEFORE_NEG);\n      int pattern = (*p == NFA_PREV_ATOM_LIKE_PATTERN);\n      int start_state;\n      int end_state;\n      int n = 0;\n      nfa_state_T *zend;\n      nfa_state_T *skip;\n\n      switch (*p) {\n      case NFA_PREV_ATOM_NO_WIDTH:\n        start_state = NFA_START_INVISIBLE;\n        end_state = NFA_END_INVISIBLE;\n        break;\n      case NFA_PREV_ATOM_NO_WIDTH_NEG:\n        start_state = NFA_START_INVISIBLE_NEG;\n        end_state = NFA_END_INVISIBLE_NEG;\n        break;\n      case NFA_PREV_ATOM_JUST_BEFORE:\n        start_state = NFA_START_INVISIBLE_BEFORE;\n        end_state = NFA_END_INVISIBLE;\n        break;\n      case NFA_PREV_ATOM_JUST_BEFORE_NEG:\n        start_state = NFA_START_INVISIBLE_BEFORE_NEG;\n        end_state = NFA_END_INVISIBLE_NEG;\n        break;\n      default:           /* NFA_PREV_ATOM_LIKE_PATTERN: */\n        start_state = NFA_START_PATTERN;\n        end_state = NFA_END_PATTERN;\n        break;\n      }\n\n      if (before)\n        n = *++p;         /* get the count */\n\n      /* The \\@= operator: match the preceding atom with zero width.\n       * The \\@! operator: no match for the preceding atom.\n       * The \\@<= operator: match for the preceding atom.\n       * The \\@<! operator: no match for the preceding atom.\n       * Surrounds the preceding atom with START_INVISIBLE and\n       * END_INVISIBLE, similarly to MOPEN. */\n\n      if (nfa_calc_size == true) {\n        nstate += pattern ? 4 : 2;\n        break;\n      }\n      e = POP();\n      s1 = alloc_state(end_state, NULL, NULL);\n      if (s1 == NULL)\n        goto theend;\n\n      s = alloc_state(start_state, e.start, s1);\n      if (s == NULL)\n        goto theend;\n      if (pattern) {\n        /* NFA_ZEND -> NFA_END_PATTERN -> NFA_SKIP -> what follows. */\n        skip = alloc_state(NFA_SKIP, NULL, NULL);\n        if (skip == NULL) {\n          goto theend;\n        }\n        zend = alloc_state(NFA_ZEND, s1, NULL);\n        if (zend == NULL) {\n          goto theend;\n        }\n        s1->out= skip;\n        patch(e.out, zend);\n        PUSH(frag(s, list1(&skip->out)));\n      } else {\n        patch(e.out, s1);\n        PUSH(frag(s, list1(&s1->out)));\n        if (before) {\n          if (n <= 0)\n            /* See if we can guess the maximum width, it avoids a\n             * lot of pointless tries. */\n            n = nfa_max_width(e.start, 0);\n          s->val = n;           /* store the count */\n        }\n      }\n      break;\n    }\n\n    case NFA_COMPOSING:         // char with composing char\n      FALLTHROUGH;\n\n    case NFA_MOPEN:     /* \\( \\) Submatch */\n    case NFA_MOPEN1:\n    case NFA_MOPEN2:\n    case NFA_MOPEN3:\n    case NFA_MOPEN4:\n    case NFA_MOPEN5:\n    case NFA_MOPEN6:\n    case NFA_MOPEN7:\n    case NFA_MOPEN8:\n    case NFA_MOPEN9:\n    case NFA_ZOPEN:     /* \\z( \\) Submatch */\n    case NFA_ZOPEN1:\n    case NFA_ZOPEN2:\n    case NFA_ZOPEN3:\n    case NFA_ZOPEN4:\n    case NFA_ZOPEN5:\n    case NFA_ZOPEN6:\n    case NFA_ZOPEN7:\n    case NFA_ZOPEN8:\n    case NFA_ZOPEN9:\n    case NFA_NOPEN:     // \\%( \\) \"Invisible Submatch\"\n      if (nfa_calc_size == true) {\n        nstate += 2;\n        break;\n      }\n\n      mopen = *p;\n      switch (*p) {\n      case NFA_NOPEN: mclose = NFA_NCLOSE; break;\n      case NFA_ZOPEN: mclose = NFA_ZCLOSE; break;\n      case NFA_ZOPEN1: mclose = NFA_ZCLOSE1; break;\n      case NFA_ZOPEN2: mclose = NFA_ZCLOSE2; break;\n      case NFA_ZOPEN3: mclose = NFA_ZCLOSE3; break;\n      case NFA_ZOPEN4: mclose = NFA_ZCLOSE4; break;\n      case NFA_ZOPEN5: mclose = NFA_ZCLOSE5; break;\n      case NFA_ZOPEN6: mclose = NFA_ZCLOSE6; break;\n      case NFA_ZOPEN7: mclose = NFA_ZCLOSE7; break;\n      case NFA_ZOPEN8: mclose = NFA_ZCLOSE8; break;\n      case NFA_ZOPEN9: mclose = NFA_ZCLOSE9; break;\n      case NFA_COMPOSING: mclose = NFA_END_COMPOSING; break;\n      default:\n        /* NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9 */\n        mclose = *p + NSUBEXP;\n        break;\n      }\n\n      /* Allow \"NFA_MOPEN\" as a valid postfix representation for\n       * the empty regexp \"\". In this case, the NFA will be\n       * NFA_MOPEN -> NFA_MCLOSE. Note that this also allows\n       * empty groups of parenthesis, and empty mbyte chars */\n      if (stackp == stack) {\n        s = alloc_state(mopen, NULL, NULL);\n        if (s == NULL)\n          goto theend;\n        s1 = alloc_state(mclose, NULL, NULL);\n        if (s1 == NULL)\n          goto theend;\n        patch(list1(&s->out), s1);\n        PUSH(frag(s, list1(&s1->out)));\n        break;\n      }\n\n      /* At least one node was emitted before NFA_MOPEN, so\n       * at least one node will be between NFA_MOPEN and NFA_MCLOSE */\n      e = POP();\n      s = alloc_state(mopen, e.start, NULL);         /* `(' */\n      if (s == NULL)\n        goto theend;\n\n      s1 = alloc_state(mclose, NULL, NULL);         /* `)' */\n      if (s1 == NULL)\n        goto theend;\n      patch(e.out, s1);\n\n      if (mopen == NFA_COMPOSING)\n        /* COMPOSING->out1 = END_COMPOSING */\n        patch(list1(&s->out1), s1);\n\n      PUSH(frag(s, list1(&s1->out)));\n      break;\n\n    case NFA_BACKREF1:\n    case NFA_BACKREF2:\n    case NFA_BACKREF3:\n    case NFA_BACKREF4:\n    case NFA_BACKREF5:\n    case NFA_BACKREF6:\n    case NFA_BACKREF7:\n    case NFA_BACKREF8:\n    case NFA_BACKREF9:\n    case NFA_ZREF1:\n    case NFA_ZREF2:\n    case NFA_ZREF3:\n    case NFA_ZREF4:\n    case NFA_ZREF5:\n    case NFA_ZREF6:\n    case NFA_ZREF7:\n    case NFA_ZREF8:\n    case NFA_ZREF9:\n      if (nfa_calc_size == true) {\n        nstate += 2;\n        break;\n      }\n      s = alloc_state(*p, NULL, NULL);\n      if (s == NULL)\n        goto theend;\n      s1 = alloc_state(NFA_SKIP, NULL, NULL);\n      if (s1 == NULL)\n        goto theend;\n      patch(list1(&s->out), s1);\n      PUSH(frag(s, list1(&s1->out)));\n      break;\n\n    case NFA_LNUM:\n    case NFA_LNUM_GT:\n    case NFA_LNUM_LT:\n    case NFA_VCOL:\n    case NFA_VCOL_GT:\n    case NFA_VCOL_LT:\n    case NFA_COL:\n    case NFA_COL_GT:\n    case NFA_COL_LT:\n    case NFA_MARK:\n    case NFA_MARK_GT:\n    case NFA_MARK_LT:\n    {\n      int n = *++p;       /* lnum, col or mark name */\n\n      if (nfa_calc_size == true) {\n        nstate += 1;\n        break;\n      }\n      s = alloc_state(p[-1], NULL, NULL);\n      if (s == NULL)\n        goto theend;\n      s->val = n;\n      PUSH(frag(s, list1(&s->out)));\n      break;\n    }\n\n    case NFA_ZSTART:\n    case NFA_ZEND:\n    default:\n      // Operands\n      if (nfa_calc_size == true) {\n        nstate++;\n        break;\n      }\n      s = alloc_state(*p, NULL, NULL);\n      if (s == NULL)\n        goto theend;\n      PUSH(frag(s, list1(&s->out)));\n      break;\n\n    }     /* switch(*p) */\n\n  }   /* for(p = postfix; *p; ++p) */\n\n  if (nfa_calc_size == true) {\n    nstate++;\n    goto theend;        /* Return value when counting size is ignored anyway */\n  }\n\n  e = POP();\n  if (stackp != stack) {\n    xfree(stack);\n    EMSG_RET_NULL(_(\"E875: (NFA regexp) (While converting from postfix to NFA),\"\n                    \"too many states left on stack\"));\n  }\n\n  if (istate >= nstate) {\n    xfree(stack);\n    EMSG_RET_NULL(_(\"E876: (NFA regexp) \"\n                    \"Not enough space to store the whole NFA \"));\n  }\n\n  matchstate = &state_ptr[istate++];   /* the match state */\n  matchstate->c = NFA_MATCH;\n  matchstate->out = matchstate->out1 = NULL;\n  matchstate->id = 0;\n\n  patch(e.out, matchstate);\n  ret = e.start;\n\ntheend:\n  xfree(stack);\n  return ret;\n\n#undef POP1\n#undef PUSH1\n#undef POP2\n#undef PUSH2\n#undef POP\n#undef PUSH\n}\n\n/*\n * After building the NFA program, inspect it to add optimization hints.\n */\nstatic void nfa_postprocess(nfa_regprog_T *prog)\n{\n  int i;\n  int c;\n\n  for (i = 0; i < prog->nstate; ++i) {\n    c = prog->state[i].c;\n    if (c == NFA_START_INVISIBLE\n        || c == NFA_START_INVISIBLE_NEG\n        || c == NFA_START_INVISIBLE_BEFORE\n        || c == NFA_START_INVISIBLE_BEFORE_NEG) {\n      int directly;\n\n      // Do it directly when what follows is possibly the end of the\n      // match.\n      if (match_follows(prog->state[i].out1->out, 0)) {\n        directly = true;\n      } else {\n        int ch_invisible = failure_chance(prog->state[i].out, 0);\n        int ch_follows = failure_chance(prog->state[i].out1->out, 0);\n\n        /* Postpone when the invisible match is expensive or has a\n         * lower chance of failing. */\n        if (c == NFA_START_INVISIBLE_BEFORE\n            || c == NFA_START_INVISIBLE_BEFORE_NEG) {\n          /* \"before\" matches are very expensive when\n           * unbounded, always prefer what follows then,\n           * unless what follows will always match.\n           * Otherwise strongly prefer what follows. */\n          if (prog->state[i].val <= 0 && ch_follows > 0) {\n            directly = false;\n          } else {\n            directly = ch_follows * 10 < ch_invisible;\n          }\n        } else {\n          /* normal invisible, first do the one with the\n           * highest failure chance */\n          directly = ch_follows < ch_invisible;\n        }\n      }\n      if (directly)\n        /* switch to the _FIRST state */\n        ++prog->state[i].c;\n    }\n  }\n}\n\n/****************************************************************\n* NFA execution code.\n****************************************************************/\n\n/* Values for done in nfa_pim_T. */\n#define NFA_PIM_UNUSED   0      /* pim not used */\n#define NFA_PIM_TODO     1      /* pim not done yet */\n#define NFA_PIM_MATCH    2      /* pim executed, matches */\n#define NFA_PIM_NOMATCH  3      /* pim executed, no match */\n\n\n#ifdef REGEXP_DEBUG\nstatic void log_subsexpr(regsubs_T *subs)\n{\n  log_subexpr(&subs->norm);\n  if (rex.nfa_has_zsubexpr) {\n    log_subexpr(&subs->synt);\n  }\n}\n\nstatic void log_subexpr(regsub_T *sub)\n{\n  int j;\n\n  for (j = 0; j < sub->in_use; j++)\n    if (REG_MULTI)\n      fprintf(log_fd, \"*** group %d, start: c=%d, l=%d, end: c=%d, l=%d\\n\",\n          j,\n          sub->list.multi[j].start_col,\n          (int)sub->list.multi[j].start_lnum,\n          sub->list.multi[j].end_col,\n          (int)sub->list.multi[j].end_lnum);\n    else {\n      char *s = (char *)sub->list.line[j].start;\n      char *e = (char *)sub->list.line[j].end;\n\n      fprintf(log_fd, \"*** group %d, start: \\\"%s\\\", end: \\\"%s\\\"\\n\",\n          j,\n          s == NULL ? \"NULL\" : s,\n          e == NULL ? \"NULL\" : e);\n    }\n}\n\nstatic char *pim_info(const nfa_pim_T *pim)\n{\n  static char buf[30];\n\n  if (pim == NULL || pim->result == NFA_PIM_UNUSED) {\n    buf[0] = NUL;\n  } else {\n    snprintf(buf, sizeof(buf), \" PIM col %d\",\n             REG_MULTI\n             ? (int)pim->end.pos.col\n             : (int)(pim->end.ptr - rex.input));\n  }\n  return buf;\n}\n\n#endif\n\n// Used during execution: whether a match has been found.\nstatic int nfa_match;\nstatic proftime_T *nfa_time_limit;\nstatic int *nfa_timed_out;\nstatic int nfa_time_count;\n\n// Copy postponed invisible match info from \"from\" to \"to\".\nstatic void copy_pim(nfa_pim_T *to, nfa_pim_T *from)\n{\n  to->result = from->result;\n  to->state = from->state;\n  copy_sub(&to->subs.norm, &from->subs.norm);\n  if (rex.nfa_has_zsubexpr) {\n    copy_sub(&to->subs.synt, &from->subs.synt);\n  }\n  to->end = from->end;\n}\n\nstatic void clear_sub(regsub_T *sub)\n{\n  if (REG_MULTI) {\n    // Use 0xff to set lnum to -1\n    memset(sub->list.multi, 0xff,\n           sizeof(struct multipos) * rex.nfa_nsubexpr);\n  } else {\n    memset(sub->list.line, 0, sizeof(struct linepos) * rex.nfa_nsubexpr);\n  }\n  sub->in_use = 0;\n}\n\n/*\n * Copy the submatches from \"from\" to \"to\".\n */\nstatic void copy_sub(regsub_T *to, regsub_T *from)\n{\n  to->in_use = from->in_use;\n  if (from->in_use > 0) {\n    /* Copy the match start and end positions. */\n    if (REG_MULTI)\n      memmove(&to->list.multi[0],\n          &from->list.multi[0],\n          sizeof(struct multipos) * from->in_use);\n    else\n      memmove(&to->list.line[0],\n          &from->list.line[0],\n          sizeof(struct linepos) * from->in_use);\n  }\n}\n\n/*\n * Like copy_sub() but exclude the main match.\n */\nstatic void copy_sub_off(regsub_T *to, regsub_T *from)\n{\n  if (to->in_use < from->in_use)\n    to->in_use = from->in_use;\n  if (from->in_use > 1) {\n    /* Copy the match start and end positions. */\n    if (REG_MULTI)\n      memmove(&to->list.multi[1],\n          &from->list.multi[1],\n          sizeof(struct multipos) * (from->in_use - 1));\n    else\n      memmove(&to->list.line[1],\n          &from->list.line[1],\n          sizeof(struct linepos) * (from->in_use - 1));\n  }\n}\n\n/*\n * Like copy_sub() but only do the end of the main match if \\ze is present.\n */\nstatic void copy_ze_off(regsub_T *to, regsub_T *from)\n{\n  if (rex.nfa_has_zend) {\n    if (REG_MULTI) {\n      if (from->list.multi[0].end_lnum >= 0){\n        to->list.multi[0].end_lnum = from->list.multi[0].end_lnum;\n        to->list.multi[0].end_col = from->list.multi[0].end_col;\n      }\n    } else {\n      if (from->list.line[0].end != NULL)\n        to->list.line[0].end = from->list.line[0].end;\n    }\n  }\n}\n\n// Return true if \"sub1\" and \"sub2\" have the same start positions.\n// When using back-references also check the end position.\nstatic bool sub_equal(regsub_T *sub1, regsub_T *sub2)\n{\n  int i;\n  int todo;\n  linenr_T s1;\n  linenr_T s2;\n  char_u      *sp1;\n  char_u      *sp2;\n\n  todo = sub1->in_use > sub2->in_use ? sub1->in_use : sub2->in_use;\n  if (REG_MULTI) {\n    for (i = 0; i < todo; i++) {\n      if (i < sub1->in_use) {\n        s1 = sub1->list.multi[i].start_lnum;\n      } else {\n        s1 = -1;\n      }\n      if (i < sub2->in_use) {\n        s2 = sub2->list.multi[i].start_lnum;\n      } else {\n        s2 = -1;\n      }\n      if (s1 != s2) {\n        return false;\n      }\n      if (s1 != -1 && sub1->list.multi[i].start_col\n          != sub2->list.multi[i].start_col) {\n        return false;\n      }\n      if (rex.nfa_has_backref) {\n        if (i < sub1->in_use) {\n          s1 = sub1->list.multi[i].end_lnum;\n        } else {\n          s1 = -1;\n        }\n        if (i < sub2->in_use) {\n          s2 = sub2->list.multi[i].end_lnum;\n        } else {\n          s2 = -1;\n        }\n        if (s1 != s2) {\n          return false;\n        }\n        if (s1 != -1\n            && sub1->list.multi[i].end_col != sub2->list.multi[i].end_col) {\n          return false;\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < todo; i++) {\n      if (i < sub1->in_use) {\n        sp1 = sub1->list.line[i].start;\n      } else {\n        sp1 = NULL;\n      }\n      if (i < sub2->in_use) {\n        sp2 = sub2->list.line[i].start;\n      } else {\n        sp2 = NULL;\n      }\n      if (sp1 != sp2) {\n        return false;\n      }\n      if (rex.nfa_has_backref) {\n        if (i < sub1->in_use) {\n          sp1 = sub1->list.line[i].end;\n        } else {\n          sp1 = NULL;\n        }\n        if (i < sub2->in_use) {\n          sp2 = sub2->list.line[i].end;\n        } else {\n          sp2 = NULL;\n        }\n        if (sp1 != sp2) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\n#ifdef REGEXP_DEBUG\nstatic void report_state(char *action,\n    regsub_T *sub,\n    nfa_state_T *state,\n    int lid,\n    nfa_pim_T *pim) {\n  int col;\n\n  if (sub->in_use <= 0) {\n    col = -1;\n  } else if (REG_MULTI) {\n    col = sub->list.multi[0].start_col;\n  } else {\n    col = (int)(sub->list.line[0].start - rex.line);\n  }\n  nfa_set_code(state->c);\n  fprintf(log_fd, \"> %s state %d to list %d. char %d: %s (start col %d)%s\\n\",\n          action, abs(state->id), lid, state->c, code, col,\n          pim_info(pim));\n}\n\n#endif\n\n// Return true if the same state is already in list \"l\" with the same\n// positions as \"subs\".\nstatic bool has_state_with_pos(\n    nfa_list_T *l,        // runtime state list\n    nfa_state_T *state,   // state to update\n    regsubs_T *subs,      // pointers to subexpressions\n    nfa_pim_T *pim        // postponed match or NULL\n)\n  FUNC_ATTR_NONNULL_ARG(1, 2, 3)\n{\n  for (int i = 0; i < l->n; i++) {\n    nfa_thread_T *thread = &l->t[i];\n    if (thread->state->id == state->id\n        && sub_equal(&thread->subs.norm, &subs->norm)\n        && (!rex.nfa_has_zsubexpr\n            || sub_equal(&thread->subs.synt, &subs->synt))\n        && pim_equal(&thread->pim, pim)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Return true if \"one\" and \"two\" are equal.  That includes when both are not\n// set.\nstatic bool pim_equal(const nfa_pim_T *one, const nfa_pim_T *two)\n{\n  const bool one_unused = (one == NULL || one->result == NFA_PIM_UNUSED);\n  const bool two_unused = (two == NULL || two->result == NFA_PIM_UNUSED);\n\n  if (one_unused) {\n    // one is unused: equal when two is also unused\n    return two_unused;\n  }\n  if (two_unused) {\n    // one is used and two is not: not equal\n    return false;\n  }\n  // compare the state id\n  if (one->state->id != two->state->id) {\n    return false;\n  }\n  // compare the position\n  if (REG_MULTI) {\n    return one->end.pos.lnum == two->end.pos.lnum\n           && one->end.pos.col == two->end.pos.col;\n  }\n  return one->end.ptr == two->end.ptr;\n}\n\n// Return true if \"state\" leads to a NFA_MATCH without advancing the input.\nstatic bool match_follows(const nfa_state_T *startstate, int depth)\n  FUNC_ATTR_NONNULL_ALL\n{\n  const nfa_state_T *state = startstate;\n\n  // avoid too much recursion\n  if (depth > 10) {\n    return false;\n  }\n  while (state != NULL) {\n    switch (state->c) {\n    case NFA_MATCH:\n    case NFA_MCLOSE:\n    case NFA_END_INVISIBLE:\n    case NFA_END_INVISIBLE_NEG:\n    case NFA_END_PATTERN:\n      return true;\n\n    case NFA_SPLIT:\n      return match_follows(state->out, depth + 1)\n             || match_follows(state->out1, depth + 1);\n\n    case NFA_START_INVISIBLE:\n    case NFA_START_INVISIBLE_FIRST:\n    case NFA_START_INVISIBLE_BEFORE:\n    case NFA_START_INVISIBLE_BEFORE_FIRST:\n    case NFA_START_INVISIBLE_NEG:\n    case NFA_START_INVISIBLE_NEG_FIRST:\n    case NFA_START_INVISIBLE_BEFORE_NEG:\n    case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n    case NFA_COMPOSING:\n      /* skip ahead to next state */\n      state = state->out1->out;\n      continue;\n\n    case NFA_ANY:\n    case NFA_ANY_COMPOSING:\n    case NFA_IDENT:\n    case NFA_SIDENT:\n    case NFA_KWORD:\n    case NFA_SKWORD:\n    case NFA_FNAME:\n    case NFA_SFNAME:\n    case NFA_PRINT:\n    case NFA_SPRINT:\n    case NFA_WHITE:\n    case NFA_NWHITE:\n    case NFA_DIGIT:\n    case NFA_NDIGIT:\n    case NFA_HEX:\n    case NFA_NHEX:\n    case NFA_OCTAL:\n    case NFA_NOCTAL:\n    case NFA_WORD:\n    case NFA_NWORD:\n    case NFA_HEAD:\n    case NFA_NHEAD:\n    case NFA_ALPHA:\n    case NFA_NALPHA:\n    case NFA_LOWER:\n    case NFA_NLOWER:\n    case NFA_UPPER:\n    case NFA_NUPPER:\n    case NFA_LOWER_IC:\n    case NFA_NLOWER_IC:\n    case NFA_UPPER_IC:\n    case NFA_NUPPER_IC:\n    case NFA_START_COLL:\n    case NFA_START_NEG_COLL:\n    case NFA_NEWL:\n      // state will advance input\n      return false;\n\n    default:\n      if (state->c > 0) {\n        // state will advance input\n        return false;\n      }\n      // Others: zero-width or possibly zero-width, might still find\n      // a match at the same position, keep looking.\n      break;\n    }\n    state = state->out;\n  }\n  return false;\n}\n\n\n// Return true if \"state\" is already in list \"l\".\nstatic bool state_in_list(\n    nfa_list_T *l,        // runtime state list\n    nfa_state_T *state,   // state to update\n    regsubs_T *subs       // pointers to subexpressions\n)\n  FUNC_ATTR_NONNULL_ALL\n{\n  if (state->lastlist[nfa_ll_index] == l->id) {\n    if (!rex.nfa_has_backref || has_state_with_pos(l, state, subs, NULL)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Offset used for \"off\" by addstate_here().\n#define ADDSTATE_HERE_OFFSET 10\n\n// Add \"state\" and possibly what follows to state list \".\".\n// Returns \"subs_arg\", possibly copied into temp_subs.\n// Returns NULL when recursiveness is too deep.\nstatic regsubs_T *addstate(\n    nfa_list_T *l,        // runtime state list\n    nfa_state_T *state,   // state to update\n    regsubs_T *subs_arg,  // pointers to subexpressions\n    nfa_pim_T *pim,       // postponed look-behind match\n    int off_arg)          // byte offset, when -1 go to next line\n  FUNC_ATTR_NONNULL_ARG(1, 2) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  int subidx;\n  int off = off_arg;\n  int add_here = false;\n  int listindex = 0;\n  int k;\n  int found = false;\n  nfa_thread_T        *thread;\n  struct multipos     save_multipos;\n  int save_in_use;\n  char_u              *save_ptr;\n  int i;\n  regsub_T            *sub;\n  regsubs_T           *subs = subs_arg;\n  static regsubs_T temp_subs;\n#ifdef REGEXP_DEBUG\n  int did_print = false;\n#endif\n  static int depth = 0;\n\n  // This function is called recursively.  When the depth is too much we run\n  // out of stack and crash, limit recursiveness here.\n  if (++depth >= 5000 || subs == NULL) {\n    depth--;\n    return NULL;\n  }\n\n  if (off_arg <= -ADDSTATE_HERE_OFFSET) {\n    add_here = true;\n    off = 0;\n    listindex = -(off_arg + ADDSTATE_HERE_OFFSET);\n  }\n\n  switch (state->c) {\n  case NFA_NCLOSE:\n  case NFA_MCLOSE:\n  case NFA_MCLOSE1:\n  case NFA_MCLOSE2:\n  case NFA_MCLOSE3:\n  case NFA_MCLOSE4:\n  case NFA_MCLOSE5:\n  case NFA_MCLOSE6:\n  case NFA_MCLOSE7:\n  case NFA_MCLOSE8:\n  case NFA_MCLOSE9:\n  case NFA_ZCLOSE:\n  case NFA_ZCLOSE1:\n  case NFA_ZCLOSE2:\n  case NFA_ZCLOSE3:\n  case NFA_ZCLOSE4:\n  case NFA_ZCLOSE5:\n  case NFA_ZCLOSE6:\n  case NFA_ZCLOSE7:\n  case NFA_ZCLOSE8:\n  case NFA_ZCLOSE9:\n  case NFA_MOPEN:\n  case NFA_ZEND:\n  case NFA_SPLIT:\n  case NFA_EMPTY:\n    /* These nodes are not added themselves but their \"out\" and/or\n     * \"out1\" may be added below.  */\n    break;\n\n  case NFA_BOL:\n  case NFA_BOF:\n    // \"^\" won't match past end-of-line, don't bother trying.\n    // Except when at the end of the line, or when we are going to the\n    // next line for a look-behind match.\n    if (rex.input > rex.line\n        && *rex.input != NUL\n        && (nfa_endp == NULL\n            || !REG_MULTI\n            || rex.lnum == nfa_endp->se_u.pos.lnum)) {\n      goto skip_add;\n    }\n    FALLTHROUGH;\n\n  case NFA_MOPEN1:\n  case NFA_MOPEN2:\n  case NFA_MOPEN3:\n  case NFA_MOPEN4:\n  case NFA_MOPEN5:\n  case NFA_MOPEN6:\n  case NFA_MOPEN7:\n  case NFA_MOPEN8:\n  case NFA_MOPEN9:\n  case NFA_ZOPEN:\n  case NFA_ZOPEN1:\n  case NFA_ZOPEN2:\n  case NFA_ZOPEN3:\n  case NFA_ZOPEN4:\n  case NFA_ZOPEN5:\n  case NFA_ZOPEN6:\n  case NFA_ZOPEN7:\n  case NFA_ZOPEN8:\n  case NFA_ZOPEN9:\n  case NFA_NOPEN:\n  case NFA_ZSTART:\n  /* These nodes need to be added so that we can bail out when it\n   * was added to this list before at the same position to avoid an\n   * endless loop for \"\\(\\)*\" */\n\n  default:\n    if (state->lastlist[nfa_ll_index] == l->id && state->c != NFA_SKIP) {\n      /* This state is already in the list, don't add it again,\n       * unless it is an MOPEN that is used for a backreference or\n       * when there is a PIM. For NFA_MATCH check the position,\n       * lower position is preferred. */\n      if (!rex.nfa_has_backref && pim == NULL && !l->has_pim\n          && state->c != NFA_MATCH) {\n\n        /* When called from addstate_here() do insert before\n         * existing states. */\n        if (add_here) {\n          for (k = 0; k < l->n && k < listindex; ++k) {\n            if (l->t[k].state->id == state->id) {\n              found = true;\n              break;\n            }\n          }\n        }\n\n        if (!add_here || found) {\nskip_add:\n#ifdef REGEXP_DEBUG\n          nfa_set_code(state->c);\n          fprintf(log_fd, \"> Not adding state %d to list %d. char %d: %s pim: %s has_pim: %d found: %d\\n\",\n                  abs(state->id), l->id, state->c, code,\n                  pim == NULL ? \"NULL\" : \"yes\", l->has_pim, found);\n#endif\n        depth--;\n        return subs;\n        }\n      }\n\n      /* Do not add the state again when it exists with the same\n       * positions. */\n      if (has_state_with_pos(l, state, subs, pim))\n        goto skip_add;\n    }\n\n    // When there are backreferences or PIMs the number of states may\n    // be (a lot) bigger than anticipated.\n    if (l->n == l->len) {\n      const int newlen = l->len * 3 / 2 + 50;\n      const size_t newsize = newlen * sizeof(nfa_thread_T);\n\n      if ((long)(newsize >> 10) >= p_mmp) {\n        EMSG(_(e_maxmempat));\n        depth--;\n        return NULL;\n      }\n      if (subs != &temp_subs) {\n        // \"subs\" may point into the current array, need to make a\n        // copy before it becomes invalid.\n        copy_sub(&temp_subs.norm, &subs->norm);\n        if (rex.nfa_has_zsubexpr) {\n          copy_sub(&temp_subs.synt, &subs->synt);\n        }\n        subs = &temp_subs;\n      }\n\n      nfa_thread_T *const newt = xrealloc(l->t, newsize);\n      l->t = newt;\n      l->len = newlen;\n    }\n\n    /* add the state to the list */\n    state->lastlist[nfa_ll_index] = l->id;\n    thread = &l->t[l->n++];\n    thread->state = state;\n    if (pim == NULL)\n      thread->pim.result = NFA_PIM_UNUSED;\n    else {\n      copy_pim(&thread->pim, pim);\n      l->has_pim = true;\n    }\n    copy_sub(&thread->subs.norm, &subs->norm);\n    if (rex.nfa_has_zsubexpr) {\n      copy_sub(&thread->subs.synt, &subs->synt);\n    }\n#ifdef REGEXP_DEBUG\n    report_state(\"Adding\", &thread->subs.norm, state, l->id, pim);\n    did_print = true;\n#endif\n  }\n\n#ifdef REGEXP_DEBUG\n  if (!did_print)\n    report_state(\"Processing\", &subs->norm, state, l->id, pim);\n#endif\n  switch (state->c) {\n  case NFA_MATCH:\n    break;\n\n  case NFA_SPLIT:\n    /* order matters here */\n    subs = addstate(l, state->out, subs, pim, off_arg);\n    subs = addstate(l, state->out1, subs, pim, off_arg);\n    break;\n\n  case NFA_EMPTY:\n  case NFA_NOPEN:\n  case NFA_NCLOSE:\n    subs = addstate(l, state->out, subs, pim, off_arg);\n    break;\n\n  case NFA_MOPEN:\n  case NFA_MOPEN1:\n  case NFA_MOPEN2:\n  case NFA_MOPEN3:\n  case NFA_MOPEN4:\n  case NFA_MOPEN5:\n  case NFA_MOPEN6:\n  case NFA_MOPEN7:\n  case NFA_MOPEN8:\n  case NFA_MOPEN9:\n  case NFA_ZOPEN:\n  case NFA_ZOPEN1:\n  case NFA_ZOPEN2:\n  case NFA_ZOPEN3:\n  case NFA_ZOPEN4:\n  case NFA_ZOPEN5:\n  case NFA_ZOPEN6:\n  case NFA_ZOPEN7:\n  case NFA_ZOPEN8:\n  case NFA_ZOPEN9:\n  case NFA_ZSTART:\n    if (state->c == NFA_ZSTART) {\n      subidx = 0;\n      sub = &subs->norm;\n    } else if (state->c >= NFA_ZOPEN && state->c <= NFA_ZOPEN9) {  // -V560\n      subidx = state->c - NFA_ZOPEN;\n      sub = &subs->synt;\n    } else {\n      subidx = state->c - NFA_MOPEN;\n      sub = &subs->norm;\n    }\n\n    /* avoid compiler warnings */\n    save_ptr = NULL;\n    memset(&save_multipos, 0, sizeof(save_multipos));\n\n    /* Set the position (with \"off\" added) in the subexpression.  Save\n     * and restore it when it was in use.  Otherwise fill any gap. */\n    if (REG_MULTI) {\n      if (subidx < sub->in_use) {\n        save_multipos = sub->list.multi[subidx];\n        save_in_use = -1;\n      } else {\n        save_in_use = sub->in_use;\n        for (i = sub->in_use; i < subidx; ++i) {\n          sub->list.multi[i].start_lnum = -1;\n          sub->list.multi[i].end_lnum = -1;\n        }\n        sub->in_use = subidx + 1;\n      }\n      if (off == -1) {\n        sub->list.multi[subidx].start_lnum = rex.lnum + 1;\n        sub->list.multi[subidx].start_col = 0;\n      } else {\n        sub->list.multi[subidx].start_lnum = rex.lnum;\n        sub->list.multi[subidx].start_col =\n          (colnr_T)(rex.input - rex.line + off);\n      }\n      sub->list.multi[subidx].end_lnum = -1;\n    } else {\n      if (subidx < sub->in_use) {\n        save_ptr = sub->list.line[subidx].start;\n        save_in_use = -1;\n      } else {\n        save_in_use = sub->in_use;\n        for (i = sub->in_use; i < subidx; ++i) {\n          sub->list.line[i].start = NULL;\n          sub->list.line[i].end = NULL;\n        }\n        sub->in_use = subidx + 1;\n      }\n      sub->list.line[subidx].start = rex.input + off;\n    }\n\n    subs = addstate(l, state->out, subs, pim, off_arg);\n    if (subs == NULL) {\n      break;\n    }\n    // \"subs\" may have changed, need to set \"sub\" again.\n    if (state->c >= NFA_ZOPEN && state->c <= NFA_ZOPEN9) {  // -V560\n      sub = &subs->synt;\n    } else {\n      sub = &subs->norm;\n    }\n\n    if (save_in_use == -1) {\n      if (REG_MULTI) {\n        sub->list.multi[subidx] = save_multipos;\n      }\n      else\n        sub->list.line[subidx].start = save_ptr;\n    } else\n      sub->in_use = save_in_use;\n    break;\n\n  case NFA_MCLOSE:\n    if (rex.nfa_has_zend\n        && (REG_MULTI\n            ? subs->norm.list.multi[0].end_lnum >= 0\n            : subs->norm.list.line[0].end != NULL)) {\n      // Do not overwrite the position set by \\ze.\n      subs = addstate(l, state->out, subs, pim, off_arg);\n      break;\n    }\n    FALLTHROUGH;\n  case NFA_MCLOSE1:\n  case NFA_MCLOSE2:\n  case NFA_MCLOSE3:\n  case NFA_MCLOSE4:\n  case NFA_MCLOSE5:\n  case NFA_MCLOSE6:\n  case NFA_MCLOSE7:\n  case NFA_MCLOSE8:\n  case NFA_MCLOSE9:\n  case NFA_ZCLOSE:\n  case NFA_ZCLOSE1:\n  case NFA_ZCLOSE2:\n  case NFA_ZCLOSE3:\n  case NFA_ZCLOSE4:\n  case NFA_ZCLOSE5:\n  case NFA_ZCLOSE6:\n  case NFA_ZCLOSE7:\n  case NFA_ZCLOSE8:\n  case NFA_ZCLOSE9:\n  case NFA_ZEND:\n    if (state->c == NFA_ZEND) {\n      subidx = 0;\n      sub = &subs->norm;\n    } else if (state->c >= NFA_ZCLOSE && state->c <= NFA_ZCLOSE9) {  // -V560\n      subidx = state->c - NFA_ZCLOSE;\n      sub = &subs->synt;\n    } else {\n      subidx = state->c - NFA_MCLOSE;\n      sub = &subs->norm;\n    }\n\n    /* We don't fill in gaps here, there must have been an MOPEN that\n     * has done that. */\n    save_in_use = sub->in_use;\n    if (sub->in_use <= subidx)\n      sub->in_use = subidx + 1;\n    if (REG_MULTI) {\n      save_multipos = sub->list.multi[subidx];\n      if (off == -1) {\n        sub->list.multi[subidx].end_lnum = rex.lnum + 1;\n        sub->list.multi[subidx].end_col = 0;\n      } else {\n        sub->list.multi[subidx].end_lnum = rex.lnum;\n        sub->list.multi[subidx].end_col =\n          (colnr_T)(rex.input - rex.line + off);\n      }\n      /* avoid compiler warnings */\n      save_ptr = NULL;\n    } else {\n      save_ptr = sub->list.line[subidx].end;\n      sub->list.line[subidx].end = rex.input + off;\n      // avoid compiler warnings\n      memset(&save_multipos, 0, sizeof(save_multipos));\n    }\n\n    subs = addstate(l, state->out, subs, pim, off_arg);\n    if (subs == NULL) {\n      break;\n    }\n    // \"subs\" may have changed, need to set \"sub\" again.\n    if (state->c >= NFA_ZCLOSE && state->c <= NFA_ZCLOSE9) {  // -V560\n      sub = &subs->synt;\n    } else {\n      sub = &subs->norm;\n    }\n\n    if (REG_MULTI) {\n      sub->list.multi[subidx] = save_multipos;\n    }\n    else\n      sub->list.line[subidx].end = save_ptr;\n    sub->in_use = save_in_use;\n    break;\n  }\n  depth--;\n  return subs;\n}\n\n/*\n * Like addstate(), but the new state(s) are put at position \"*ip\".\n * Used for zero-width matches, next state to use is the added one.\n * This makes sure the order of states to be tried does not change, which\n * matters for alternatives.\n */\nstatic regsubs_T *addstate_here(\n    nfa_list_T *l,        // runtime state list\n    nfa_state_T *state,   // state to update\n    regsubs_T *subs,      // pointers to subexpressions\n    nfa_pim_T *pim,       // postponed look-behind match\n    int *ip\n)\n  FUNC_ATTR_NONNULL_ARG(1, 2, 5) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  int tlen = l->n;\n  int count;\n  int listidx = *ip;\n\n  /* First add the state(s) at the end, so that we know how many there are.\n   * Pass the listidx as offset (avoids adding another argument to\n   * addstate(). */\n  regsubs_T *r = addstate(l, state, subs, pim, -listidx - ADDSTATE_HERE_OFFSET);\n  if (r == NULL) {\n    return NULL;\n  }\n\n  // when \"*ip\" was at the end of the list, nothing to do\n  if (listidx + 1 == tlen) {\n    return r;\n  }\n\n  // re-order to put the new state at the current position\n  count = l->n - tlen;\n  if (count == 0) {\n    return r;  // no state got added\n  }\n  if (count == 1) {\n    // overwrite the current state\n    l->t[listidx] = l->t[l->n - 1];\n  } else if (count > 1) {\n    if (l->n + count - 1 >= l->len) {\n      /* not enough space to move the new states, reallocate the list\n       * and move the states to the right position */\n      const int newlen = l->len * 3 / 2 + 50;\n      const size_t newsize = newlen * sizeof(nfa_thread_T);\n\n      if ((long)(newsize >> 10) >= p_mmp) {\n        EMSG(_(e_maxmempat));\n        return NULL;\n      }\n      nfa_thread_T *const newl = xmalloc(newsize);\n      l->len = newlen;\n      memmove(&(newl[0]),\n          &(l->t[0]),\n          sizeof(nfa_thread_T) * listidx);\n      memmove(&(newl[listidx]),\n          &(l->t[l->n - count]),\n          sizeof(nfa_thread_T) * count);\n      memmove(&(newl[listidx + count]),\n          &(l->t[listidx + 1]),\n          sizeof(nfa_thread_T) * (l->n - count - listidx - 1));\n      xfree(l->t);\n      l->t = newl;\n    } else {\n      /* make space for new states, then move them from the\n       * end to the current position */\n      memmove(&(l->t[listidx + count]),\n          &(l->t[listidx + 1]),\n          sizeof(nfa_thread_T) * (l->n - listidx - 1));\n      memmove(&(l->t[listidx]),\n          &(l->t[l->n - 1]),\n          sizeof(nfa_thread_T) * count);\n    }\n  }\n  --l->n;\n  *ip = listidx - 1;\n\n  return r;\n}\n\n/*\n * Check character class \"class\" against current character c.\n */\nstatic int check_char_class(int class, int c)\n{\n  switch (class) {\n  case NFA_CLASS_ALNUM:\n    if (c >= 1 && c < 128 && isalnum(c)) {\n      return OK;\n    }\n    break;\n  case NFA_CLASS_ALPHA:\n    if (c >= 1 && c < 128 && isalpha(c)) {\n      return OK;\n    }\n    break;\n  case NFA_CLASS_BLANK:\n    if (c == ' ' || c == '\\t')\n      return OK;\n    break;\n  case NFA_CLASS_CNTRL:\n    if (c >= 1 && c <= 127 && iscntrl(c)) {\n      return OK;\n    }\n    break;\n  case NFA_CLASS_DIGIT:\n    if (ascii_isdigit(c))\n      return OK;\n    break;\n  case NFA_CLASS_GRAPH:\n    if (c >= 1 && c <= 127 && isgraph(c)) {\n      return OK;\n    }\n    break;\n  case NFA_CLASS_LOWER:\n    if (mb_islower(c) && c != 170 && c != 186) {\n      return OK;\n    }\n    break;\n  case NFA_CLASS_PRINT:\n    if (vim_isprintc(c))\n      return OK;\n    break;\n  case NFA_CLASS_PUNCT:\n    if (c >= 1 && c < 128 && ispunct(c)) {\n      return OK;\n    }\n    break;\n  case NFA_CLASS_SPACE:\n    if ((c >= 9 && c <= 13) || (c == ' '))\n      return OK;\n    break;\n  case NFA_CLASS_UPPER:\n    if (mb_isupper(c)) {\n      return OK;\n    }\n    break;\n  case NFA_CLASS_XDIGIT:\n    if (ascii_isxdigit(c))\n      return OK;\n    break;\n  case NFA_CLASS_TAB:\n    if (c == '\\t')\n      return OK;\n    break;\n  case NFA_CLASS_RETURN:\n    if (c == '\\r')\n      return OK;\n    break;\n  case NFA_CLASS_BACKSPACE:\n    if (c == '\\b')\n      return OK;\n    break;\n  case NFA_CLASS_ESCAPE:\n    if (c == ESC) {\n      return OK;\n    }\n    break;\n  case NFA_CLASS_IDENT:\n    if (vim_isIDc(c)) {\n      return OK;\n    }\n    break;\n  case NFA_CLASS_KEYWORD:\n    if (reg_iswordc(c)) {\n      return OK;\n    }\n    break;\n  case NFA_CLASS_FNAME:\n    if (vim_isfilec(c)) {\n      return OK;\n    }\n    break;\n\n  default:\n    // should not be here :P\n    IEMSGN(_(e_ill_char_class), class);\n    return FAIL;\n  }\n  return FAIL;\n}\n\n/*\n * Check for a match with subexpression \"subidx\".\n * Return true if it matches.\n */\nstatic int \nmatch_backref (\n    regsub_T *sub,           /* pointers to subexpressions */\n    int subidx,\n    int *bytelen       /* out: length of match in bytes */\n)\n{\n  int len;\n\n  if (sub->in_use <= subidx) {\nretempty:\n    /* backref was not set, match an empty string */\n    *bytelen = 0;\n    return true;\n  }\n\n  if (REG_MULTI) {\n    if (sub->list.multi[subidx].start_lnum < 0\n        || sub->list.multi[subidx].end_lnum < 0)\n      goto retempty;\n    if (sub->list.multi[subidx].start_lnum == rex.lnum\n        && sub->list.multi[subidx].end_lnum == rex.lnum) {\n      len = sub->list.multi[subidx].end_col\n            - sub->list.multi[subidx].start_col;\n      if (cstrncmp(rex.line + sub->list.multi[subidx].start_col,\n                   rex.input, &len) == 0) {\n        *bytelen = len;\n        return true;\n      }\n    } else {\n      if (match_with_backref(sub->list.multi[subidx].start_lnum,\n                             sub->list.multi[subidx].start_col,\n                             sub->list.multi[subidx].end_lnum,\n                             sub->list.multi[subidx].end_col,\n                             bytelen) == RA_MATCH) {\n        return true;\n      }\n    }\n  } else {\n    if (sub->list.line[subidx].start == NULL\n        || sub->list.line[subidx].end == NULL)\n      goto retempty;\n    len = (int)(sub->list.line[subidx].end - sub->list.line[subidx].start);\n    if (cstrncmp(sub->list.line[subidx].start, rex.input, &len) == 0) {\n      *bytelen = len;\n      return true;\n    }\n  }\n  return false;\n}\n\n\n\n/*\n * Check for a match with \\z subexpression \"subidx\".\n * Return true if it matches.\n */\nstatic int \nmatch_zref (\n    int subidx,\n    int *bytelen       /* out: length of match in bytes */\n)\n{\n  int len;\n\n  cleanup_zsubexpr();\n  if (re_extmatch_in == NULL || re_extmatch_in->matches[subidx] == NULL) {\n    /* backref was not set, match an empty string */\n    *bytelen = 0;\n    return true;\n  }\n\n  len = (int)STRLEN(re_extmatch_in->matches[subidx]);\n  if (cstrncmp(re_extmatch_in->matches[subidx], rex.input, &len) == 0) {\n    *bytelen = len;\n    return true;\n  }\n  return false;\n}\n\n/*\n * Save list IDs for all NFA states of \"prog\" into \"list\".\n * Also reset the IDs to zero.\n * Only used for the recursive value lastlist[1].\n */\nstatic void nfa_save_listids(nfa_regprog_T *prog, int *list)\n{\n  int i;\n  nfa_state_T     *p;\n\n  /* Order in the list is reverse, it's a bit faster that way. */\n  p = &prog->state[0];\n  for (i = prog->nstate; --i >= 0; ) {\n    list[i] = p->lastlist[1];\n    p->lastlist[1] = 0;\n    ++p;\n  }\n}\n\n/*\n * Restore list IDs from \"list\" to all NFA states.\n */\nstatic void nfa_restore_listids(nfa_regprog_T *prog, int *list)\n{\n  int i;\n  nfa_state_T     *p;\n\n  p = &prog->state[0];\n  for (i = prog->nstate; --i >= 0; ) {\n    p->lastlist[1] = list[i];\n    ++p;\n  }\n}\n\nstatic bool nfa_re_num_cmp(uintmax_t val, int op, uintmax_t pos)\n{\n  if (op == 1) return pos > val;\n  if (op == 2) return pos < val;\n  return val == pos;\n}\n\n\n/*\n * Recursively call nfa_regmatch()\n * \"pim\" is NULL or contains info about a Postponed Invisible Match (start\n * position).\n */\nstatic int recursive_regmatch(\n    nfa_state_T *state, nfa_pim_T *pim, nfa_regprog_T *prog,\n    regsubs_T *submatch, regsubs_T *m, int **listids, int *listids_len)\n  FUNC_ATTR_NONNULL_ARG(1, 3, 5, 6, 7)\n{\n  const int save_reginput_col = (int)(rex.input - rex.line);\n  const int save_reglnum = rex.lnum;\n  const int save_nfa_match = nfa_match;\n  const int save_nfa_listid = rex.nfa_listid;\n  save_se_T *const save_nfa_endp = nfa_endp;\n  save_se_T endpos;\n  save_se_T   *endposp = NULL;\n  int need_restore = false;\n\n  if (pim != NULL) {\n    // start at the position where the postponed match was\n    if (REG_MULTI) {\n      rex.input = rex.line + pim->end.pos.col;\n    } else {\n      rex.input = pim->end.ptr;\n    }\n  }\n\n  if (state->c == NFA_START_INVISIBLE_BEFORE\n      || state->c == NFA_START_INVISIBLE_BEFORE_FIRST\n      || state->c == NFA_START_INVISIBLE_BEFORE_NEG\n      || state->c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST) {\n    // The recursive match must end at the current position. When \"pim\" is\n    // not NULL it specifies the current position.\n    endposp = &endpos;\n    if (REG_MULTI) {\n      if (pim == NULL) {\n        endpos.se_u.pos.col = (int)(rex.input - rex.line);\n        endpos.se_u.pos.lnum = rex.lnum;\n      } else {\n        endpos.se_u.pos = pim->end.pos;\n      }\n    } else {\n      if (pim == NULL) {\n        endpos.se_u.ptr = rex.input;\n      } else {\n        endpos.se_u.ptr = pim->end.ptr;\n      }\n    }\n\n    // Go back the specified number of bytes, or as far as the\n    // start of the previous line, to try matching \"\\@<=\" or\n    // not matching \"\\@<!\". This is very inefficient, limit the number of\n    // bytes if possible.\n    if (state->val <= 0) {\n      if (REG_MULTI) {\n        rex.line = reg_getline(--rex.lnum);\n        if (rex.line == NULL) {\n          // can't go before the first line\n          rex.line = reg_getline(++rex.lnum);\n        }\n      }\n      rex.input = rex.line;\n    } else {\n      if (REG_MULTI && (int)(rex.input - rex.line) < state->val) {\n        // Not enough bytes in this line, go to end of\n        // previous line.\n        rex.line = reg_getline(--rex.lnum);\n        if (rex.line == NULL) {\n          // can't go before the first line\n          rex.line = reg_getline(++rex.lnum);\n          rex.input = rex.line;\n        } else {\n          rex.input = rex.line + STRLEN(rex.line);\n        }\n      }\n      if ((int)(rex.input - rex.line) >= state->val) {\n        rex.input -= state->val;\n        rex.input -= utf_head_off(rex.line, rex.input);\n      } else {\n        rex.input = rex.line;\n      }\n    }\n  }\n\n#ifdef REGEXP_DEBUG\n  if (log_fd != stderr)\n    fclose(log_fd);\n  log_fd = NULL;\n#endif\n  // Have to clear the lastlist field of the NFA nodes, so that\n  // nfa_regmatch() and addstate() can run properly after recursion.\n  if (nfa_ll_index == 1) {\n    // Already calling nfa_regmatch() recursively.  Save the lastlist[1]\n    // values and clear them.\n    if (*listids == NULL || *listids_len < prog->nstate) {\n      xfree(*listids);\n      *listids = xmalloc(sizeof(**listids) * prog->nstate);\n      *listids_len = prog->nstate;\n    }\n    nfa_save_listids(prog, *listids);\n    need_restore = true;\n    // any value of rex.nfa_listid will do\n  } else {\n    // First recursive nfa_regmatch() call, switch to the second lastlist\n    // entry.  Make sure rex.nfa_listid is different from a previous\n    // recursive call, because some states may still have this ID.\n    nfa_ll_index++;\n    if (rex.nfa_listid <= rex.nfa_alt_listid) {\n      rex.nfa_listid = rex.nfa_alt_listid;\n    }\n  }\n\n  // Call nfa_regmatch() to check if the current concat matches at this\n  // position. The concat ends with the node NFA_END_INVISIBLE\n  nfa_endp = endposp;\n  const int result = nfa_regmatch(prog, state->out, submatch, m);\n\n  if (need_restore) {\n    nfa_restore_listids(prog, *listids);\n  } else {\n    nfa_ll_index--;\n    rex.nfa_alt_listid = rex.nfa_listid;\n  }\n\n  // restore position in input text\n  rex.lnum = save_reglnum;\n  if (REG_MULTI) {\n    rex.line = reg_getline(rex.lnum);\n  }\n  rex.input = rex.line + save_reginput_col;\n  if (result != NFA_TOO_EXPENSIVE) {\n    nfa_match = save_nfa_match;\n    rex.nfa_listid = save_nfa_listid;\n  }\n  nfa_endp = save_nfa_endp;\n\n#ifdef REGEXP_DEBUG\n  log_fd = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n  if (log_fd != NULL) {\n    fprintf(log_fd, \"****************************\\n\");\n    fprintf(log_fd, \"FINISHED RUNNING nfa_regmatch() recursively\\n\");\n    fprintf(log_fd, \"MATCH = %s\\n\", !result ? \"false\" : \"OK\");\n    fprintf(log_fd, \"****************************\\n\");\n  } else {\n    EMSG(_(e_log_open_failed));\n    log_fd = stderr;\n  }\n#endif\n\n  return result;\n}\n\n\n/*\n * Estimate the chance of a match with \"state\" failing.\n * empty match: 0\n * NFA_ANY: 1\n * specific character: 99\n */\nstatic int failure_chance(nfa_state_T *state, int depth)\n{\n  int c = state->c;\n  int l, r;\n\n  /* detect looping */\n  if (depth > 4)\n    return 1;\n\n  switch (c) {\n  case NFA_SPLIT:\n    if (state->out->c == NFA_SPLIT || state->out1->c == NFA_SPLIT)\n      /* avoid recursive stuff */\n      return 1;\n    /* two alternatives, use the lowest failure chance */\n    l = failure_chance(state->out, depth + 1);\n    r = failure_chance(state->out1, depth + 1);\n    return l < r ? l : r;\n\n  case NFA_ANY:\n    /* matches anything, unlikely to fail */\n    return 1;\n\n  case NFA_MATCH:\n  case NFA_MCLOSE:\n  case NFA_ANY_COMPOSING:\n    /* empty match works always */\n    return 0;\n\n  case NFA_START_INVISIBLE:\n  case NFA_START_INVISIBLE_FIRST:\n  case NFA_START_INVISIBLE_NEG:\n  case NFA_START_INVISIBLE_NEG_FIRST:\n  case NFA_START_INVISIBLE_BEFORE:\n  case NFA_START_INVISIBLE_BEFORE_FIRST:\n  case NFA_START_INVISIBLE_BEFORE_NEG:\n  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n  case NFA_START_PATTERN:\n    /* recursive regmatch is expensive, use low failure chance */\n    return 5;\n\n  case NFA_BOL:\n  case NFA_EOL:\n  case NFA_BOF:\n  case NFA_EOF:\n  case NFA_NEWL:\n    return 99;\n\n  case NFA_BOW:\n  case NFA_EOW:\n    return 90;\n\n  case NFA_MOPEN:\n  case NFA_MOPEN1:\n  case NFA_MOPEN2:\n  case NFA_MOPEN3:\n  case NFA_MOPEN4:\n  case NFA_MOPEN5:\n  case NFA_MOPEN6:\n  case NFA_MOPEN7:\n  case NFA_MOPEN8:\n  case NFA_MOPEN9:\n  case NFA_ZOPEN:\n  case NFA_ZOPEN1:\n  case NFA_ZOPEN2:\n  case NFA_ZOPEN3:\n  case NFA_ZOPEN4:\n  case NFA_ZOPEN5:\n  case NFA_ZOPEN6:\n  case NFA_ZOPEN7:\n  case NFA_ZOPEN8:\n  case NFA_ZOPEN9:\n  case NFA_ZCLOSE:\n  case NFA_ZCLOSE1:\n  case NFA_ZCLOSE2:\n  case NFA_ZCLOSE3:\n  case NFA_ZCLOSE4:\n  case NFA_ZCLOSE5:\n  case NFA_ZCLOSE6:\n  case NFA_ZCLOSE7:\n  case NFA_ZCLOSE8:\n  case NFA_ZCLOSE9:\n  case NFA_NOPEN:\n  case NFA_MCLOSE1:\n  case NFA_MCLOSE2:\n  case NFA_MCLOSE3:\n  case NFA_MCLOSE4:\n  case NFA_MCLOSE5:\n  case NFA_MCLOSE6:\n  case NFA_MCLOSE7:\n  case NFA_MCLOSE8:\n  case NFA_MCLOSE9:\n  case NFA_NCLOSE:\n    return failure_chance(state->out, depth + 1);\n\n  case NFA_BACKREF1:\n  case NFA_BACKREF2:\n  case NFA_BACKREF3:\n  case NFA_BACKREF4:\n  case NFA_BACKREF5:\n  case NFA_BACKREF6:\n  case NFA_BACKREF7:\n  case NFA_BACKREF8:\n  case NFA_BACKREF9:\n  case NFA_ZREF1:\n  case NFA_ZREF2:\n  case NFA_ZREF3:\n  case NFA_ZREF4:\n  case NFA_ZREF5:\n  case NFA_ZREF6:\n  case NFA_ZREF7:\n  case NFA_ZREF8:\n  case NFA_ZREF9:\n    /* backreferences don't match in many places */\n    return 94;\n\n  case NFA_LNUM_GT:\n  case NFA_LNUM_LT:\n  case NFA_COL_GT:\n  case NFA_COL_LT:\n  case NFA_VCOL_GT:\n  case NFA_VCOL_LT:\n  case NFA_MARK_GT:\n  case NFA_MARK_LT:\n  case NFA_VISUAL:\n    /* before/after positions don't match very often */\n    return 85;\n\n  case NFA_LNUM:\n    return 90;\n\n  case NFA_CURSOR:\n  case NFA_COL:\n  case NFA_VCOL:\n  case NFA_MARK:\n    /* specific positions rarely match */\n    return 98;\n\n  case NFA_COMPOSING:\n    return 95;\n\n  default:\n    if (c > 0)\n      /* character match fails often */\n      return 95;\n  }\n\n  /* something else, includes character classes */\n  return 50;\n}\n\n/*\n * Skip until the char \"c\" we know a match must start with.\n */\nstatic int skip_to_start(int c, colnr_T *colp)\n{\n  const char_u *const s = cstrchr(rex.line + *colp, c);\n  if (s == NULL) {\n    return FAIL;\n  }\n  *colp = (int)(s - rex.line);\n  return OK;\n}\n\n/*\n * Check for a match with match_text.\n * Called after skip_to_start() has found regstart.\n * Returns zero for no match, 1 for a match.\n */\nstatic long find_match_text(colnr_T startcol, int regstart, char_u *match_text)\n{\n#define PTR2LEN(x) utf_ptr2len(x)\n\n  colnr_T col = startcol;\n  int regstart_len = PTR2LEN(rex.line + startcol);\n\n  for (;;) {\n    bool match = true;\n    char_u *s1 = match_text;\n    char_u *s2 = rex.line + col + regstart_len;  // skip regstart\n    while (*s1) {\n      int c1_len = PTR2LEN(s1);\n      int c1 = PTR2CHAR(s1);\n      int c2_len = PTR2LEN(s2);\n      int c2 = PTR2CHAR(s2);\n\n      if ((c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))\n          || c1_len != c2_len) {\n        match = false;\n        break;\n      }\n      s1 += c1_len;\n      s2 += c2_len;\n    }\n    if (match\n        // check that no composing char follows\n        && !utf_iscomposing(PTR2CHAR(s2))) {\n      cleanup_subexpr();\n      if (REG_MULTI) {\n        rex.reg_startpos[0].lnum = rex.lnum;\n        rex.reg_startpos[0].col = col;\n        rex.reg_endpos[0].lnum = rex.lnum;\n        rex.reg_endpos[0].col = s2 - rex.line;\n      } else {\n        rex.reg_startp[0] = rex.line + col;\n        rex.reg_endp[0] = s2;\n      }\n      return 1L;\n    }\n\n    // Try finding regstart after the current match.\n    col += regstart_len;  // skip regstart\n    if (skip_to_start(regstart, &col) == FAIL) {\n      break;\n    }\n  }\n  return 0L;\n\n#undef PTR2LEN\n}\n\nstatic int nfa_did_time_out(void)\n{\n  if (nfa_time_limit != NULL && profile_passed_limit(*nfa_time_limit)) {\n    if (nfa_timed_out != NULL) {\n      *nfa_timed_out = true;\n    }\n    return true;\n  }\n  return false;\n}\n\n/// Main matching routine.\n///\n/// Run NFA to determine whether it matches rex.input.\n///\n/// When \"nfa_endp\" is not NULL it is a required end-of-match position.\n///\n/// Return true if there is a match, false if there is no match,\n/// NFA_TOO_EXPENSIVE if we end up with too many states.\n/// When there is a match \"submatch\" contains the positions.\n///\n/// Note: Caller must ensure that: start != NULL.\nstatic int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start,\n                        regsubs_T *submatch, regsubs_T *m)\n  FUNC_ATTR_NONNULL_ARG(1, 2, 4)\n{\n  int result = false;\n  int flag = 0;\n  bool go_to_nextline = false;\n  nfa_thread_T *t;\n  nfa_list_T list[2];\n  int listidx;\n  nfa_list_T  *thislist;\n  nfa_list_T  *nextlist;\n  int         *listids = NULL;\n  int listids_len = 0;\n  nfa_state_T *add_state;\n  bool add_here;\n  int add_count;\n  int add_off = 0;\n  int toplevel = start->c == NFA_MOPEN;\n  regsubs_T *r;\n#ifdef NFA_REGEXP_DEBUG_LOG\n  FILE        *debug = fopen(NFA_REGEXP_DEBUG_LOG, \"a\");\n\n  if (debug == NULL) {\n    EMSG2(\"(NFA) COULD NOT OPEN %s!\", NFA_REGEXP_DEBUG_LOG);\n    return false;\n  }\n#endif\n  // Some patterns may take a long time to match, especially when using\n  // recursive_regmatch(). Allow interrupting them with CTRL-C.\n  fast_breakcheck();\n  if (got_int) {\n#ifdef NFA_REGEXP_DEBUG_LOG\n    fclose(debug);\n#endif\n    return false;\n  }\n  if (nfa_did_time_out()) {\n#ifdef NFA_REGEXP_DEBUG_LOG\n    fclose(debug);\n#endif\n    return false;\n  }\n\n  nfa_match = false;\n\n  // Allocate memory for the lists of nodes.\n  size_t size = (prog->nstate + 1) * sizeof(nfa_thread_T);\n  list[0].t = xmalloc(size);\n  list[0].len = prog->nstate + 1;\n  list[1].t = xmalloc(size);\n  list[1].len = prog->nstate + 1;\n\n#ifdef REGEXP_DEBUG\n  log_fd = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n  if (log_fd != NULL) {\n    fprintf(log_fd, \"**********************************\\n\");\n    nfa_set_code(start->c);\n    fprintf(log_fd, \" RUNNING nfa_regmatch() starting with state %d, code %s\\n\",\n        abs(start->id), code);\n    fprintf(log_fd, \"**********************************\\n\");\n  } else {\n    EMSG(_(e_log_open_failed));\n    log_fd = stderr;\n  }\n#endif\n\n  thislist = &list[0];\n  thislist->n = 0;\n  thislist->has_pim = false;\n  nextlist = &list[1];\n  nextlist->n = 0;\n  nextlist->has_pim = false;\n#ifdef REGEXP_DEBUG\n  fprintf(log_fd, \"(---) STARTSTATE first\\n\");\n#endif\n  thislist->id = rex.nfa_listid + 1;\n\n  // Inline optimized code for addstate(thislist, start, m, 0) if we know\n  // it's the first MOPEN.\n  if (toplevel) {\n    if (REG_MULTI) {\n      m->norm.list.multi[0].start_lnum = rex.lnum;\n      m->norm.list.multi[0].start_col = (colnr_T)(rex.input - rex.line);\n    } else {\n      m->norm.list.line[0].start = rex.input;\n    }\n    m->norm.in_use = 1;\n    r = addstate(thislist, start->out, m, NULL, 0);\n  } else {\n    r = addstate(thislist, start, m, NULL, 0);\n  }\n  if (r == NULL) {\n    nfa_match = NFA_TOO_EXPENSIVE;\n    goto theend;\n  }\n\n#define ADD_STATE_IF_MATCH(state) \\\n  if (result) { \\\n    add_state = state->out; \\\n    add_off = clen; \\\n  }\n\n  /*\n   * Run for each character.\n   */\n  for (;; ) {\n    int curc = utf_ptr2char(rex.input);\n    int clen = utfc_ptr2len(rex.input);\n    if (curc == NUL) {\n      clen = 0;\n      go_to_nextline = false;\n    }\n\n    /* swap lists */\n    thislist = &list[flag];\n    nextlist = &list[flag ^= 1];\n    nextlist->n = 0;                // clear nextlist\n    nextlist->has_pim = false;\n    rex.nfa_listid++;\n    if (prog->re_engine == AUTOMATIC_ENGINE\n        && (rex.nfa_listid >= NFA_MAX_STATES)) {\n      // Too many states, retry with old engine.\n      nfa_match = NFA_TOO_EXPENSIVE;\n      goto theend;\n    }\n\n    thislist->id = rex.nfa_listid;\n    nextlist->id = rex.nfa_listid + 1;\n\n#ifdef REGEXP_DEBUG\n    fprintf(log_fd, \"------------------------------------------\\n\");\n    fprintf(log_fd, \">>> Reginput is \\\"%s\\\"\\n\", rex.input);\n    fprintf(log_fd,\n            \">>> Advanced one character... Current char is %c (code %d) \\n\",\n            curc,\n            (int)curc);\n    fprintf(log_fd, \">>> Thislist has %d states available: \", thislist->n);\n    {\n      int i;\n\n      for (i = 0; i < thislist->n; i++)\n        fprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));\n    }\n    fprintf(log_fd, \"\\n\");\n#endif\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n    fprintf(debug, \"\\n-------------------\\n\");\n#endif\n    /*\n     * If the state lists are empty we can stop.\n     */\n    if (thislist->n == 0)\n      break;\n\n    // compute nextlist\n    for (listidx = 0; listidx < thislist->n; listidx++) {\n      // If the list gets very long there probably is something wrong.\n      // At least allow interrupting with CTRL-C.\n      fast_breakcheck();\n      if (got_int) {\n        break;\n      }\n      if (nfa_time_limit != NULL && ++nfa_time_count == 20) {\n        nfa_time_count = 0;\n        if (nfa_did_time_out()) {\n          break;\n        }\n      }\n      t = &thislist->t[listidx];\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n      nfa_set_code(t->state->c);\n      fprintf(debug, \"%s, \", code);\n#endif\n#ifdef REGEXP_DEBUG\n      {\n        int col;\n\n        if (t->subs.norm.in_use <= 0) {\n          col = -1;\n        } else if (REG_MULTI) {\n          col = t->subs.norm.list.multi[0].start_col;\n        } else {\n          col = (int)(t->subs.norm.list.line[0].start - rex.line);\n        }\n        nfa_set_code(t->state->c);\n        fprintf(log_fd, \"(%d) char %d %s (start col %d)%s... \\n\",\n                abs(t->state->id), (int)t->state->c, code, col,\n                pim_info(&t->pim));\n      }\n#endif\n\n      /*\n       * Handle the possible codes of the current state.\n       * The most important is NFA_MATCH.\n       */\n      add_state = NULL;\n      add_here = false;\n      add_count = 0;\n      switch (t->state->c) {\n      case NFA_MATCH:\n      {\n        // If the match is not at the start of the line, ends before a\n        // composing characters and rex.reg_icombine is not set, that\n        // is not really a match.\n        if (!rex.reg_icombine\n            && rex.input != rex.line\n            && utf_iscomposing(curc)) {\n          break;\n        }\n        nfa_match = true;\n        copy_sub(&submatch->norm, &t->subs.norm);\n        if (rex.nfa_has_zsubexpr) {\n          copy_sub(&submatch->synt, &t->subs.synt);\n        }\n#ifdef REGEXP_DEBUG\n        log_subsexpr(&t->subs);\n#endif\n        // Found the left-most longest match, do not look at any other\n        // states at this position.  When the list of states is going\n        // to be empty quit without advancing, so that \"rex.input\" is\n        // correct.\n        if (nextlist->n == 0) {\n          clen = 0;\n        }\n        goto nextchar;\n      }\n\n      case NFA_END_INVISIBLE:\n      case NFA_END_INVISIBLE_NEG:\n      case NFA_END_PATTERN:\n        // This is only encountered after a NFA_START_INVISIBLE or\n        // NFA_START_INVISIBLE_BEFORE node.\n        // They surround a zero-width group, used with \"\\@=\", \"\\&\",\n        // \"\\@!\", \"\\@<=\" and \"\\@<!\".\n        // If we got here, it means that the current \"invisible\" group\n        // finished successfully, so return control to the parent\n        // nfa_regmatch().  For a look-behind match only when it ends\n        // in the position in \"nfa_endp\".\n        // Submatches are stored in *m, and used in the parent call.\n#ifdef REGEXP_DEBUG\n        if (nfa_endp != NULL) {\n          if (REG_MULTI) {\n            fprintf(log_fd,\n                    \"Current lnum: %d, endp lnum: %d;\"\n                    \" current col: %d, endp col: %d\\n\",\n                    (int)rex.lnum,\n                    (int)nfa_endp->se_u.pos.lnum,\n                    (int)(rex.input - rex.line),\n                    nfa_endp->se_u.pos.col);\n          } else {\n            fprintf(log_fd, \"Current col: %d, endp col: %d\\n\",\n                    (int)(rex.input - rex.line),\n                    (int)(nfa_endp->se_u.ptr - rex.input));\n          }\n        }\n#endif\n        // If \"nfa_endp\" is set it's only a match if it ends at\n        // \"nfa_endp\"\n        if (nfa_endp != NULL\n            && (REG_MULTI\n                ? (rex.lnum != nfa_endp->se_u.pos.lnum\n                   || (int)(rex.input - rex.line) != nfa_endp->se_u.pos.col)\n                : rex.input != nfa_endp->se_u.ptr)) {\n          break;\n        }\n        // do not set submatches for \\@!\n        if (t->state->c != NFA_END_INVISIBLE_NEG) {\n          copy_sub(&m->norm, &t->subs.norm);\n          if (rex.nfa_has_zsubexpr) {\n            copy_sub(&m->synt, &t->subs.synt);\n          }\n        }\n#ifdef REGEXP_DEBUG\n        fprintf(log_fd, \"Match found:\\n\");\n        log_subsexpr(m);\n#endif\n        nfa_match = true;\n        // See comment above at \"goto nextchar\".\n        if (nextlist->n == 0) {\n          clen = 0;\n        }\n        goto nextchar;\n\n      case NFA_START_INVISIBLE:\n      case NFA_START_INVISIBLE_FIRST:\n      case NFA_START_INVISIBLE_NEG:\n      case NFA_START_INVISIBLE_NEG_FIRST:\n      case NFA_START_INVISIBLE_BEFORE:\n      case NFA_START_INVISIBLE_BEFORE_FIRST:\n      case NFA_START_INVISIBLE_BEFORE_NEG:\n      case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n      {\n#ifdef REGEXP_DEBUG\n        fprintf(log_fd, \"Failure chance invisible: %d, what follows: %d\\n\",\n            failure_chance(t->state->out, 0),\n            failure_chance(t->state->out1->out, 0));\n#endif\n        // Do it directly if there already is a PIM or when\n        // nfa_postprocess() detected it will work better.\n        if (t->pim.result != NFA_PIM_UNUSED\n            || t->state->c == NFA_START_INVISIBLE_FIRST\n            || t->state->c == NFA_START_INVISIBLE_NEG_FIRST\n            || t->state->c == NFA_START_INVISIBLE_BEFORE_FIRST\n            || t->state->c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST) {\n          int in_use = m->norm.in_use;\n\n          // Copy submatch info for the recursive call, opposite\n          // of what happens on success below.\n          copy_sub_off(&m->norm, &t->subs.norm);\n          if (rex.nfa_has_zsubexpr) {\n            copy_sub_off(&m->synt, &t->subs.synt);\n          }\n          // First try matching the invisible match, then what\n          // follows.\n          result = recursive_regmatch(t->state, NULL, prog, submatch, m,\n                                      &listids, &listids_len);\n          if (result == NFA_TOO_EXPENSIVE) {\n            nfa_match = result;\n            goto theend;\n          }\n\n          // for \\@! and \\@<! it is a match when the result is\n          // false\n          if (result != (t->state->c == NFA_START_INVISIBLE_NEG\n                         || t->state->c == NFA_START_INVISIBLE_NEG_FIRST\n                         || t->state->c\n                         == NFA_START_INVISIBLE_BEFORE_NEG\n                         || t->state->c\n                         == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {\n            // Copy submatch info from the recursive call\n            copy_sub_off(&t->subs.norm, &m->norm);\n            if (rex.nfa_has_zsubexpr) {\n              copy_sub_off(&t->subs.synt, &m->synt);\n            }\n            // If the pattern has \\ze and it matched in the\n            // sub pattern, use it.\n            copy_ze_off(&t->subs.norm, &m->norm);\n\n            // t->state->out1 is the corresponding\n            // END_INVISIBLE node; Add its out to the current\n            // list (zero-width match).\n            add_here = true;\n            add_state = t->state->out1->out;\n          }\n          m->norm.in_use = in_use;\n        } else {\n          nfa_pim_T pim;\n\n          // First try matching what follows.  Only if a match\n          // is found verify the invisible match matches.  Add a\n          // nfa_pim_T to the following states, it contains info\n          // about the invisible match.\n          pim.state = t->state;\n          pim.result = NFA_PIM_TODO;\n          pim.subs.norm.in_use = 0;\n          pim.subs.synt.in_use = 0;\n          if (REG_MULTI) {\n            pim.end.pos.col = (int)(rex.input - rex.line);\n            pim.end.pos.lnum = rex.lnum;\n          } else {\n            pim.end.ptr = rex.input;\n          }\n          // t->state->out1 is the corresponding END_INVISIBLE\n          // node; Add its out to the current list (zero-width\n          // match).\n          if (addstate_here(thislist, t->state->out1->out, &t->subs,\n                            &pim, &listidx) == NULL) {\n            nfa_match = NFA_TOO_EXPENSIVE;\n            goto theend;\n          }\n        }\n      }\n      break;\n\n      case NFA_START_PATTERN:\n      {\n        nfa_state_T *skip = NULL;\n#ifdef REGEXP_DEBUG\n        int skip_lid = 0;\n#endif\n\n        // There is no point in trying to match the pattern if the\n        // output state is not going to be added to the list.\n        if (state_in_list(nextlist, t->state->out1->out, &t->subs)) {\n          skip = t->state->out1->out;\n#ifdef REGEXP_DEBUG\n          skip_lid = nextlist->id;\n#endif\n        } else if (state_in_list(nextlist,\n                       t->state->out1->out->out, &t->subs)) {\n          skip = t->state->out1->out->out;\n#ifdef REGEXP_DEBUG\n          skip_lid = nextlist->id;\n#endif\n        } else if (state_in_list(thislist,\n                       t->state->out1->out->out, &t->subs)) {\n          skip = t->state->out1->out->out;\n#ifdef REGEXP_DEBUG\n          skip_lid = thislist->id;\n#endif\n        }\n        if (skip != NULL) {\n#ifdef REGEXP_DEBUG\n          nfa_set_code(skip->c);\n          fprintf(\n              log_fd,\n              \"> Not trying to match pattern, output state %d is already in list %d. char %d: %s\\n\",\n              abs(skip->id), skip_lid, skip->c, code);\n#endif\n          break;\n        }\n        // Copy submatch info to the recursive call, opposite of what\n        // happens afterwards.\n        copy_sub_off(&m->norm, &t->subs.norm);\n        if (rex.nfa_has_zsubexpr) {\n          copy_sub_off(&m->synt, &t->subs.synt);\n        }\n\n        // First try matching the pattern.\n        result = recursive_regmatch(t->state, NULL, prog, submatch, m,\n                                    &listids, &listids_len);\n        if (result == NFA_TOO_EXPENSIVE) {\n          nfa_match = result;\n          goto theend;\n        }\n        if (result) {\n          int bytelen;\n\n#ifdef REGEXP_DEBUG\n          fprintf(log_fd, \"NFA_START_PATTERN matches:\\n\");\n          log_subsexpr(m);\n#endif\n          // Copy submatch info from the recursive call\n          copy_sub_off(&t->subs.norm, &m->norm);\n          if (rex.nfa_has_zsubexpr) {\n            copy_sub_off(&t->subs.synt, &m->synt);\n          }\n          // Now we need to skip over the matched text and then\n          // continue with what follows.\n          if (REG_MULTI) {\n            // TODO(RE): multi-line match\n            bytelen = m->norm.list.multi[0].end_col\n                      - (int)(rex.input - rex.line);\n          } else {\n            bytelen = (int)(m->norm.list.line[0].end - rex.input);\n          }\n\n#ifdef REGEXP_DEBUG\n          fprintf(log_fd, \"NFA_START_PATTERN length: %d\\n\", bytelen);\n#endif\n          if (bytelen == 0) {\n            // empty match, output of corresponding\n            // NFA_END_PATTERN/NFA_SKIP to be used at current\n            // position\n            add_here = true;\n            add_state = t->state->out1->out->out;\n          } else if (bytelen <= clen) {\n            // match current character, output of corresponding\n            // NFA_END_PATTERN to be used at next position.\n            add_state = t->state->out1->out->out;\n            add_off = clen;\n          } else {\n            // skip over the matched characters, set character\n            // count in NFA_SKIP\n            add_state = t->state->out1->out;\n            add_off = bytelen;\n            add_count = bytelen - clen;\n          }\n        }\n        break;\n      }\n\n      case NFA_BOL:\n        if (rex.input == rex.line) {\n          add_here = true;\n          add_state = t->state->out;\n        }\n        break;\n\n      case NFA_EOL:\n        if (curc == NUL) {\n          add_here = true;\n          add_state = t->state->out;\n        }\n        break;\n\n      case NFA_BOW:\n        result = true;\n\n        if (curc == NUL) {\n          result = false;\n        } else {\n          int this_class;\n\n          // Get class of current and previous char (if it exists).\n          this_class = mb_get_class_tab(rex.input, rex.reg_buf->b_chartab);\n          if (this_class <= 1) {\n            result = false;\n          } else if (reg_prev_class() == this_class) {\n            result = false;\n          }\n        }\n        if (result) {\n          add_here = true;\n          add_state = t->state->out;\n        }\n        break;\n\n      case NFA_EOW:\n        result = true;\n        if (rex.input == rex.line) {\n          result = false;\n        } else {\n          int this_class, prev_class;\n\n          // Get class of current and previous char (if it exists).\n          this_class = mb_get_class_tab(rex.input, rex.reg_buf->b_chartab);\n          prev_class = reg_prev_class();\n          if (this_class == prev_class\n              || prev_class == 0 || prev_class == 1) {\n            result = false;\n          }\n        }\n        if (result) {\n          add_here = true;\n          add_state = t->state->out;\n        }\n        break;\n\n      case NFA_BOF:\n        if (rex.lnum == 0 && rex.input == rex.line\n            && (!REG_MULTI || rex.reg_firstlnum == 1)) {\n          add_here = true;\n          add_state = t->state->out;\n        }\n        break;\n\n      case NFA_EOF:\n        if (rex.lnum == rex.reg_maxline && curc == NUL) {\n          add_here = true;\n          add_state = t->state->out;\n        }\n        break;\n\n      case NFA_COMPOSING:\n      {\n        int mc = curc;\n        int len = 0;\n        nfa_state_T *end;\n        nfa_state_T *sta;\n        int cchars[MAX_MCO];\n        int ccount = 0;\n        int j;\n\n        sta = t->state->out;\n        len = 0;\n        if (utf_iscomposing(sta->c)) {\n          // Only match composing character(s), ignore base\n          // character.  Used for \".{composing}\" and \"{composing}\"\n          // (no preceding character).\n          len += mb_char2len(mc);\n        }\n        if (rex.reg_icombine && len == 0) {\n          // If \\Z was present, then ignore composing characters.\n          // When ignoring the base character this always matches.\n          if (sta->c != curc) {\n            result = FAIL;\n          } else {\n            result = OK;\n          }\n          while (sta->c != NFA_END_COMPOSING) {\n            sta = sta->out;\n          }\n        } else if (len > 0 || mc == sta->c) {\n          // Check base character matches first, unless ignored.\n          if (len == 0) {\n            len += mb_char2len(mc);\n            sta = sta->out;\n          }\n\n          // We don't care about the order of composing characters.\n          // Get them into cchars[] first.\n          while (len < clen) {\n            mc = utf_ptr2char(rex.input + len);\n            cchars[ccount++] = mc;\n            len += mb_char2len(mc);\n            if (ccount == MAX_MCO)\n              break;\n          }\n\n          // Check that each composing char in the pattern matches a\n          // composing char in the text.  We do not check if all\n          // composing chars are matched.\n          result = OK;\n          while (sta->c != NFA_END_COMPOSING) {\n            for (j = 0; j < ccount; ++j)\n              if (cchars[j] == sta->c)\n                break;\n            if (j == ccount) {\n              result = FAIL;\n              break;\n            }\n            sta = sta->out;\n          }\n        } else\n          result = FAIL;\n\n        end = t->state->out1;               // NFA_END_COMPOSING\n        ADD_STATE_IF_MATCH(end);\n        break;\n      }\n\n      case NFA_NEWL:\n        if (curc == NUL && !rex.reg_line_lbr && REG_MULTI\n            && rex.lnum <= rex.reg_maxline) {\n          go_to_nextline = true;\n          // Pass -1 for the offset, which means taking the position\n          // at the start of the next line.\n          add_state = t->state->out;\n          add_off = -1;\n        } else if (curc == '\\n' && rex.reg_line_lbr) {\n          // match \\n as if it is an ordinary character\n          add_state = t->state->out;\n          add_off = 1;\n        }\n        break;\n\n      case NFA_START_COLL:\n      case NFA_START_NEG_COLL:\n      {\n        // What follows is a list of characters, until NFA_END_COLL.\n        // One of them must match or none of them must match.\n        nfa_state_T     *state;\n        int result_if_matched;\n        int c1, c2;\n\n        // Never match EOL. If it's part of the collection it is added\n        // as a separate state with an OR.\n        if (curc == NUL) {\n          break;\n        }\n\n        state = t->state->out;\n        result_if_matched = (t->state->c == NFA_START_COLL);\n        for (;; ) {\n          if (state->c == NFA_END_COLL) {\n            result = !result_if_matched;\n            break;\n          }\n          if (state->c == NFA_RANGE_MIN) {\n            c1 = state->val;\n            state = state->out;             // advance to NFA_RANGE_MAX\n            c2 = state->val;\n#ifdef REGEXP_DEBUG\n            fprintf(log_fd, \"NFA_RANGE_MIN curc=%d c1=%d c2=%d\\n\",\n                curc, c1, c2);\n#endif\n            if (curc >= c1 && curc <= c2) {\n              result = result_if_matched;\n              break;\n            }\n            if (rex.reg_ic) {\n              int curc_low = utf_fold(curc);\n              int done = false;\n\n              for (; c1 <= c2; c1++) {\n                if (utf_fold(c1) == curc_low) {\n                  result = result_if_matched;\n                  done = true;\n                  break;\n                }\n              }\n              if (done) {\n                break;\n              }\n            }\n          } else if (state->c < 0 ? check_char_class(state->c, curc)\n                     : (curc == state->c\n                        || (rex.reg_ic\n                            && utf_fold(curc) == utf_fold(state->c)))) {\n            result = result_if_matched;\n            break;\n          }\n          state = state->out;\n        }\n        if (result) {\n          // next state is in out of the NFA_END_COLL, out1 of\n          // START points to the END state\n          add_state = t->state->out1->out;\n          add_off = clen;\n        }\n        break;\n      }\n\n      case NFA_ANY:\n        // Any char except '\\0', (end of input) does not match.\n        if (curc > 0) {\n          add_state = t->state->out;\n          add_off = clen;\n        }\n        break;\n\n      case NFA_ANY_COMPOSING:\n        // On a composing character skip over it.  Otherwise do\n        // nothing.  Always matches.\n        if (utf_iscomposing(curc)) {\n          add_off = clen;\n        } else {\n          add_here = true;\n          add_off = 0;\n        }\n        add_state = t->state->out;\n        break;\n\n      // Character classes like \\a for alpha, \\d for digit etc.\n      case NFA_IDENT:           //  \\i\n        result = vim_isIDc(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_SIDENT:          //  \\I\n        result = !ascii_isdigit(curc) && vim_isIDc(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_KWORD:           //  \\k\n        result = vim_iswordp_buf(rex.input, rex.reg_buf);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_SKWORD:          //  \\K\n        result = !ascii_isdigit(curc)\n                 && vim_iswordp_buf(rex.input, rex.reg_buf);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_FNAME:           //  \\f\n        result = vim_isfilec(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_SFNAME:          //  \\F\n        result = !ascii_isdigit(curc) && vim_isfilec(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_PRINT:           //  \\p\n        result = vim_isprintc(PTR2CHAR(rex.input));\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_SPRINT:          //  \\P\n        result = !ascii_isdigit(curc) && vim_isprintc(PTR2CHAR(rex.input));\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_WHITE:           //  \\s\n        result = ascii_iswhite(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_NWHITE:          //  \\S\n        result = curc != NUL && !ascii_iswhite(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_DIGIT:           //  \\d\n        result = ri_digit(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_NDIGIT:          //  \\D\n        result = curc != NUL && !ri_digit(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_HEX:             //  \\x\n        result = ri_hex(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_NHEX:            //  \\X\n        result = curc != NUL && !ri_hex(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_OCTAL:           //  \\o\n        result = ri_octal(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_NOCTAL:          //  \\O\n        result = curc != NUL && !ri_octal(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_WORD:            //  \\w\n        result = ri_word(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_NWORD:           //  \\W\n        result = curc != NUL && !ri_word(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_HEAD:            //  \\h\n        result = ri_head(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_NHEAD:           //  \\H\n        result = curc != NUL && !ri_head(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_ALPHA:           //  \\a\n        result = ri_alpha(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_NALPHA:          //  \\A\n        result = curc != NUL && !ri_alpha(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_LOWER:           //  \\l\n        result = ri_lower(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_NLOWER:          //  \\L\n        result = curc != NUL && !ri_lower(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_UPPER:           //  \\u\n        result = ri_upper(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_NUPPER:          // \\U\n        result = curc != NUL && !ri_upper(curc);\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_LOWER_IC:        // [a-z]\n        result = ri_lower(curc) || (rex.reg_ic && ri_upper(curc));\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_NLOWER_IC:       // [^a-z]\n        result = curc != NUL\n                 && !(ri_lower(curc) || (rex.reg_ic && ri_upper(curc)));\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_UPPER_IC:        // [A-Z]\n        result = ri_upper(curc) || (rex.reg_ic && ri_lower(curc));\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_NUPPER_IC:       // [^A-Z]\n        result = curc != NUL\n                 && !(ri_upper(curc) || (rex.reg_ic && ri_lower(curc)));\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n\n      case NFA_BACKREF1:\n      case NFA_BACKREF2:\n      case NFA_BACKREF3:\n      case NFA_BACKREF4:\n      case NFA_BACKREF5:\n      case NFA_BACKREF6:\n      case NFA_BACKREF7:\n      case NFA_BACKREF8:\n      case NFA_BACKREF9:\n      case NFA_ZREF1:\n      case NFA_ZREF2:\n      case NFA_ZREF3:\n      case NFA_ZREF4:\n      case NFA_ZREF5:\n      case NFA_ZREF6:\n      case NFA_ZREF7:\n      case NFA_ZREF8:\n      case NFA_ZREF9:\n        // \\1 .. \\9  \\z1 .. \\z9\n      {\n        int subidx;\n        int bytelen;\n\n        if (t->state->c <= NFA_BACKREF9) {\n          subidx = t->state->c - NFA_BACKREF1 + 1;\n          result = match_backref(&t->subs.norm, subidx, &bytelen);\n        } else {\n          subidx = t->state->c - NFA_ZREF1 + 1;\n          result = match_zref(subidx, &bytelen);\n        }\n\n        if (result) {\n          if (bytelen == 0) {\n            // empty match always works, output of NFA_SKIP to be\n            // used next\n            add_here = true;\n            add_state = t->state->out->out;\n          } else if (bytelen <= clen) {\n            // match current character, jump ahead to out of\n            // NFA_SKIP\n            add_state = t->state->out->out;\n            add_off = clen;\n          } else {\n            // skip over the matched characters, set character\n            // count in NFA_SKIP\n            add_state = t->state->out;\n            add_off = bytelen;\n            add_count = bytelen - clen;\n          }\n        }\n        break;\n      }\n      case NFA_SKIP:\n        // character of previous matching \\1 .. \\9  or \\@>\n        if (t->count - clen <= 0) {\n          // end of match, go to what follows\n          add_state = t->state->out;\n          add_off = clen;\n        } else {\n          // add state again with decremented count\n          add_state = t->state;\n          add_off = 0;\n          add_count = t->count - clen;\n        }\n        break;\n\n      case NFA_LNUM:\n      case NFA_LNUM_GT:\n      case NFA_LNUM_LT:\n        assert(t->state->val >= 0\n               && !((rex.reg_firstlnum > 0\n                     && rex.lnum > LONG_MAX - rex.reg_firstlnum)\n                    || (rex.reg_firstlnum < 0\n                        && rex.lnum < LONG_MIN + rex.reg_firstlnum))\n               && rex.lnum + rex.reg_firstlnum >= 0);\n        result = (REG_MULTI\n                  && nfa_re_num_cmp((uintmax_t)t->state->val,\n                                    t->state->c - NFA_LNUM,\n                                    (uintmax_t)(rex.lnum + rex.reg_firstlnum)));\n        if (result) {\n          add_here = true;\n          add_state = t->state->out;\n        }\n        break;\n\n      case NFA_COL:\n      case NFA_COL_GT:\n      case NFA_COL_LT:\n        assert(t->state->val >= 0\n               && rex.input >= rex.line\n               && (uintmax_t)(rex.input - rex.line) <= UINTMAX_MAX - 1);\n        result = nfa_re_num_cmp((uintmax_t)t->state->val,\n                                t->state->c - NFA_COL,\n                                (uintmax_t)(rex.input - rex.line + 1));\n        if (result) {\n          add_here = true;\n          add_state = t->state->out;\n        }\n        break;\n\n      case NFA_VCOL:\n      case NFA_VCOL_GT:\n      case NFA_VCOL_LT:\n        {\n          int op = t->state->c - NFA_VCOL;\n          colnr_T col = (colnr_T)(rex.input - rex.line);\n\n          // Bail out quickly when there can't be a match, avoid the overhead of\n          // win_linetabsize() on long lines.\n          if (op != 1 && col > t->state->val * MB_MAXBYTES) {\n            break;\n          }\n\n          result = false;\n          win_T *wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n          if (op == 1 && col - 1 > t->state->val && col > 100) {\n            long ts = wp->w_buffer->b_p_ts;\n\n            // Guess that a character won't use more columns than 'tabstop',\n            // with a minimum of 4.\n            if (ts < 4) {\n              ts = 4;\n            }\n            result = col > t->state->val * ts;\n          }\n          if (!result) {\n            uintmax_t lts = win_linetabsize(wp, rex.line, col);\n            assert(t->state->val >= 0);\n            result = nfa_re_num_cmp((uintmax_t)t->state->val, op, lts + 1);\n          }\n          if (result) {\n            add_here = true;\n            add_state = t->state->out;\n          }\n        }\n        break;\n\n      case NFA_MARK:\n      case NFA_MARK_GT:\n      case NFA_MARK_LT:\n      {\n        pos_T *pos = getmark_buf(rex.reg_buf, t->state->val, false);\n\n        // Compare the mark position to the match position, if the mark\n        // exists and mark is set in reg_buf.\n        if (pos != NULL && pos->lnum > 0) {\n          const colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n            && pos->col == MAXCOL\n            ? (colnr_T)STRLEN(reg_getline(pos->lnum - rex.reg_firstlnum))\n            : pos->col;\n\n          result = pos->lnum == rex.lnum + rex.reg_firstlnum\n            ? (pos_col == (colnr_T)(rex.input - rex.line)\n               ? t->state->c == NFA_MARK\n               : (pos_col < (colnr_T)(rex.input - rex.line)\n                  ? t->state->c == NFA_MARK_GT\n                  : t->state->c == NFA_MARK_LT))\n            : (pos->lnum < rex.lnum + rex.reg_firstlnum\n               ? t->state->c == NFA_MARK_GT\n               : t->state->c == NFA_MARK_LT);\n          if (result) {\n            add_here = true;\n            add_state = t->state->out;\n          }\n        }\n        break;\n      }\n\n      case NFA_CURSOR:\n        result = rex.reg_win != NULL\n          && (rex.lnum + rex.reg_firstlnum == rex.reg_win->w_cursor.lnum)\n          && ((colnr_T)(rex.input - rex.line) == rex.reg_win->w_cursor.col);\n        if (result) {\n          add_here = true;\n          add_state = t->state->out;\n        }\n        break;\n\n      case NFA_VISUAL:\n        result = reg_match_visual();\n        if (result) {\n          add_here = true;\n          add_state = t->state->out;\n        }\n        break;\n\n      case NFA_MOPEN1:\n      case NFA_MOPEN2:\n      case NFA_MOPEN3:\n      case NFA_MOPEN4:\n      case NFA_MOPEN5:\n      case NFA_MOPEN6:\n      case NFA_MOPEN7:\n      case NFA_MOPEN8:\n      case NFA_MOPEN9:\n      case NFA_ZOPEN:\n      case NFA_ZOPEN1:\n      case NFA_ZOPEN2:\n      case NFA_ZOPEN3:\n      case NFA_ZOPEN4:\n      case NFA_ZOPEN5:\n      case NFA_ZOPEN6:\n      case NFA_ZOPEN7:\n      case NFA_ZOPEN8:\n      case NFA_ZOPEN9:\n      case NFA_NOPEN:\n      case NFA_ZSTART:\n        // These states are only added to be able to bail out when\n        // they are added again, nothing is to be done.\n        break;\n\n      default:          // regular character\n      {\n        int c = t->state->c;\n\n#ifdef REGEXP_DEBUG\n        if (c < 0) {\n          IEMSGN(\"INTERNAL: Negative state char: %\" PRId64, c);\n        }\n#endif\n        result = (c == curc);\n\n        if (!result && rex.reg_ic) {\n          result = utf_fold(c) == utf_fold(curc);\n        }\n\n        // If rex.reg_icombine is not set only skip over the character\n        // itself.  When it is set skip over composing characters.\n        if (result && !rex.reg_icombine) {\n          clen = utf_ptr2len(rex.input);\n        }\n\n        ADD_STATE_IF_MATCH(t->state);\n        break;\n      }\n      }       // switch (t->state->c)\n\n      if (add_state != NULL) {\n        nfa_pim_T *pim;\n        nfa_pim_T pim_copy;\n\n        if (t->pim.result == NFA_PIM_UNUSED)\n          pim = NULL;\n        else\n          pim = &t->pim;\n\n        // Handle the postponed invisible match if the match might end\n        // without advancing and before the end of the line.\n        if (pim != NULL && (clen == 0 || match_follows(add_state, 0))) {\n          if (pim->result == NFA_PIM_TODO) {\n#ifdef REGEXP_DEBUG\n            fprintf(log_fd, \"\\n\");\n            fprintf(log_fd, \"==================================\\n\");\n            fprintf(log_fd, \"Postponed recursive nfa_regmatch()\\n\");\n            fprintf(log_fd, \"\\n\");\n#endif\n            result = recursive_regmatch(pim->state, pim, prog, submatch, m,\n                                        &listids, &listids_len);\n            pim->result = result ? NFA_PIM_MATCH : NFA_PIM_NOMATCH;\n            // for \\@! and \\@<! it is a match when the result is\n            // false\n            if (result != (pim->state->c == NFA_START_INVISIBLE_NEG\n                           || pim->state->c == NFA_START_INVISIBLE_NEG_FIRST\n                           || pim->state->c\n                           == NFA_START_INVISIBLE_BEFORE_NEG\n                           || pim->state->c\n                           == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {\n              // Copy submatch info from the recursive call\n              copy_sub_off(&pim->subs.norm, &m->norm);\n              if (rex.nfa_has_zsubexpr) {\n                copy_sub_off(&pim->subs.synt, &m->synt);\n              }\n            }\n          } else {\n            result = (pim->result == NFA_PIM_MATCH);\n#ifdef REGEXP_DEBUG\n            fprintf(log_fd, \"\\n\");\n            fprintf(\n                log_fd,\n                \"Using previous recursive nfa_regmatch() result, result == %d\\n\",\n                pim->result);\n            fprintf(log_fd, \"MATCH = %s\\n\", result ? \"OK\" : \"false\");\n            fprintf(log_fd, \"\\n\");\n#endif\n          }\n\n          // for \\@! and \\@<! it is a match when result is false\n          if (result != (pim->state->c == NFA_START_INVISIBLE_NEG\n                         || pim->state->c == NFA_START_INVISIBLE_NEG_FIRST\n                         || pim->state->c\n                         == NFA_START_INVISIBLE_BEFORE_NEG\n                         || pim->state->c\n                         == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)) {\n            // Copy submatch info from the recursive call\n            copy_sub_off(&t->subs.norm, &pim->subs.norm);\n            if (rex.nfa_has_zsubexpr) {\n              copy_sub_off(&t->subs.synt, &pim->subs.synt);\n            }\n          } else {\n            // look-behind match failed, don't add the state\n            continue;\n          }\n\n          // Postponed invisible match was handled, don't add it to\n          // following states.\n          pim = NULL;\n        }\n\n        // If \"pim\" points into l->t it will become invalid when\n        // adding the state causes the list to be reallocated.  Make a\n        // local copy to avoid that.\n        if (pim == &t->pim) {\n          copy_pim(&pim_copy, pim);\n          pim = &pim_copy;\n        }\n\n        if (add_here) {\n          r = addstate_here(thislist, add_state, &t->subs, pim, &listidx);\n        } else {\n          r = addstate(nextlist, add_state, &t->subs, pim, add_off);\n          if (add_count > 0) {\n            nextlist->t[nextlist->n - 1].count = add_count;\n          }\n        }\n        if (r == NULL) {\n          nfa_match = NFA_TOO_EXPENSIVE;\n          goto theend;\n        }\n      }\n    }     // for (thislist = thislist; thislist->state; thislist++)\n\n    // Look for the start of a match in the current position by adding the\n    // start state to the list of states.\n    // The first found match is the leftmost one, thus the order of states\n    // matters!\n    // Do not add the start state in recursive calls of nfa_regmatch(),\n    // because recursive calls should only start in the first position.\n    // Unless \"nfa_endp\" is not NULL, then we match the end position.\n    // Also don't start a match past the first line.\n    if (!nfa_match\n        && ((toplevel\n             && rex.lnum == 0\n             && clen != 0\n             && (rex.reg_maxcol == 0\n                 || (colnr_T)(rex.input - rex.line) < rex.reg_maxcol))\n            || (nfa_endp != NULL\n                && (REG_MULTI\n                    ? (rex.lnum < nfa_endp->se_u.pos.lnum\n                       || (rex.lnum == nfa_endp->se_u.pos.lnum\n                           && (int)(rex.input - rex.line)\n                           < nfa_endp->se_u.pos.col))\n                    : rex.input < nfa_endp->se_u.ptr)))) {\n#ifdef REGEXP_DEBUG\n      fprintf(log_fd, \"(---) STARTSTATE\\n\");\n#endif\n      // Inline optimized code for addstate() if we know the state is\n      // the first MOPEN.\n      if (toplevel) {\n        int add = true;\n\n        if (prog->regstart != NUL && clen != 0) {\n          if (nextlist->n == 0) {\n            colnr_T col = (colnr_T)(rex.input - rex.line) + clen;\n\n            // Nextlist is empty, we can skip ahead to the\n            // character that must appear at the start.\n            if (skip_to_start(prog->regstart, &col) == FAIL) {\n              break;\n            }\n#ifdef REGEXP_DEBUG\n            fprintf(log_fd, \"  Skipping ahead %d bytes to regstart\\n\",\n                    col - ((colnr_T)(rex.input - rex.line) + clen));\n#endif\n            rex.input = rex.line + col - clen;\n          } else {\n            // Checking if the required start character matches is\n            // cheaper than adding a state that won't match.\n            const int c = PTR2CHAR(rex.input + clen);\n            if (c != prog->regstart\n                && (!rex.reg_ic\n                    || utf_fold(c) != utf_fold(prog->regstart))) {\n#ifdef REGEXP_DEBUG\n              fprintf(log_fd,\n                  \"  Skipping start state, regstart does not match\\n\");\n#endif\n              add = false;\n            }\n          }\n        }\n\n        if (add) {\n          if (REG_MULTI) {\n            m->norm.list.multi[0].start_col =\n              (colnr_T)(rex.input - rex.line) + clen;\n          } else {\n            m->norm.list.line[0].start = rex.input + clen;\n          }\n          if (addstate(nextlist, start->out, m, NULL, clen) == NULL) {\n            nfa_match = NFA_TOO_EXPENSIVE;\n            goto theend;\n          }\n        }\n      } else {\n        if (addstate(nextlist, start, m, NULL, clen) == NULL) {\n          nfa_match = NFA_TOO_EXPENSIVE;\n          goto theend;\n        }\n      }\n    }\n\n#ifdef REGEXP_DEBUG\n    fprintf(log_fd, \">>> Thislist had %d states available: \", thislist->n);\n    {\n      int i;\n\n      for (i = 0; i < thislist->n; i++)\n        fprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));\n    }\n    fprintf(log_fd, \"\\n\");\n#endif\n\nnextchar:\n    // Advance to the next character, or advance to the next line, or\n    // finish.\n    if (clen != 0) {\n      rex.input += clen;\n    } else if (go_to_nextline || (nfa_endp != NULL && REG_MULTI\n                                  && rex.lnum < nfa_endp->se_u.pos.lnum)) {\n      reg_nextline();\n    } else {\n      break;\n    }\n\n    // Allow interrupting with CTRL-C.\n    line_breakcheck();\n    if (got_int) {\n      break;\n    }\n    // Check for timeout once every twenty times to avoid overhead.\n    if (nfa_time_limit != NULL && ++nfa_time_count == 20) {\n      nfa_time_count = 0;\n      if (nfa_did_time_out()) {\n        break;\n      }\n    }\n  }\n\n#ifdef REGEXP_DEBUG\n  if (log_fd != stderr)\n    fclose(log_fd);\n  log_fd = NULL;\n#endif\n\ntheend:\n  // Free memory\n  xfree(list[0].t);\n  xfree(list[1].t);\n  xfree(listids);\n#undef ADD_STATE_IF_MATCH\n#ifdef NFA_REGEXP_DEBUG_LOG\n  fclose(debug);\n#endif\n\n  return nfa_match;\n}\n\n// Try match of \"prog\" with at rex.line[\"col\"].\n// Returns <= 0 for failure, number of lines contained in the match otherwise.\nstatic long nfa_regtry(nfa_regprog_T *prog,\n                       colnr_T col,\n                       proftime_T *tm,    // timeout limit or NULL\n                       int *timed_out)    // flag set on timeout or NULL\n{\n  int i;\n  regsubs_T subs, m;\n  nfa_state_T *start = prog->start;\n#ifdef REGEXP_DEBUG\n  FILE        *f;\n#endif\n\n  rex.input = rex.line + col;\n  nfa_time_limit = tm;\n  nfa_timed_out = timed_out;\n  nfa_time_count = 0;\n\n#ifdef REGEXP_DEBUG\n  f = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n  if (f != NULL) {\n    fprintf(f,\n        \"\\n\\n\\t=======================================================\\n\");\n#ifdef REGEXP_DEBUG\n    fprintf(f, \"\\tRegexp is \\\"%s\\\"\\n\", nfa_regengine.expr);\n#endif\n    fprintf(f, \"\\tInput text is \\\"%s\\\" \\n\", rex.input);\n    fprintf(f, \"\\t=======================================================\\n\\n\");\n    nfa_print_state(f, start);\n    fprintf(f, \"\\n\\n\");\n    fclose(f);\n  } else {\n    EMSG(\"Could not open temporary log file for writing\");\n  }\n#endif\n\n  clear_sub(&subs.norm);\n  clear_sub(&m.norm);\n  clear_sub(&subs.synt);\n  clear_sub(&m.synt);\n\n  int result = nfa_regmatch(prog, start, &subs, &m);\n  if (!result) {\n    return 0;\n  } else if (result == NFA_TOO_EXPENSIVE) {\n    return result;\n  }\n\n  cleanup_subexpr();\n  if (REG_MULTI) {\n    for (i = 0; i < subs.norm.in_use; i++) {\n      rex.reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;\n      rex.reg_startpos[i].col = subs.norm.list.multi[i].start_col;\n\n      rex.reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;\n      rex.reg_endpos[i].col = subs.norm.list.multi[i].end_col;\n    }\n\n    if (rex.reg_startpos[0].lnum < 0) {\n      rex.reg_startpos[0].lnum = 0;\n      rex.reg_startpos[0].col = col;\n    }\n    if (rex.reg_endpos[0].lnum < 0) {\n      // pattern has a \\ze but it didn't match, use current end\n      rex.reg_endpos[0].lnum = rex.lnum;\n      rex.reg_endpos[0].col = (int)(rex.input - rex.line);\n    } else {\n      // Use line number of \"\\ze\".\n      rex.lnum = rex.reg_endpos[0].lnum;\n    }\n  } else {\n    for (i = 0; i < subs.norm.in_use; i++) {\n      rex.reg_startp[i] = subs.norm.list.line[i].start;\n      rex.reg_endp[i] = subs.norm.list.line[i].end;\n    }\n\n    if (rex.reg_startp[0] == NULL) {\n      rex.reg_startp[0] = rex.line + col;\n    }\n    if (rex.reg_endp[0] == NULL) {\n      rex.reg_endp[0] = rex.input;\n    }\n  }\n\n  /* Package any found \\z(...\\) matches for export. Default is none. */\n  unref_extmatch(re_extmatch_out);\n  re_extmatch_out = NULL;\n\n  if (prog->reghasz == REX_SET) {\n    cleanup_zsubexpr();\n    re_extmatch_out = make_extmatch();\n    // Loop over \\z1, \\z2, etc.  There is no \\z0.\n    for (i = 1; i < subs.synt.in_use; i++) {\n      if (REG_MULTI) {\n        struct multipos *mpos = &subs.synt.list.multi[i];\n\n        // Only accept single line matches that are valid.\n        if (mpos->start_lnum >= 0\n            && mpos->start_lnum == mpos->end_lnum\n            && mpos->end_col >= mpos->start_col) {\n          re_extmatch_out->matches[i] =\n            vim_strnsave(reg_getline(mpos->start_lnum) + mpos->start_col,\n                         mpos->end_col - mpos->start_col);\n        }\n      } else {\n        struct linepos *lpos = &subs.synt.list.line[i];\n\n        if (lpos->start != NULL && lpos->end != NULL)\n          re_extmatch_out->matches[i] =\n            vim_strnsave(lpos->start, lpos->end - lpos->start);\n      }\n    }\n  }\n\n  return 1 + rex.lnum;\n}\n\n/// Match a regexp against a string (\"line\" points to the string) or multiple\n/// lines (if \"line\" is NULL, use reg_getline()).\n///\n/// @param line String in which to search or NULL\n/// @param startcol Column to start looking for match\n/// @param tm Timeout limit or NULL\n/// @param timed_out Flag set on timeout or NULL\n///\n/// @return <= 0 if there is no match and number of lines contained in the\n/// match otherwise.\nstatic long nfa_regexec_both(char_u *line, colnr_T startcol,\n                             proftime_T *tm, int *timed_out)\n{\n  nfa_regprog_T   *prog;\n  long retval = 0L;\n  colnr_T col = startcol;\n\n  if (REG_MULTI) {\n    prog = (nfa_regprog_T *)rex.reg_mmatch->regprog;\n    line = reg_getline((linenr_T)0);  // relative to the cursor\n    rex.reg_startpos = rex.reg_mmatch->startpos;\n    rex.reg_endpos = rex.reg_mmatch->endpos;\n  } else {\n    prog = (nfa_regprog_T *)rex.reg_match->regprog;\n    rex.reg_startp = rex.reg_match->startp;\n    rex.reg_endp = rex.reg_match->endp;\n  }\n\n  /* Be paranoid... */\n  if (prog == NULL || line == NULL) {\n    IEMSG(_(e_null));\n    goto theend;\n  }\n\n  // If pattern contains \"\\c\" or \"\\C\": overrule value of rex.reg_ic\n  if (prog->regflags & RF_ICASE) {\n    rex.reg_ic = true;\n  } else if (prog->regflags & RF_NOICASE) {\n    rex.reg_ic = false;\n  }\n\n  // If pattern contains \"\\Z\" overrule value of rex.reg_icombine\n  if (prog->regflags & RF_ICOMBINE) {\n    rex.reg_icombine = true;\n  }\n\n  rex.line = line;\n  rex.lnum = 0;  // relative to line\n\n  rex.nfa_has_zend = prog->has_zend;\n  rex.nfa_has_backref = prog->has_backref;\n  rex.nfa_nsubexpr = prog->nsubexp;\n  rex.nfa_listid = 1;\n  rex.nfa_alt_listid = 2;\n#ifdef REGEXP_DEBUG\n  nfa_regengine.expr = prog->pattern;\n#endif\n\n  if (prog->reganch && col > 0)\n    return 0L;\n\n  rex.need_clear_subexpr = true;\n  // Clear the external match subpointers if necessary.\n  if (prog->reghasz == REX_SET) {\n    rex.nfa_has_zsubexpr = true;\n    rex.need_clear_zsubexpr = true;\n  } else {\n    rex.nfa_has_zsubexpr = false;\n    rex.need_clear_zsubexpr = false;\n  }\n\n  if (prog->regstart != NUL) {\n    /* Skip ahead until a character we know the match must start with.\n     * When there is none there is no match. */\n    if (skip_to_start(prog->regstart, &col) == FAIL)\n      return 0L;\n\n    // If match_text is set it contains the full text that must match.\n    // Nothing else to try. Doesn't handle combining chars well.\n    if (prog->match_text != NULL && !rex.reg_icombine) {\n      return find_match_text(col, prog->regstart, prog->match_text);\n    }\n  }\n\n  // If the start column is past the maximum column: no need to try.\n  if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol) {\n    goto theend;\n  }\n\n  // Set the \"nstate\" used by nfa_regcomp() to zero to trigger an error when\n  // it's accidentally used during execution.\n  nstate = 0;\n  for (int i = 0; i < prog->nstate; i++) {\n    prog->state[i].id = i;\n    prog->state[i].lastlist[0] = 0;\n    prog->state[i].lastlist[1] = 0;\n  }\n\n  retval = nfa_regtry(prog, col, tm, timed_out);\n\n#ifdef REGEXP_DEBUG\n  nfa_regengine.expr = NULL;\n#endif\n\ntheend:\n  if (retval > 0) {\n    // Make sure the end is never before the start.  Can happen when \\zs and\n    // \\ze are used.\n    if (REG_MULTI) {\n      const lpos_T *const start = &rex.reg_mmatch->startpos[0];\n      const lpos_T *const end = &rex.reg_mmatch->endpos[0];\n\n      if (end->lnum < start->lnum\n          || (end->lnum == start->lnum && end->col < start->col)) {\n        rex.reg_mmatch->endpos[0] = rex.reg_mmatch->startpos[0];\n      }\n    } else {\n      if (rex.reg_match->endp[0] < rex.reg_match->startp[0]) {\n        rex.reg_match->endp[0] = rex.reg_match->startp[0];\n      }\n    }\n  }\n\n  return retval;\n}\n\n/*\n * Compile a regular expression into internal code for the NFA matcher.\n * Returns the program in allocated space.  Returns NULL for an error.\n */\nstatic regprog_T *nfa_regcomp(char_u *expr, int re_flags)\n{\n  nfa_regprog_T       *prog = NULL;\n  int                 *postfix;\n\n  if (expr == NULL)\n    return NULL;\n\n#ifdef REGEXP_DEBUG\n  nfa_regengine.expr = expr;\n#endif\n  nfa_re_flags = re_flags;\n\n  init_class_tab();\n\n  nfa_regcomp_start(expr, re_flags);\n\n  // Build postfix form of the regexp. Needed to build the NFA\n  // (and count its size).\n  postfix = re2post();\n  if (postfix == NULL) {\n    goto fail;              // Cascaded (syntax?) error\n  }\n\n  /*\n   * In order to build the NFA, we parse the input regexp twice:\n   * 1. first pass to count size (so we can allocate space)\n   * 2. second to emit code\n   */\n#ifdef REGEXP_DEBUG\n  {\n    FILE *f = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n\n    if (f != NULL) {\n      fprintf(f,\n              \"\\n*****************************\\n\\n\\n\\n\\t\"\n              \"Compiling regexp \\\"%s\\\"... hold on !\\n\",\n              expr);\n      fclose(f);\n    }\n  }\n#endif\n\n  /*\n   * PASS 1\n   * Count number of NFA states in \"nstate\". Do not build the NFA.\n   */\n  post2nfa(postfix, post_ptr, true);\n\n  /* allocate the regprog with space for the compiled regexp */\n  size_t prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);\n  prog = xmalloc(prog_size);\n  state_ptr = prog->state;\n  prog->re_in_use = false;\n\n  /*\n   * PASS 2\n   * Build the NFA\n   */\n  prog->start = post2nfa(postfix, post_ptr, false);\n  if (prog->start == NULL) {\n    goto fail;\n  }\n  prog->regflags = regflags;\n  prog->engine = &nfa_regengine;\n  prog->nstate = nstate;\n  prog->has_zend = rex.nfa_has_zend;\n  prog->has_backref = rex.nfa_has_backref;\n  prog->nsubexp = regnpar;\n\n  nfa_postprocess(prog);\n\n  prog->reganch = nfa_get_reganch(prog->start, 0);\n  prog->regstart = nfa_get_regstart(prog->start, 0);\n  prog->match_text = nfa_get_match_text(prog->start);\n\n#ifdef REGEXP_DEBUG\n  nfa_postfix_dump(expr, OK);\n  nfa_dump(prog);\n#endif\n  /* Remember whether this pattern has any \\z specials in it. */\n  prog->reghasz = re_has_z;\n  prog->pattern = vim_strsave(expr);\n#ifdef REGEXP_DEBUG\n  nfa_regengine.expr = NULL;\n#endif\n\nout:\n  xfree(post_start);\n  post_start = post_ptr = post_end = NULL;\n  state_ptr = NULL;\n  return (regprog_T *)prog;\n\nfail:\n  XFREE_CLEAR(prog);\n#ifdef REGEXP_DEBUG\n  nfa_postfix_dump(expr, FAIL);\n  nfa_regengine.expr = NULL;\n#endif\n  goto out;\n}\n\n/*\n * Free a compiled regexp program, returned by nfa_regcomp().\n */\nstatic void nfa_regfree(regprog_T *prog)\n{\n  if (prog != NULL) {\n    xfree(((nfa_regprog_T *)prog)->match_text);\n    xfree(((nfa_regprog_T *)prog)->pattern);\n    xfree(prog);\n  }\n}\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" is a compiled regexp as returned by nfa_regcomp().\n * Uses curbuf for line count and 'iskeyword'.\n * If \"line_lbr\" is true, consider a \"\\n\" in \"line\" to be a line break.\n *\n * Returns <= 0 for failure, number of lines contained in the match otherwise.\n */\nstatic int \nnfa_regexec_nl (\n    regmatch_T *rmp,\n    char_u *line,      /* string to match against */\n    colnr_T col,       /* column to start looking for match */\n    bool line_lbr\n)\n{\n  rex.reg_match = rmp;\n  rex.reg_mmatch = NULL;\n  rex.reg_maxline = 0;\n  rex.reg_line_lbr = line_lbr;\n  rex.reg_buf = curbuf;\n  rex.reg_win = NULL;\n  rex.reg_ic = rmp->rm_ic;\n  rex.reg_icombine = false;\n  rex.reg_maxcol = 0;\n  return nfa_regexec_both(line, col, NULL, NULL);\n}\n\n/// Matches a regexp against multiple lines.\n/// \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n/// Uses curbuf for line count and 'iskeyword'.\n///\n/// @param win Window in which to search or NULL\n/// @param buf Buffer in which to search\n/// @param lnum Number of line to start looking for match\n/// @param col Column to start looking for match\n/// @param tm Timeout limit or NULL\n/// @param timed_out Flag set on timeout or NULL\n///\n/// @return <= 0 if there is no match and number of lines contained in the match\n/// otherwise.\n///\n/// @note The body is the same as bt_regexec() except for nfa_regexec_both()\n///\n/// @warning\n/// Match may actually be in another line. e.g.:\n/// when r.e. is \\nc, cursor is at 'a' and the text buffer looks like\n///\n/// @par\n///\n///     +-------------------------+\n///     |a                        |\n///     |b                        |\n///     |c                        |\n///     |                         |\n///     +-------------------------+\n///\n/// @par\n/// then nfa_regexec_multi() returns 3. while the original vim_regexec_multi()\n/// returns 0 and a second call at line 2 will return 2.\n///\n/// @par\n/// FIXME if this behavior is not compatible.\nstatic long nfa_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf,\n                              linenr_T lnum, colnr_T col,\n                              proftime_T *tm, int *timed_out)\n{\n  rex.reg_match = NULL;\n  rex.reg_mmatch = rmp;\n  rex.reg_buf = buf;\n  rex.reg_win = win;\n  rex.reg_firstlnum = lnum;\n  rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;\n  rex.reg_line_lbr = false;\n  rex.reg_ic = rmp->rmm_ic;\n  rex.reg_icombine = false;\n  rex.reg_maxcol = rmp->rmm_maxcol;\n\n  return nfa_regexec_both(NULL, col, tm, timed_out);\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 0, "line": 1274}, "message": "Assuming 'expr' is not equal to NULL"}, {"location": {"col": 7, "file": 0, "line": 1286}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 0, "line": 1299}, "message": "Assuming the condition is false"}, {"location": {"col": 43, "file": 0, "line": 1299}, "message": "Assuming 'reg_toolong' is 0"}, {"location": {"col": 7, "file": 0, "line": 1312}, "message": "Assuming the condition is false"}, {"location": {"col": 7, "file": 0, "line": 1314}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 1318}, "message": "Null pointer value stored to 'scan'"}, {"location": {"col": 7, "file": 0, "line": 1319}, "message": "Null pointer passed to 1st parameter expecting 'nonnull'"}], "macros": [{"location": {"col": 7, "file": 0, "line": 1319}, "expansion": "((int)*(regnext(scan)))", "name": "OP"}], "notes": [], "path": "src/nvim/regexp.c", "reportHash": "52179308a1ef84ba881e0ff871cc960c", "checkerName": "core.NonNullParamChecker", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"col": 7, "file": 1, "line": 3006}, "message": "Assuming 'postfix' is not equal to NULL"}, {"location": {"col": 7, "file": 1, "line": 3017}, "message": "Assuming 'nfa_calc_size' is not equal to false"}, {"location": {"col": 21, "file": 1, "line": 3024}, "message": "Assuming 'p' is >= 'end'"}, {"location": {"col": 21, "file": 1, "line": 3024}, "message": "Loop body executed 0 times"}, {"location": {"col": 7, "file": 1, "line": 3442}, "message": "Assuming 'nfa_calc_size' is not equal to true"}, {"location": {"col": 7, "file": 1, "line": 3447}, "message": "Calling 'st_pop'"}, {"location": {"col": 1, "file": 1, "line": 2772}, "message": "Entered call from 'post2nfa'"}, {"location": {"col": 3, "file": 1, "line": 2776}, "message": "Null pointer value stored to 'stackp'"}, {"location": {"col": 10, "file": 1, "line": 2780}, "message": "Dereference of null pointer"}], "macros": [{"location": {"col": 7, "file": 1, "line": 3447}, "expansion": "st_pop(&stackp, stack); if (stackp < stack) { st_error(postfix, end, p); xfree(stack); return((void*)0); }", "name": "POP"}], "notes": [], "path": "src/nvim/regexp_nfa.c", "reportHash": "a7e2d75532e5438937a5c7097a0bad93", "checkerName": "core.NullDereference", "reviewStatus": null, "severity": "HIGH"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
